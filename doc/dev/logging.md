# Logging System Documentation

This document provides a comprehensive analysis of the logging architecture throughout the entire lab project, explaining the relationship between different logging systems and how they work together.

## Overview

The lab system implements a **multi-layered logging architecture** with three distinct but integrated logging systems:

1. **Enhanced Auxiliary Logging** (`lib/gen/aux`) - **PRIMARY** system for all `lib/ops` functions and modern structured logging
2. **Core Module Logging** (`lib/core/lo1`, `lib/core/err`, `lib/core/tme`) - Legacy system for core infrastructure
3. **Initialization Logging** (`bin/ini`, `lib/core/ver`) - Bootstrap and verification specific logging

### Logging System Hierarchy

```
┌─────────────────────────────────────────────────────────────────┐
│ Enhanced Auxiliary Logging (lib/gen/aux) - PRIMARY SYSTEM      │
│ ├─ All lib/ops functions use structured logging                 │
│ ├─ Supports JSON, CSV, key-value, and human formats            │
│ ├─ Enterprise-grade features: tracing, metrics, cluster info   │
│ └─ Files: aux_operational.{log,jsonl,csv}, aux_debug.{log,jsonl,csv} │
├─────────────────────────────────────────────────────────────────┤
│ Component Orchestrator (bin/orc) - Uses lo1 Logging            │
│ └─ File: lo1.log                                               │
├─────────────────────────────────────────────────────────────────┤
│ Core Infrastructure Logging (lib/core/*)                       │
│ ├─ lo1.log - Advanced hierarchical logging with colors         │
│ ├─ err.log - Centralized error handling                        │
│ ├─ tme.log - Timing and performance data                       │
│ └─ State files in .tmp/ for runtime configuration              │
├─────────────────────────────────────────────────────────────────┤
│ Initialization & Bootstrap (bin/ini, lib/core/ver)              │
│ ├─ ini.log - Startup sequence and module loading               │
│ ├─ ver.log - System verification and validation                │
│ └─ init_flow.log - High-precision initialization timing        │
└─────────────────────────────────────────────────────────────────┘
```

### Verbosity Control Hierarchy

The system uses **hierarchical verbosity controls** with a master switch pattern:

- **`MASTER_TERMINAL_VERBOSITY`** (default: "off") - Global terminal output control
- **Module-specific switches** - Individual controls that require master to be "on":
  - `INI_LOG_TERMINAL_VERBOSITY` - Initialization messages
  - `VER_LOG_TERMINAL_VERBOSITY` - Verification messages  
  - `LO1_LOG_TERMINAL_VERBOSITY` - Advanced logging output
  - `ERR_TERMINAL_VERBOSITY` - Error messages
  - `TME_TERMINAL_VERBOSITY` - Timing reports
- **Enhanced auxiliary controls** - Independent system with own verbosity:
  - `AUX_DEBUG_ENABLED` - Controls aux debug output
  - Independent of other verbosity systems but respects `MASTER_TERMINAL_VERBOSITY`

## Log Files Generated

### Enhanced Auxiliary Logging Files (`lib/gen/aux`)

The **primary logging system** used by all `lib/ops` functions and modern components:

**Consolidated Logs (All Events)**:
- **`aux.log`** - Human-readable format for all events (operational, debug, business logic)
- **`aux.json`** - JSON Lines format for structured log aggregation (Elasticsearch, etc.)
- **`aux.csv`** - CSV format for data analysis tools (optional, when AUX_LOG_FORMAT=csv)

**Generated by functions**:
- `aux_log()` - General operational logging with explicit levels
- `aux_info()`, `aux_warn()`, `aux_err()` - Convenience operational functions
- `aux_business()`, `aux_security()`, `aux_audit()`, `aux_perf()` - Specialized logging
- `aux_dbg()` - Development and debug logging (now consolidated into same files)

**Format control**: Set via `AUX_LOG_FORMAT` environment variable:
- `json` - Structured JSON with cluster metadata (writes to aux.json)
- `csv` - Comma-separated values with headers (writes to aux.csv) 
- `kv` - Key-value pairs (Splunk-compatible, writes to aux.log)
- `human` - Default colored terminal format (writes to aux.log)

**Consolidation Notes**:
- All auxiliary logging (operational, debug, business, security, etc.) is now consolidated into the same files
- Debug messages from `aux_dbg()` are written to the same files as operational messages from `aux_log()`
- Message types are distinguished by log level and type metadata in structured formats

### Core Infrastructure Logs (`lib/core/*`)

**`lo1.log`**:
- **Purpose**: Advanced hierarchical logging with color-coded indentation
- **Used by**: `bin/orc` (Component Orchestrator) and other core infrastructure
- **Format**: `HH:MM:SS.NN └─ message` with colored depth visualization
- **Features**: 16-level color gradient, call stack depth caching, timing integration
- **Control**: `setlog on|off` command, state persisted in `.tmp/lo1_state`

**`err.log`**:
- **Purpose**: Centralized error and warning repository
- **Format**: `[SEVERITY] YYYY-MM-DD HH:MM:SS - [component] message`
- **Functions**: `handle_error()`, `error_handler()`, `err_process()`
- **Features**: Severity levels, component tracking, error statistics

**`tme.log`**:
- **Purpose**: Timing and performance measurement data
- **Functions**: `tme_start_timer()`, `tme_end_timer()`, `tme_print_timing_report()`
- **Features**: Hierarchical timing, configurable reports, performance analysis

### Initialization and Bootstrap Logs

**`ini.log`**:
- **Purpose**: Main initialization script (`bin/ini`) logging
- **Format**: `[INI] HH:MM:SS - [source_function] message`
- **Function**: `ini_log()` embedded in `bin/ini`
- **Usage**: Startup sequence debugging, module loading issues

**`ver.log`**:
- **Purpose**: System verification and validation logging
- **Format**: `[VER] YYYY-MM-DD HH:MM:SS - [source_function] message`
- **Function**: `ver_log()` in `lib/core/ver`
- **Usage**: Path verification, module integrity checks, dependency validation

**`init_flow.log`**:
- **Purpose**: High-precision initialization timing and flow tracking
- **Format**: `INIT_SCRIPT_FLOW: [description] - HH:MM:SS.NNNNNNNNN`
- **Usage**: Correlating initialization timing, diagnosing startup performance

## State and Configuration Files (`.tmp/`)

### Enhanced Auxiliary System State

The auxiliary logging system is **stateless by design** - it requires no persistent state files and is controlled entirely through environment variables:

- **`AUX_LOG_FORMAT`** - Controls output format (json|csv|kv|human)
- **`AUX_DEBUG_ENABLED`** - Controls debug output (1|0)
- **`MASTER_TERMINAL_VERBOSITY`** - Master terminal control (on|off)

### Core Logging State Files

**`lo1_state`**:
- **Purpose**: Persistent on/off state for lo1 logging system
- **Values**: "on" | "off"
- **Control**: `setlog on|off` command
- **Default**: "on" if missing

**`lo1_depth_cache`**:
- **Purpose**: Performance cache for call stack depth calculations
- **Usage**: Automatically managed by lo1 for hierarchical indentation
- **Cleanup**: Automatic every 300 seconds

### Timing System State Files

**`tme_state`**:
- **Purpose**: Controls timing report generation
- **Values**: "true" | "false"
- **Control**: `tme_settme report on|off`

**`tme_levels`**:
- **Purpose**: Maximum depth for timing report hierarchy
- **Values**: Integer 1-9
- **Control**: `tme_settme depth N`

**`tme_sort_order`**:
- **Purpose**: Sort order for timing reports
- **Values**: "chron" | "duration" 
- **Control**: `tme_settme sort chron|duration`

## Environment Variables and Configuration

### Directory Configuration (`cfg/core/ric`)

```bash
# Base directories (can be overridden)
LOG_DIR="${LOG_DIR:-${LAB_DIR}/.log}"     # Log file location
TMP_DIR="${TMP_DIR:-${LAB_DIR}/.tmp}"     # State file location

# Core infrastructure log files
ERROR_LOG="${LOG_DIR}/err.log"            # Error log
INI_LOG_FILE="${LOG_DIR}/ini.log"         # Initialization log
VER_LOG_FILE="${LOG_DIR}/ver.log"         # Verification log
LOG_FILE="${LOG_DIR}/lo1.log"             # Advanced logging
TME_LOG_FILE="${LOG_DIR}/tme.log"         # Timing log

# Enhanced auxiliary logs (auto-generated by lib/gen/aux) - CONSOLIDATED
# aux.log                                 # All events (operational & debug)
# aux.json                                # JSON format for all events
# aux.csv                                 # CSV format (when AUX_LOG_FORMAT=csv)

# State file paths
LOG_STATE_FILE="${TMP_DIR}/lo1_state"     # Lo1 on/off state
TME_STATE_FILE="${TMP_DIR}/tme_state"     # Timing report state
TME_LEVELS_FILE="${TMP_DIR}/tme_levels"   # Timing report depth
```

### Enhanced Auxiliary Logging Configuration

```bash
# Output format control
export AUX_LOG_FORMAT="json"              # json|csv|kv|human

# Debug output control
export AUX_DEBUG_ENABLED="1"              # 1=enable, 0=disable

# Cluster metadata (for distributed systems)
export CLUSTER_ID="production-cluster-01"
export SERVICE_NAME="user-service"
export NODE_ID="${HOSTNAME}"

# Performance metrics integration
export METRICS_ENDPOINT="http://metrics-server:8080"

# Distributed tracing (auto-generated when using aux_start_trace)
# TRACE_ID - Correlation ID for request tracing
# REQUEST_ID - Unique request identifier
```

### Core Infrastructure Logging Controls

```bash
# Master control (default: "off")
MASTER_TERMINAL_VERBOSITY="off"

# Module-specific controls (require master "on")
INI_LOG_TERMINAL_VERBOSITY="on"          # Initialization messages
VER_LOG_TERMINAL_VERBOSITY="on"          # Verification messages  
LO1_LOG_TERMINAL_VERBOSITY="on"          # Advanced logging
ERR_TERMINAL_VERBOSITY="on"              # Error messages
TME_TERMINAL_VERBOSITY="on"              # Timing reports

# Lo1 debug message generation
LOG_DEBUG_ENABLED=1                       # 1=enable, 0=disable lo1 debug

# TME nested controls (require both master and TME "on")
TME_REPORT_TERMINAL_OUTPUT="on"          # Timing reports
TME_TIMING_TERMINAL_OUTPUT="on"          # Timing measurements
TME_DEBUG_TERMINAL_OUTPUT="on"           # Debug information
TME_STATUS_TERMINAL_OUTPUT="on"          # Status updates
```

## Function Reference by Logging System

### Enhanced Auxiliary Logging (`lib/gen/aux`) - PRIMARY SYSTEM

**Operational Logging Functions**:
```bash
# General operational logging with explicit levels
aux_log "INFO" "Service started successfully" "user_count=150,status=active"
aux_log "ERROR" "Database connection failed" "host=db.example.com,timeout=30s"

# Convenience functions for common levels
aux_info "User authentication successful" "user_id=123,method=oauth"
aux_warn "Configuration file not found, using defaults" "file=/etc/app.conf"
aux_err "Failed to process request" "request_id=abc123,error=timeout"

# Specialized logging for specific domains
aux_business "Order completed successfully" "order_id=12345,amount=99.99,customer=premium"
aux_security "Failed login attempt" "ip=192.168.1.100,user=admin,attempts=3"
aux_audit "Admin privileges granted" "admin=john,target_user=jane,permissions=write"
aux_perf "Database query completed" "duration=250ms,table=users,rows=150"
```

**Development and Debug Logging**:
```bash
# Automatic function context capture
aux_dbg "Starting validation process"               # Auto-captures calling function
aux_dbg "Found 5 items in configuration" "INFO"    # Optional severity level
aux_dbg "Variable state: count=$count, status=$status"

# Distributed tracing
aux_start_trace "user_registration"               # Generates correlation IDs
aux_dbg "Processing user data"                     # Includes trace context
aux_end_trace                                      # Closes trace span

# Performance metrics
aux_metric "response_time" 125.5 "gauge"          # Performance monitoring
aux_metric "cache_hits" 8543 "counter"            # Operational metrics
```

**Key Features**:
- **Structured Context**: All functions support `key=value,key2=value2` context data
- **Multiple Formats**: Automatic output in JSON, CSV, key-value, or human-readable
- **Cluster Metadata**: Automatic collection of node, cluster, and service information
- **Independent Operation**: No dependencies on other logging systems
- **Production Ready**: Designed for centralized log aggregation and monitoring

### Core Infrastructure Logging (`lib/core/*`)

**Advanced Logging Module (`lib/core/lo1`)**:
```bash
# Main logging interface (used by bin/orc)
log lvl "Component initialization completed"

# Module logging interface
lo1_log_message "Service started" 1 "orchestrator"

# Runtime control
setlog on                                          # Enable logging output
setlog off                                         # Disable logging output

# Debug logging (internal)
lo1_debug_log "Cache updated" "component_name"
```

**Error Handling (`lib/core/err`)**:
```bash
# Structured error logging
handle_error "Operation failed" "gpu_module" 1 "ERROR"

# Automatic trap handler (set via trap)
error_handler "$LINENO" "${ERROR_CODES[EXECUTION_FAILED]}" "false"

# Error reporting
print_error_report                                 # Generate error summary
```

**Timing Module (`lib/core/tme`)**:
```bash
# Timer management
tme_start_timer "component_name" "parent_component"
tme_end_timer "component_name" "success"

# Report generation
tme_print_timing_report                            # Generate performance report

# Configuration
tme_settme report on|off                           # Control reports
tme_settme sort chron|duration                     # Set sort order
tme_settme depth 1-9                               # Set report depth
```

### Initialization Logging

**Initialization Script (`bin/ini`)**:
```bash
# Internal logging function (embedded in bin/ini)
ini_log "Module loading completed" "init_system" "$LOG_PRIORITY_NORMAL"
```

**Verification Module (`lib/core/ver`)**:
```bash
# System verification logging
ver_log "Path validation completed" "verify_paths" 1
```

## Usage Patterns and Best Practices

### For New lib/ops Functions

**REQUIRED**: All `lib/ops` functions must use the enhanced auxiliary logging system according to the `.spec` standard:

```bash
#!/bin/bash
# Source the enhanced logging system
source lib/gen/aux

# Example GPU passthrough function
gpu_passthrough() {
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    local gpu_id="$1"
    local host="$2"
    local driver="$3"
    
    # Entry logging
    aux_info "GPU passthrough initiated" "gpu_id=$gpu_id,host=$host,driver=$driver"
    
    # Business logic with error handling
    if ! validate_gpu "$gpu_id"; then
        aux_err "GPU validation failed" "gpu_id=$gpu_id,error=device_not_found"
        return 1
    fi
    
    # Debug information
    aux_dbg "GPU device located and validated"
    
    # Performance tracking
    aux_start_trace "gpu_passthrough_${gpu_id}"
    
    # Execute operations with audit trail
    aux_audit "GPU driver binding initiated" "gpu_id=$gpu_id,driver=$driver,admin=$USER"
    
    # Success logging
    aux_business "GPU passthrough completed" "gpu_id=$gpu_id,host=$host,status=active"
    aux_end_trace
}
```

### For Core Infrastructure

Use `lib/core/lo1` for orchestration and core system components:

```bash
# In bin/orc or similar infrastructure code
lo1_log "lvl" "Component orchestration started"
tme_start_timer "component_setup"

# Execute components with timing
execute_component "source_lib_ops" "LIB_OPS" "$COMPONENT_REQUIRED"

lo1_log "lvl" "All components initialized successfully"
tme_end_timer "component_setup" "success"
```

### For Initialization and Bootstrap

Use specific initialization logging for startup sequences:

```bash
# In bin/ini
ini_log "Loading core modules" "bootstrap" "$LOG_PRIORITY_NORMAL"

# In lib/core/ver
ver_log "Verifying system dependencies" "verify_deps" 1
```

## Configuration Scenarios

### Development Environment

```bash
# Enable all logging for comprehensive debugging
export MASTER_TERMINAL_VERBOSITY="on"
export AUX_DEBUG_ENABLED="1"
export AUX_LOG_FORMAT="human"
export LOG_DEBUG_ENABLED="1"

# Enhanced auxiliary functions provide rich debug output
aux_dbg "Development mode enabled"
setlog on  # Enable lo1 output
```

### Production Environment

```bash
# Structured logging for centralized aggregation
export AUX_LOG_FORMAT="json"
export CLUSTER_ID="production-cluster-01"
export SERVICE_NAME="lab-ops"

# Silent terminal, structured logs only
export MASTER_TERMINAL_VERBOSITY="off"
export AUX_DEBUG_ENABLED="0"

# Production operations logged in structured format
aux_business "Service deployment completed" "version=2.1.0,environment=production"
```

### Testing Environment

```bash
# Mixed approach - structured output with selective terminal
export AUX_LOG_FORMAT="json"
export MASTER_TERMINAL_VERBOSITY="on"
export ERR_TERMINAL_VERBOSITY="on"      # Errors to terminal
export AUX_DEBUG_ENABLED="1"            # Debug to files

# Testing with both systems
aux_info "Test suite started" "suite=integration,test_count=25"
lo1_log "lvl" "Test infrastructure initialized"
```

## Log File Analysis Workflow

### 1. Current System Status

```bash
# Check enhanced auxiliary logs (primary system)
tail -f "${LOG_DIR}/aux_operational.log"           # Human-readable operations
jq . "${LOG_DIR}/aux_operational.jsonl"            # Structured operational data
tail -f "${LOG_DIR}/aux_debug.log"                 # Development debug output

# Check core infrastructure
tail -f "${LOG_DIR}/lo1.log"                       # Orchestration and core systems
tail -f "${LOG_DIR}/err.log"                       # Error analysis
```

### 2. Initialization Issues

```bash
# Startup sequence analysis
tail -f "${LOG_DIR}/init_flow.log"                 # High-precision timing
tail -f "${LOG_DIR}/ini.log"                       # Initialization details
tail -f "${LOG_DIR}/ver.log"                       # Verification failures
```

### 3. Performance Analysis

```bash
# Timing and performance
tail -f "${LOG_DIR}/tme.log"                       # Core system timing
grep "aux_perf\|aux_metric" "${LOG_DIR}/aux_operational.log"  # Application performance
```

### 4. Security and Audit

```bash
# Security events
grep "aux_security\|aux_audit" "${LOG_DIR}/aux_operational.log"
jq 'select(.level=="security" or .level=="audit")' "${LOG_DIR}/aux_operational.jsonl"
```

## Migration from Legacy Documentation

The previous logging documentation described a legacy architecture. Key changes:

**REPLACED**:
- Complex hierarchical verbosity matrices
- Legacy module dependencies
- Outdated file references

**ENHANCED**:
- **Primary focus on enhanced auxiliary logging** (`lib/gen/aux`)
- **Clear separation of concerns** between logging systems
- **Production-ready structured logging** with enterprise features
- **Simplified configuration** with environment variables
- **Modern observability features** (tracing, metrics, cluster metadata)

**CURRENT STATE**:
- All `lib/ops` functions use enhanced auxiliary logging
- Core infrastructure uses `lib/core/lo1` system  
- Initialization uses specialized bootstrap logging
- All systems coexist and serve different purposes

This architecture provides both **development agility** (through comprehensive debug logging) and **operational excellence** (through structured, aggregatable logs) while maintaining **backward compatibility** with existing core infrastructure.
