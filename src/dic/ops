#!/bin/bash

# ============================================================================
# DEPENDENCY INJECTION CONTAINER - GENERIC OPERATIONS ENGINE
# ============================================================================
#
# DESCRIPTION:
#   This is the main entry point for the Dependency Injection Container (DIC)
#   system. It provides a generic interface for executing library functions
#   with automatic variable injection based on naming conventions and
#   configuration mappings.
#
# ARCHITECTURE:
#   ┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
#   │   User Command  │ -> │  Generic Engine  │ -> │  Pure Function  │
#   │   ops pve vpt   │    │   src/dic/ops    │    │  lib/ops/pve    │
#   └─────────────────┘    └──────────────────┘    └─────────────────┘
#                                   │
#                                   v
#                          ┌──────────────────┐
#                          │  Auto-Injection  │
#                          │  • Convention    │
#                          │  • Configuration │
#                          │  • Introspection │
#                          └──────────────────┘
#
# USAGE:
#   ops MODULE FUNCTION [ARGS...]
#   ops pve vpt 100 on              # Enable passthrough for VM 100
#   ops gpu vck 101                 # Check GPU configuration for VM 101
#   ops sys sca usr all             # System scan all users
#   ops --list                      # List all available modules
#   ops MODULE --list               # List functions in specific module
#   ops MODULE FUNCTION --help      # Show function help
#
# ENVIRONMENT VARIABLES:
#   OPS_DEBUG=1          # Enable debug output
#   OPS_VALIDATE=strict  # Validation level (strict|warn|silent)
#   OPS_CACHE=1          # Enable caching (default: 1)
#   OPS_METHOD=auto      # Injection method (auto|convention|config|custom)
#
# ============================================================================

# Get the directory of this script
DIC_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
DIC_LIB_DIR="${DIC_DIR}/lib"
DIC_CONFIG_DIR="${DIC_DIR}/config"

# Source DIC libraries
source "${DIC_LIB_DIR}/injector"
source "${DIC_LIB_DIR}/introspector"
source "${DIC_LIB_DIR}/resolver"

# Default configuration
OPS_DEBUG=${OPS_DEBUG:-0}
OPS_VALIDATE=${OPS_VALIDATE:-warn}
OPS_CACHE=${OPS_CACHE:-1}
OPS_METHOD=${OPS_METHOD:-auto}

# Cache for function signatures and variable resolutions
declare -A FUNCTION_SIGNATURE_CACHE
declare -A VARIABLE_RESOLUTION_CACHE

# ============================================================================
# CORE FUNCTIONS
# ============================================================================

# Main operations dispatcher
ops_main() {
    local module="$1"
    local function="$2"
    shift 2
    
    # Handle special commands
    case "$module" in
        --help|-h)
            ops_show_help
            return 0
            ;;
        --list|-l)
            ops_list_modules
            return 0
            ;;
        --debug)
            OPS_DEBUG=1
            ops_main "$@"
            return $?
            ;;
        "")
            echo "Error: No module specified"
            ops_show_usage
            return 1
            ;;
    esac
    
    # Handle module-specific commands
    case "$function" in
        --list|-l)
            ops_list_functions "$module"
            return 0
            ;;
        --help|-h)
            ops_show_module_help "$module"
            return 0
            ;;
        "")
            echo "Error: No function specified for module '$module'"
            ops_show_usage
            return 1
            ;;
    esac
    
    # Handle function-specific commands
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        ops_show_function_help "$module" "$function"
        return 0
    fi
    
    # Execute the operation
    ops_execute "$module" "$function" "$@"
}

# Execute operation with dependency injection
ops_execute() {
    local module="$1"
    local function="$2"
    shift 2
    
    local full_function="${module}_${function}"
    
    ops_debug "Executing: $full_function with args: $*"
    
    # Validate module and function exist
    if ! ops_validate_operation "$module" "$function"; then
        return 1
    fi
    
    # Source the library module
    local lib_path="${LIB_OPS_DIR}/${module}"
    if [[ ! -f "$lib_path" ]]; then
        echo "Error: Library module not found: $lib_path"
        return 1
    fi
    
    source "$lib_path"
    
    # Check if function exists
    if ! declare -f "$full_function" >/dev/null 2>&1; then
        echo "Error: Function '$full_function' not found in module '$module'"
        return 1
    fi
    
    # Perform dependency injection and execute
    ops_inject_and_execute "$full_function" "$@"
}

# Inject dependencies and execute function
ops_inject_and_execute() {
    local function_name="$1"
    shift
    
    ops_debug "Injecting dependencies for: $function_name"
    
    # Get function signature
    local signature
    if ! signature=$(ops_get_function_signature "$function_name"); then
        echo "Error: Could not analyze function signature for '$function_name'"
        return 1
    fi
    
    ops_debug "Function signature: $signature"
    
    # Resolve variables based on method
    local resolved_vars
    case "$OPS_METHOD" in
        convention)
            resolved_vars=$(ops_resolve_by_convention "$function_name" "$signature")
            ;;
        config)
            resolved_vars=$(ops_resolve_by_config "$function_name" "$signature")
            ;;
        custom)
            resolved_vars=$(ops_resolve_by_custom "$function_name" "$signature")
            ;;
        auto|*)
            # Try convention first, then config, then custom
            resolved_vars=$(ops_resolve_by_convention "$function_name" "$signature")
            if [[ -z "$resolved_vars" ]]; then
                resolved_vars=$(ops_resolve_by_config "$function_name" "$signature")
            fi
            if [[ -z "$resolved_vars" ]]; then
                resolved_vars=$(ops_resolve_by_custom "$function_name" "$signature")
            fi
            ;;
    esac
    
    ops_debug "Resolved variables: $resolved_vars"
    
    # Validate required variables
    if ! ops_validate_variables "$function_name" "$resolved_vars"; then
        return 1
    fi
    
    # Execute function with injected variables and user arguments
    ops_debug "Executing: $function_name $resolved_vars $*"
    eval "$function_name $resolved_vars \"\$@\""
}

# ============================================================================
# VALIDATION FUNCTIONS
# ============================================================================

# Validate that operation exists
ops_validate_operation() {
    local module="$1"
    local function="$2"
    
    # Check if LIB_OPS_DIR is set
    if [[ -z "$LIB_OPS_DIR" ]]; then
        echo "Error: LIB_OPS_DIR not set. Please run 'source bin/ini' first."
        return 1
    fi
    
    # Check if module exists
    if [[ ! -f "${LIB_OPS_DIR}/${module}" ]]; then
        echo "Error: Module '$module' not found in ${LIB_OPS_DIR}/"
        echo "Available modules:"
        ops_list_modules
        return 1
    fi
    
    return 0
}

# Validate resolved variables
ops_validate_variables() {
    local function_name="$1"
    local resolved_vars="$2"
    
    case "$OPS_VALIDATE" in
        strict)
            # Check for empty variables
            for var in $resolved_vars; do
                if [[ "$var" == '""' || "$var" == "''" ]]; then
                    echo "Error: Required variable is empty for function '$function_name'"
                    return 1
                fi
            done
            ;;
        warn)
            # Warn about empty variables
            for var in $resolved_vars; do
                if [[ "$var" == '""' || "$var" == "''" ]]; then
                    echo "Warning: Variable is empty for function '$function_name': $var"
                fi
            done
            ;;
        silent)
            # No validation
            ;;
    esac
    
    return 0
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Show main help
ops_show_help() {
    cat << 'EOF'
Dependency Injection Container (DIC) - Generic Operations Engine

USAGE:
    ops MODULE FUNCTION [ARGS...]       Execute operation with auto-injection
    ops --list                          List all available modules
    ops MODULE --list                   List functions in specific module
    ops MODULE FUNCTION --help          Show function help
    ops --debug MODULE FUNCTION ARGS    Execute with debug output

EXAMPLES:
    ops pve vpt 100 on                  Enable passthrough for VM 100
    ops gpu vck 101                     Check GPU configuration for VM 101
    ops sys sca usr all                 System scan all users
    ops pve --list                      List all PVE functions
    ops pve vpt --help                  Show help for pve_vpt function

ENVIRONMENT VARIABLES:
    OPS_DEBUG=1                         Enable debug output
    OPS_VALIDATE=strict                 Validation level (strict|warn|silent)
    OPS_CACHE=1                         Enable caching (default)
    OPS_METHOD=auto                     Injection method (auto|convention|config)

DEPENDENCY INJECTION:
    The DIC automatically injects global variables into pure library functions
    based on naming conventions and configuration mappings:
    
    - Convention: vm_id → VM_ID, cluster_nodes → CLUSTER_NODES
    - Configuration: Complex mappings defined in config files
    - Hostname-specific: pci0_id → ${hostname}_NODE_PCI0
    
    This eliminates the need for individual wrapper functions while maintaining
    the same functionality as the src/mgt/ approach.

For more information, see: src/dic/README.md
EOF
}

# Show usage
ops_show_usage() {
    echo "Usage: ops MODULE FUNCTION [ARGS...]"
    echo "Try 'ops --help' for more information."
}

# List available modules
ops_list_modules() {
    echo "Available modules:"
    if [[ -d "$LIB_OPS_DIR" ]]; then
        for module in "$LIB_OPS_DIR"/*; do
            if [[ -f "$module" ]]; then
                local module_name=$(basename "$module")
                echo "  $module_name"
            fi
        done
    else
        echo "  Error: LIB_OPS_DIR not found. Please run 'source bin/ini' first."
    fi
}

# List functions in a module
ops_list_functions() {
    local module="$1"
    local lib_path="${LIB_OPS_DIR}/${module}"
    
    if [[ ! -f "$lib_path" ]]; then
        echo "Error: Module '$module' not found"
        return 1
    fi
    
    echo "Functions in module '$module':"
    # Extract function names from the library file
    grep "^${module}_[a-z_]*(" "$lib_path" | cut -d'(' -f1 | sed "s/^${module}_/  /"
}

# Show module help
ops_show_module_help() {
    local module="$1"
    echo "Help for module '$module':"
    echo "  Use 'ops $module --list' to see available functions"
    echo "  Use 'ops $module FUNCTION --help' for function-specific help"
}

# Show function help
ops_show_function_help() {
    local module="$1"
    local function="$2"
    local full_function="${module}_${function}"
    
    echo "Help for function '$full_function':"
    echo "  This function will be executed with automatic dependency injection"
    echo "  Global variables will be resolved based on parameter names"
    echo "  Use OPS_DEBUG=1 to see variable injection details"
}

# Debug output
ops_debug() {
    if [[ "$OPS_DEBUG" == "1" ]]; then
        echo "[DIC] $*" >&2
    fi
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

# If script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Check if running in correct environment
    if [[ -z "$LIB_OPS_DIR" ]]; then
        echo "Error: Environment not initialized. Please run 'source bin/ini' first."
        exit 1
    fi
    
    # Execute main function with all arguments
    ops_main "$@"
fi
