#!/bin/bash

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of specific functions in the script, displaying their usage, shortname, and description
# overview functions
# [function_name_filter]
sys_fun() {
    # TECHNICAL DETAILS:
    # Optional parameters - no validation needed
    # Pass all arguments to processing function
    # Supports filtering by function name pattern
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Optional parameters - no validation needed
    # Pass all arguments to processing function
    aux_laf "$FILEPATH_gen" "$@"
}

# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
# (no parameters)
sys_var() {
    # TECHNICAL DETAILS:
    # Scans configuration files and extracts variable definitions
    # Displays usage across different files and contexts
    # No parameters required - operates on default configuration
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 0 ]; then
        aux_use
        return 1
    fi
    
    aux_acu -o "$CONFIG_gen" "$DIR_FUN/.."
}

# Manages git operations, ensuring the local repository syncs with the remote.
# git sync operations
# [commit_message]
sys_gio() {
    # TECHNICAL DETAILS:
    # Performs status check, pull, commit, and push operations as needed
    # If commit message provided, uses it for commits
    # Otherwise commits with empty message when changes detected
    # Handles both clean working tree updates and dirty tree commits
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Optional parameters - no validation needed
    local dir="${DIR_FUN:-.}/.."
    local branch="${GIT_BRANCH:-master}"
    local commit_message=""

    # If arguments are provided, use them as the commit message
    if [ $# -gt 0 ]; then
        commit_message="$*"
    fi

    # Navigate to the git folder
    cd "$dir" || { echo "Failed to change directory to $dir"; return 1; }

    # Fetch updates from remote
    git fetch origin "$branch" || { echo "Failed to fetch from remote"; return 1; }

    # Get the current status
    local status_output
    status_output=$(git status --porcelain)
    if [[ -z "$status_output" ]]; then
        echo "Working tree clean. Checking for updates..."
        if git rev-list HEAD...origin/"$branch" --count | grep -q "^0$"; then
            echo "Local branch is up to date with origin/$branch."
        else
            echo "Updates available. Pulling changes..."
            git pull origin "$branch" || { echo "Failed to pull changes"; return 1; }
        fi
    else
        echo "Changes detected. Committing and pushing..."
        git add . || { echo "Failed to stage changes"; return 1; }
        if [[ -n "$commit_message" ]]; then
            git commit -m "$commit_message" || { echo "Failed to commit changes"; return 1; }
        else
            git commit --allow-empty-message -m "" || { echo "Failed to commit changes"; return 1; }
        fi
        git push origin "$branch" || { echo "Failed to push changes"; return 1; }
    fi

    # Return to the previous directory
    cd - > /dev/null || { echo "Failed to return to previous directory"; return 1; }
}

# Detects the system's package manager
# detect package manager
# (no parameters)
sys_dpa() {
    # TECHNICAL DETAILS:
    # Checks for common package managers: apt, dnf, yum, zypper
    # Returns the detected package manager name or 'unknown'
    # Used by other functions to determine installation commands
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 0 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local pman="unknown"

    if command -v apt &> /dev/null; then
        pman="apt"
    elif command -v dnf &> /dev/null; then
        pman="dnf"
    elif command -v yum &> /dev/null; then
        pman="yum"
    elif command -v zypper &> /dev/null; then
        pman="zypper"
    fi

    echo "$pman"
}

# Updates and upgrades system packages using the detected package manager
# update packages system
# (no parameters)
sys_upa() {
    # TECHNICAL DETAILS:
    # Uses sys_dpa to detect package manager automatically
    # Performs both update (refresh) and upgrade (install) operations
    # Supports apt, dnf, yum, and zypper package managers
    # Provides detailed success/failure feedback
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 0 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"

    # Get package manager using sys-dpa
    local pman
    pman=$(sys-dpa)

    if [ "$pman" = "unknown" ]; then
        aux_nos "$function_name" "Could not detect a supported package manager"
        return 1
    fi

    # Define commands based on package manager
    case "$pman" in
        apt)
            apt update -y && apt upgrade -y
            ;;
        dnf|yum)
            $pman update -y && $pman upgrade -y
            ;;
        zypper)
            zypper refresh -y && zypper update -y
            ;;
        *)
            aux_nos "$function_name" "Unsupported package manager: $pman"
            return 1
            ;;
    esac

    if [ $? -eq 0 ]; then
        aux_nos "$function_name" "System update and upgrade completed successfully"
        return 0
    else
        aux_nos "$function_name" "Failed to update and upgrade system"
        return 1
    fi
}

# Installs specified packages using the system's package manager
# install packages system
# <pak1> <pak2> ...
sys_ipa() {
    # TECHNICAL DETAILS:
    # Filters out already installed packages before attempting installation
    # Uses detected package manager from sys_dpa function
    # Supports multiple packages in single command
    # Provides feedback on installation status
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -lt 1 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"

    # Get package manager using sys-dpa
    local pman
    pman=$(sys-dpa)
    if [ "$pman" = "unknown" ]; then
        aux_nos "$function_name" "Could not detect a supported package manager"
        return 1
    fi

    # Filter out already installed packages
    local packages_to_install=()
    for package in "$@"; do
        case "$pman" in
            apt)
                if ! dpkg -l "$package" &>/dev/null; then
                    packages_to_install+=("$package")
                fi
                ;;
            dnf|yum)
                if ! rpm -q "$package" &>/dev/null; then
                    packages_to_install+=("$package")
                fi
                ;;
            zypper)
                if ! rpm -q "$package" &>/dev/null; then
                    packages_to_install+=("$package")
                fi
                ;;
        esac
    done

    # If no packages need installation, exit successfully
    if [ ${#packages_to_install[@]} -eq 0 ]; then
        aux_nos "$function_name" "All packages are already installed"
        return 0
    fi

    # Install filtered packages
    case "$pman" in
        dnf|yum)
            $pman install -y "${packages_to_install[@]}"
            ;;
    esac

    local exit_status=$?
    if [ $exit_status -eq 0 ]; then
        aux_nos "$function_name" "Successfully installed packages: ${packages_to_install[*]}"
        return 0
    else
        aux_nos "$function_name" "Failed to install packages: ${packages_to_install[*]}"
        return 1
    fi
}

# Configures git globally with a specified username and email, essential for proper commit attribution
# git set config
# <username> <usermail>
sys_gst() {
    # TECHNICAL DETAILS:
    # Sets global git configuration for user.name and user.email
    # Essential for proper commit attribution in git operations
    # Both username and email are required parameters
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local username="$1"
    local usermail="$2"

    git config --global user.name "$username"
    git config --global user.email "$usermail"

    aux_nos "$function_name" "executed ( $1 $2 )"
}

# Installs, enables, and starts the sysstat service for system performance monitoring. Modifies the configuration to ensure it's enabled
# setup sysstat service
# (no parameters)
sys_sst() {
    # TECHNICAL DETAILS:
    # Installs sysstat package for system performance monitoring
    # Enables sysstat in /etc/default/sysstat configuration
    # Starts and enables the systemd service
    # Essential for system performance data collection
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 0 ]; then
        aux_use
        return 1
    fi
    
    # Step 1: Install sysstat
    install_pakages sysstat

  # Step 2: Enable sysstat
  sed -i 's/ENABLED="false"/ENABLED="true"/' /etc/default/sysstat

  # Step 3: Start the sysstat service
  systemctl enable sysstat
  systemctl start sysstat

  echo "sysstat has been installed, enabled, and started."
}

# Creates a new user with a specified username and password, prompting for input if not provided. Verifies successful user creation
# user setup
# <username> <password>
sys_ust() {
    # TECHNICAL DETAILS:
    # Creates new system user with home directory
    # Sets password using chpasswd for security
    # Validates successful user creation with id command
    # Provides interactive prompts if parameters missing
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local username="$1"
    local password="$2"

    # Prompt for user details
    aux_mev "username" "Enter new username" "$username"
    while [ -z "$password" ]; do
        aux_mev "password" "Enter password for $username" "$password"
    done

    # Create the user
    useradd -m "$username"
    echo "$username:$password" | chpasswd

    # Check if user creation was successful
    if id -u "$username" > /dev/null 2>&1; then
        aux_nos "$function_name" "User $username created successfully"
    else
        aux_nos "$function_name" "Failed to create user $username"
        return 1
    fi
}

# Enables and starts a specified systemd service. Checks if the service is active and prompts for continuation if it's not
# systemd setup service
# <service>
sys_sdc() {
    # TECHNICAL DETAILS:
    # Enables service for automatic startup on boot
    # Starts service immediately if not running
    # Verifies service status and provides interactive continuation
    # Handles service activation failures gracefully
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local service="$1"

    # Enable and start smbd service
    systemctl enable "$service"
    systemctl start "$service"

    # Check if service is active
    systemctl is-active --quiet "$service"
    if [ $? -eq 0 ]; then
        aux_nos "$function_name" "$service is active"
    else
        read -p "$service is not active. Do you want to continue anyway? [Y/n] " choice
        case "$choice" in
            [yY]|[yY][eE][sS])
                aux_nos "$function_name" "$service is not active"
                ;;
            *)
                aux_nos "$function_name" "$service is not active. Exiting."
                return 1
                ;;
        esac
    fi
}

# An interactive Bash function that guides users through Git history navigation, offering options for reset type and subsequent actions, with built-in safeguards and explanations.
# git reset explorer
# (no parameters)
sys_gre() {
    # TECHNICAL DETAILS:
    # Interactive Git Reset Explorer with guided prompts
    # Offers soft, mixed, and hard reset options with explanations
    # Provides post-reset actions: keep state, create branch, force push, new commit
    # Includes safety prompts and status display
    # Educational tool for understanding git reset operations
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 0 ]; then
        aux_use
        return 1
    fi
    
    echo "Welcome to the Git Reset Explorer (sys-gre)!"
    echo "This function will guide you through the process of moving back in Git history."
    echo

    # Step 1: Determine how many commits to go back
    read -p "How many commits do you want to go back? " num_commits

    # Step 2: Determine the reset type
    echo
    echo "What type of reset do you want to perform?"
    echo "1. Soft (move HEAD but leave staging and working directory unchanged)"
    echo "2. Mixed (move HEAD and reset staging, but leave working directory unchanged)"
    echo "3. Hard (move HEAD, reset staging, and reset working directory)"
    read -p "Enter your choice (1/2/3): " reset_type

    # Construct the reset command
    case $reset_type in
        1) reset_cmd="git reset --soft HEAD~$num_commits" ;;
        2) reset_cmd="git reset HEAD~$num_commits" ;;
        3) reset_cmd="git reset --hard HEAD~$num_commits" ;;
        *) echo "Invalid choice. Exiting."; return 1 ;;
    esac

    # Execute the reset command
    echo
    echo "Executing: $reset_cmd"
    eval $reset_cmd

    # Step 3: Handle the new state
    echo
    echo "Reset complete. What would you like to do with this new state?"
    echo "1. Keep this state (do nothing further)"
    echo "2. Create a new branch at this point"
    echo "3. Force push this state to the remote (caution: rewrites history)"
    echo "4. Create a new commit with this state"
    read -p "Enter your choice (1/2/3/4): " state_choice

    case $state_choice in
        1)
            echo "Keeping the current state. No further action needed."
            ;;
        2)
            read -p "Enter the name for the new branch: " branch_name
            git checkout -b $branch_name
            echo "Created and switched to new branch: $branch_name"
            ;;
        3)
            read -p "Enter the name of the remote branch to force push to: " remote_branch
            git push -f origin HEAD:$remote_branch
            echo "Force pushed to $remote_branch. Remote history has been rewritten."
            ;;
        4)
            read -p "Enter a commit message: " commit_message
            git commit -m "$commit_message"
            echo "Created a new commit with the message: $commit_message"
            ;;
        *)
            echo "Invalid choice. No further action taken."
            ;;
    esac

    echo
    echo "Gen-gre process complete. Your repository is now in the following state:"
    git status
    echo
    echo "Current commit:"
    git log -1 --oneline
}

