#!/bin/bash

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of specific functions in the script, displaying their usage, shortname, and description
# overview functions
# [function_name_filter]
sys_fun() {
    # Technical Description:
    #   Analyzes function definitions within script files and displays comprehensive overview
    #   Supports optional filtering by function name patterns for targeted analysis
    #   Extracts function metadata including usage patterns, shortnames, and descriptions
    #   Processes function documentation and presents it in a structured format
    # Dependencies:
    #   - ana_laf function for function analysis and formatting
    #   - aux_tec function for technical details display
    #   - FILEPATH_gen variable for target file path
    #   - Read permissions on source files
    # Arguments:
    #   $1: [function_name_filter] - optional pattern to filter functions by name
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Optional parameters - no validation needed
    # Pass all arguments to processing function
    ana_laf "$FILEPATH_gen" "$@"
}

# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
# -x (execute)
sys_var() {
    # Technical Description:
    #   Scans configuration files and extracts variable definitions using auxiliary functions
    #   Displays variable usage patterns across different files and contexts
    #   Analyzes configuration structure and provides comprehensive overview of variable usage
    #   Operates on default configuration files within the project directory structure
    # Dependencies:
    #   - ana_acu function for configuration analysis
    #   - CONFIG_gen variable for configuration file path
    #   - DIR_FUN variable for directory navigation
    #   - Read permissions on configuration files
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    ana_acu -o "$CONFIG_gen" "$DIR_FUN/.."
}

# Manages git operations, ensuring the local repository syncs with the remote.
# git sync operations
# [commit_message]
sys_gio() {
    # Technical Description:
    #   Comprehensive git synchronization workflow handling both clean and dirty working trees
    #   Performs fetch, status check, pull for clean trees, and add/commit/push for dirty trees
    #   Supports optional commit messages, defaults to empty message when not provided
    #   Handles branch management with configurable default branch via GIT_BRANCH variable
    #   Includes error handling for each git operation with descriptive failure messages
    # Dependencies:
    #   - git command line tool with full functionality
    #   - GIT_BRANCH environment variable for branch configuration
    #   - DIR_FUN variable for directory navigation
    #   - Write permissions for git operations and directory access
    #   - Network connectivity for remote operations
    # Arguments:
    #   $1: [commit_message] - optional commit message for changes, space-separated words combined
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Optional parameters - no validation needed
    local dir="${DIR_FUN:-.}/.."
    local branch="${GIT_BRANCH:-master}"
    local commit_message=""

    # If arguments are provided, use them as the commit message
    if [ $# -gt 0 ]; then
        commit_message="$*"
    fi

    # Navigate to the git folder
    cd "$dir" || { echo "Failed to change directory to $dir"; return 1; }

    # Fetch updates from remote
    git fetch origin "$branch" || { echo "Failed to fetch from remote"; return 1; }

    # Get the current status
    local status_output
    status_output=$(git status --porcelain)
    if [[ -z "$status_output" ]]; then
        echo "Working tree clean. Checking for updates..."
        if git rev-list HEAD...origin/"$branch" --count | grep -q "^0$"; then
            echo "Local branch is up to date with origin/$branch."
        else
            echo "Updates available. Pulling changes..."
            git pull origin "$branch" || { echo "Failed to pull changes"; return 1; }
        fi
    else
        echo "Changes detected. Committing and pushing..."
        git add . || { echo "Failed to stage changes"; return 1; }
        if [[ -n "$commit_message" ]]; then
            git commit -m "$commit_message" || { echo "Failed to commit changes"; return 1; }
        else
            git commit --allow-empty-message -m "" || { echo "Failed to commit changes"; return 1; }
        fi
        git push origin "$branch" || { echo "Failed to push changes"; return 1; }
    fi

    # Return to the previous directory
    cd - > /dev/null || { echo "Failed to return to previous directory"; return 1; }
}

# Detects the system's package manager
# detect package manager
# -x (execute)
sys_dpa() {
    # Technical Description:
    #   Scans system for available package managers using command availability checks
    #   Tests for presence of common package managers: apt, dnf, yum, zypper in priority order
    #   Returns detected package manager name for use by other package management functions
    #   Provides fallback 'unknown' result when no supported package manager found
    # Dependencies:
    #   - command utility for testing command availability
    #   - Standard package managers: apt, dnf, yum, or zypper installed on system
    #   - No special permissions required beyond command execution
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local pman="unknown"

    if command -v apt &> /dev/null; then
        pman="apt"
    elif command -v dnf &> /dev/null; then
        pman="dnf"
    elif command -v yum &> /dev/null; then
        pman="yum"
    elif command -v zypper &> /dev/null; then
        pman="zypper"
    fi

    echo "$pman"
}

# Updates and upgrades system packages using the detected package manager
# update packages system
# -x (execute)
sys_upa() {
    # Technical Description:
    #   Performs comprehensive system package update and upgrade operations
    #   Uses sys_dpa to automatically detect the appropriate package manager
    #   Executes both refresh (update) and upgrade operations in sequence
    #   Supports apt, dnf, yum, and zypper package managers with appropriate commands
    #   Provides detailed feedback on operation success or failure with specific error messages
    # Dependencies:
    #   - sys_dpa function for package manager detection
    #   - Detected package manager (apt, dnf, yum, or zypper) installed and functional
    #   - Root or sudo privileges for package management operations
    #   - Network connectivity for downloading package updates
    #   - aux_log function for status reporting
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"

    # Get package manager using sys_dpa
    local pman
    pman=$(sys_dpa -x)

    if [ "$pman" = "unknown" ]; then
        aux_log "ERROR" "$function_name: Could not detect a supported package manager"
        return 1
    fi

    # Define commands based on package manager
    case "$pman" in
        apt)
            apt update -y && apt upgrade -y
            ;;
        dnf|yum)
            $pman update -y && $pman upgrade -y
            ;;
        zypper)
            zypper refresh -y && zypper update -y
            ;;
        *)
            aux_log "ERROR" "$function_name: Unsupported package manager: $pman"
            return 1
            ;;
    esac

    if [ $? -eq 0 ]; then
        aux_log "INFO" "$function_name: System update and upgrade completed successfully"
        return 0
    else
        aux_log "ERROR" "$function_name: Failed to update and upgrade system"
        return 1
    fi
}

# Installs specified packages using the system's package manager
# install packages system
# <pak1> <pak2> ...
sys_ipa() {
    # Technical Description:
    #   Intelligently installs system packages using detected package manager
    #   Filters out already installed packages to avoid redundant operations
    #   Supports installation of multiple packages in a single operation
    #   Handles different package managers with appropriate installation commands
    #   Provides comprehensive feedback on installation status and results
    # Dependencies:
    #   - sys_dpa function for package manager detection
    #   - Package manager utilities: dpkg (apt), rpm (dnf/yum/zypper)
    #   - Root or sudo privileges for package installation
    #   - Network connectivity for downloading packages
    #   - aux_log function for status reporting
    # Arguments:
    #   $1, $2, ...: package_name - names of packages to install from system repositories
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -lt 1 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"

    # Get package manager using sys_dpa
    local pman
    pman=$(sys_dpa -x)
    if [ "$pman" = "unknown" ]; then
        aux_log "ERROR" "$function_name: Could not detect a supported package manager"
        return 1
    fi

    # Filter out already installed packages
    local packages_to_install=()
    for package in "$@"; do
        case "$pman" in
            apt)
                if ! dpkg -l "$package" &>/dev/null; then
                    packages_to_install+=("$package")
                fi
                ;;
            dnf|yum)
                if ! rpm -q "$package" &>/dev/null; then
                    packages_to_install+=("$package")
                fi
                ;;
            zypper)
                if ! rpm -q "$package" &>/dev/null; then
                    packages_to_install+=("$package")
                fi
                ;;
        esac
    done

    # If no packages need installation, exit successfully
    if [ ${#packages_to_install[@]} -eq 0 ]; then
        aux_log "INFO" "$function_name: All packages are already installed"
        return 0
    fi

    # Install filtered packages
    case "$pman" in
        apt)
            apt install -y "${packages_to_install[@]}"
            ;;
        dnf|yum)
            $pman install -y "${packages_to_install[@]}"
            ;;
        zypper)
            zypper install -y "${packages_to_install[@]}"
            ;;
        *)
            aux_log "ERROR" "$function_name: Unsupported package manager: $pman"
            return 1
            ;;
    esac

    local exit_status=$?
    if [ $exit_status -eq 0 ]; then
        aux_log "INFO" "$function_name: Successfully installed packages: ${packages_to_install[*]}"
        return 0
    else
        aux_log "ERROR" "$function_name: Failed to install packages: ${packages_to_install[*]}"
        return 1
    fi
}

# Configures git globally with a specified username and email, essential for proper commit attribution
# git set config
# <username> <usermail>
sys_gst() {
    # Technical Description:
    #   Configures global git user identity settings for proper commit attribution
    #   Sets both user.name and user.email in the global git configuration
    #   Essential prerequisite for git operations requiring user identification
    #   Configuration persists across all git repositories for the current user
    #   Validates successful configuration and provides execution feedback
    # Dependencies:
    #   - git command line tool with configuration capabilities
    #   - Write permissions for git global configuration file (~/.gitconfig)
    #   - aux_log function for status notification
    # Arguments:
    #   $1: username - git user name for commit attribution (spaces allowed)
    #   $2: usermail - git user email address for commit identification
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local username="$1"
    local usermail="$2"

    git config --global user.name "$username"
    git config --global user.email "$usermail"

    aux_log "INFO" "$function_name: executed ( $1 $2 )"
}

# Installs, enables, and starts the sysstat service for system performance monitoring. Modifies the configuration to ensure it's enabled
# setup sysstat service
# -x (execute)
sys_sst() {
    # Technical Description:
    #   Comprehensive setup of sysstat service for system performance monitoring
    #   Installs sysstat package using system package manager
    #   Modifies /etc/default/sysstat configuration to enable data collection
    #   Enables and starts the systemd service for automatic startup and immediate operation
    #   Essential for system performance data collection and historical analysis
    # Dependencies:
    #   - sys_ipa function for package installation
    #   - systemctl command for service management
    #   - sed command for configuration file modification
    #   - Root or sudo privileges for system service and configuration changes
    #   - Write permissions for /etc/default/sysstat file
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Step 1: Install sysstat
    sys_ipa sysstat

    # Step 2: Enable sysstat
    sed -i 's/ENABLED="false"/ENABLED="true"/' /etc/default/sysstat

    # Step 3: Start the sysstat service
    systemctl enable sysstat
    systemctl start sysstat

    echo "sysstat has been installed, enabled, and started."
}

# Creates a new user with a specified username and password, prompting for input if not provided. Verifies successful user creation
# user setup
# <username> <password>
sys_ust() {
    # Technical Description:
    #   Creates new system user account with home directory and specified credentials
    #   Uses useradd command for user creation with automatic home directory creation
    #   Sets user password securely using chpasswd for encrypted password storage
    #   Validates successful user creation using id command verification
    #   Provides interactive prompts and comprehensive error handling
    # Dependencies:
    #   - useradd command for user account creation
    #   - chpasswd command for secure password setting
    #   - id command for user existence verification
    #   - aux_log function for status notification
    #   - Root or sudo privileges for user management operations
    # Arguments:
    #   $1: username - desired username for the new system account
    #   $2: password - initial password for the new user account
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local username="$1"
    local password="$2"

    # Create the user
    useradd -m "$username"
    echo "$username:$password" | chpasswd

    # Check if user creation was successful
    if id -u "$username" > /dev/null 2>&1; then
        aux_log "INFO" "$function_name: User $username created successfully"
    else
        aux_log "ERROR" "$function_name: Failed to create user $username"
        return 1
    fi
}

# Enables and starts a specified systemd service. Checks if the service is active and prompts for continuation if it's not
# systemd setup service
# <service>
sys_sdc() {
    # Technical Description:
    #   Comprehensive systemd service management with enable, start, and verification operations
    #   Enables service for automatic startup on system boot using systemctl enable
    #   Starts service immediately for current session using systemctl start
    #   Verifies service activation status and provides interactive continuation options
    #   Handles service activation failures gracefully with user choice prompts
    # Dependencies:
    #   - systemctl command for systemd service management
    #   - systemctl is-active command for service status verification
    #   - aux_tec and aux_use functions for help and usage display
    #   - aux_log function for status notification
    #   - Root or sudo privileges for service management operations
    # Arguments:
    #   $1: service - name of the systemd service to enable and start
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local service="$1"

    # Enable and start smbd service
    systemctl enable "$service"
    systemctl start "$service"

    # Check if service is active
    systemctl is-active --quiet "$service"
    if [ $? -eq 0 ]; then
        aux_log "INFO" "$function_name: $service is active"
    else
        read -p "$service is not active. Do you want to continue anyway? [Y/n] " choice
        case "$choice" in
            [yY]|[yY][eE][sS])
                aux_log "WARN" "$function_name: $service is not active"
                ;;
            *)
                aux_log "ERROR" "$function_name: $service is not active. Exiting."
                return 1
                ;;
        esac
    fi
}

# An interactive Bash function that guides users through Git history navigation, offering options for reset type and subsequent actions, with built-in safeguards and explanations.
# git reset explorer
# -x (execute)
sys_gre() {
    # Technical Description:
    #   Interactive Git Reset Explorer providing guided workflow for git history manipulation
    #   Offers comprehensive reset options: soft, mixed, and hard with detailed explanations
    #   Provides post-reset action choices: keep state, create branch, force push, or new commit
    #   Includes safety prompts and educational information for understanding git reset operations
    #   Features status display and commit information for complete workflow transparency
    # Dependencies:
    #   - git command line tool with full reset, branch, and status capabilities
    #   - git log command for commit history display
    #   - Interactive shell environment for user input prompts
    #   - Working git repository with commit history
    #   - Network connectivity for push operations (if selected)
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    echo "Welcome to the Git Reset Explorer (sys-gre)!"
    echo "This function will guide you through the process of moving back in Git history."
    echo

    # Step 1: Determine how many commits to go back
    read -p "How many commits do you want to go back? " num_commits

    # Step 2: Determine the reset type
    echo
    echo "What type of reset do you want to perform?"
    echo "1. Soft (move HEAD but leave staging and working directory unchanged)"
    echo "2. Mixed (move HEAD and reset staging, but leave working directory unchanged)"
    echo "3. Hard (move HEAD, reset staging, and reset working directory)"
    read -p "Enter your choice (1/2/3): " reset_type

    # Construct the reset command
    case $reset_type in
        1) reset_cmd="git reset --soft HEAD~$num_commits" ;;
        2) reset_cmd="git reset HEAD~$num_commits" ;;
        3) reset_cmd="git reset --hard HEAD~$num_commits" ;;
        *) echo "Invalid choice. Exiting."; return 1 ;;
    esac

    # Execute the reset command
    echo
    echo "Executing: $reset_cmd"
    eval $reset_cmd

    # Step 3: Handle the new state
    echo
    echo "Reset complete. What would you like to do with this new state?"
    echo "1. Keep this state (do nothing further)"
    echo "2. Create a new branch at this point"
    echo "3. Force push this state to the remote (caution: rewrites history)"
    echo "4. Create a new commit with this state"
    read -p "Enter your choice (1/2/3/4): " state_choice

    case $state_choice in
        1)
            echo "Keeping the current state. No further action needed."
            ;;
        2)
            read -p "Enter the name for the new branch: " branch_name
            git checkout -b $branch_name
            echo "Created and switched to new branch: $branch_name"
            ;;
        3)
            read -p "Enter the name of the remote branch to force push to: " remote_branch
            git push -f origin HEAD:$remote_branch
            echo "Force pushed to $remote_branch. Remote history has been rewritten."
            ;;
        4)
            read -p "Enter a commit message: " commit_message
            git commit -m "$commit_message"
            echo "Created a new commit with the message: $commit_message"
            ;;
        *)
            echo "Invalid choice. No further action taken."
            ;;
    esac

    echo
    echo "Gen-gre process complete. Your repository is now in the following state:"
    git status
    echo
    echo "Current commit:"
    git log -1 --oneline
}
