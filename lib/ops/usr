#!/bin/bash

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of selected functions in the script, displaying their usage, shortname, and description
# overview functions
# [function_name_filter]
usr_fun() {
    # Technical Description:
    #   Extracts and displays function documentation from the current script file
    #   Parses function comment blocks to show usage, shortname, and description
    #   Supports optional filtering by function name pattern for targeted display
    #   Uses ana_laf utility to format and present function information consistently
    # Dependencies:
    #   - ana_laf function for listing and formatting function documentation
    #   - FILEPATH_usr variable must be properly initialized
    #   - grep and awk utilities for text processing
    #   - Read access to the function definition file
    # Arguments:
    #   $1: function_name_filter (optional) - pattern to filter displayed functions
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    ana_laf "$FILEPATH_usr" "$@"
}
# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
# -x (execute)
usr_var() {
    # Technical Description:
    #   Scans configuration files and workspace directories to extract variable definitions
    #   Analyzes variable usage patterns across multiple files in the project
    #   Provides comprehensive overview of variable names, values, and cross-file dependencies
    #   Uses ana_acu utility with overview mode to format and display results
    # Dependencies:
    #   - ana_acu function with -o (overview) option
    #   - CONFIG_usr variable pointing to site configuration file
    #   - DIR_FUN variable for workspace directory navigation
    #   - Read access to configuration files and workspace directories
    # Arguments:
    #   $1: -x - explicit execution flag required for consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    ana_acu -o "$CONFIG_usr" "$DIR_FUN/.."
}

# Changes the Konsole profile for the current user by updating the konsolerc file
# change konsole profile
# <profile_number>
usr_ckp() {
    # Technical Description:
    #   Updates Konsole terminal emulator default profile configuration for current user
    #   Validates profile existence in user's Konsole profile directory before applying changes
    #   Modifies konsolerc configuration file to set new default profile
    #   Handles both root and regular user environments with appropriate path resolution
    #   Creates or updates [Desktop Entry] section with DefaultProfile setting
    # Dependencies:
    #   - whoami command for user identification
    #   - grep and sed utilities for file processing
    #   - Konsole profile files in ~/.local/share/konsole/
    #   - Write access to ~/.config/konsolerc file
    #   - Valid Konsole installation and profile structure
    # Arguments:
    #   $1: profile_number - numeric identifier of the Konsole profile to set as default
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ]; then
        aux_use
        return 1
    fi
    
    local profile_number="$1"
    local username
    local konsole_profile_path
    local profile_name
    username=$(whoami)
    echo "Changing Konsole profile for user: $username"
    if [ "$username" = "root" ]; then
        konsole_profile_path="/root/.local/share/konsole"
    else
        konsole_profile_path="$HOME/.local/share/konsole"
    fi
    if [ ! -d "$konsole_profile_path" ]; then
        echo "Error: Konsole profile directory not found at $konsole_profile_path"
        return 1
    fi
    if ! [[ "$profile_number" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid profile number. Please provide a positive integer."
        return 1
    fi
    profile_name="Profile $profile_number.profile"
    if [ ! -f "$konsole_profile_path/$profile_name" ]; then
        echo "Error: Profile $profile_number does not exist in $konsole_profile_path"
        return 1
    fi
    local konsolerc_path
    if [ "$username" = "root" ]; then
        konsolerc_path="/root/.config/konsolerc"
    else
        konsolerc_path="$HOME/.config/konsolerc"
    fi
    if [ ! -f "$konsolerc_path" ]; then
        echo "Error: Konsole configuration file not found at $konsolerc_path"
        return 1
    fi
    
    # Check if [Desktop Entry] section exists
    if ! grep -q '^\[Desktop Entry\]' "$konsolerc_path"; then
        # If it doesn't exist, add it and the DefaultProfile line
        echo -e "\n[Desktop Entry]\nDefaultProfile=Profile $profile_number.profile" >> "$konsolerc_path"
        echo "Added [Desktop Entry] section with DefaultProfile to $konsolerc_path"
    else
        # If [Desktop Entry] exists, check if DefaultProfile line exists
        if ! sed -n '/^\[Desktop Entry\]/,/^\[/p' "$konsolerc_path" | grep -q '^DefaultProfile='; then
            # If it doesn't exist, add it to the [Desktop Entry] section
            sed -i '/^\[Desktop Entry\]/a DefaultProfile=Profile '"$profile_number"'.profile' "$konsolerc_path"
            echo "Added DefaultProfile line to $konsolerc_path"
        else
            # If it exists, update it
            sed -i '/^\[Desktop Entry\]/,/^\[/ s/^DefaultProfile=.*/DefaultProfile=Profile '"$profile_number"'.profile/' "$konsolerc_path"
            echo "Updated existing DefaultProfile line in $konsolerc_path"
        fi
    fi
    
    echo "Konsole default profile updated to Profile $profile_number for user $username."
}

# Prompts the user to select a file from the current directory by displaying a numbered list of files and returning the chosen filename
# variable select filename
# -x (execute)
usr_vsf() {
    # Technical Description:
    #   Creates interactive file selection interface for current working directory
    #   Lists all files with numeric indices for easy selection by user input
    #   Captures user selection and stores result in variable for further processing
    #   Provides numbered menu system with read prompt for user interaction
    # Dependencies:
    #   - ls command for file listing
    #   - read command for user input capture
    #   - Standard bash array functionality
    #   - Access to current working directory
    # Arguments:
    #   $1: -x - explicit execution flag required for interactive operations
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    files=($(ls))
    echo "Select a file by entering its index:"
    for i in "${!files[@]}"; do
        echo "$i: ${files[$i]}"
    done
    read -p "Enter the index of the file you want: " index
    sel="${files[$index]}"
    echo "$selected_file"
}

# Counts files in directories based on specified visibility (regular, hidden, or both). Displays results sorted by directory name
# count files folder
# <path> <folder_type: 1=regular, 2=hidden, 3=both>
usr_cff() {
    # Technical Description:
    #   Performs directory traversal to count files based on visibility criteria
    #   Supports three counting modes: regular files only, hidden files only, or both types
    #   Uses find command with appropriate name patterns for file type filtering
    #   Displays results in formatted table with directory names and file counts
    #   Sorts output alphabetically by directory name for consistent presentation
    # Dependencies:
    #   - find command with -mindepth, -maxdepth, -type, and -name options
    #   - wc command for line counting
    #   - printf for formatted output
    #   - sort command for alphabetical ordering
    #   - Read access to specified directory path
    # Arguments:
    #   $1: path - target directory path to analyze for file counting
    #   $2: folder_type - numeric type: 1 (regular), 2 (hidden), 3 (both)
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi

    local path="$1"
    local folder_type="$2"

    # count files in a directory
    count_files() {
        local dir="$1"
        find "$dir" -type f | wc -l
    }

    # print directory information
    print_directory_info() {
        local dir="$1"
        local file_count=$(count_files "$dir")
        printf "%-20s %5s\n" "$dir" "$file_count"
    }

    # Main function logic
    case "$folder_type" in
        1)
            find "$path" -mindepth 1 -maxdepth 1 -type d -name '[^.]*' | while read -r dir; do
                print_directory_info "$dir"
            done
            ;;
        2)
            find "$path" -mindepth 1 -maxdepth 1 -type d -name '.*' | while read -r dir; do
                print_directory_info "$dir"
            done
            ;;
        3)
            find "$path" -mindepth 1 -maxdepth 1 -type d \( -name '[^.]*' -o -name '.*' \) | while read -r dir; do
                print_directory_info "$dir"
            done
            ;;
        *)
            echo "Invalid folder type. Please provide either 1, 2, or 3."
            ;;
    esac | sort
}

# Compares data usage between two paths up to a specified depth. Displays results in a tabular format with color-coded differences
# data usage comparison
# <path1> <path2> <depth>
usr_duc() {
    # Technical Description:
    #   Performs parallel disk usage analysis on two directory trees up to specified depth
    #   Converts relative paths to absolute paths for accurate comparison
    #   Uses du command to gather size information and processes output for alignment
    #   Implements color-coded output highlighting size differences between paths
    #   Formats results in human-readable units (B, K, M, G) with tabular presentation
    #   Uses join operation to correlate corresponding subdirectories between paths
    # Dependencies:
    #   - du command with -b (bytes) and -d (depth) options
    #   - realpath for absolute path conversion
    #   - join command for data correlation
    #   - awk for data processing and formatting
    #   - column command for table formatting
    #   - sed and sort utilities for output processing
    # Arguments:
    #   $1: path1 - first directory path for comparison analysis
    #   $2: path2 - second directory path for comparison analysis  
    #   $3: depth - maximum directory depth for recursive analysis
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    local path1=$1
    local path2=$2
    local depth=$3

    # Convert relative paths to absolute paths
    path1=$(realpath "$path1")
    path2=$(realpath "$path2")

    # remove base path and sort by subpath
    process_du() {
        local path=$1
        local depth=$2
        du -b -d "$depth" "$path" | sed "s|$path/||" | sort -k2
    }

    # Process and sort du output for both paths
    output1=$(process_du "$path1" "$depth")
    output2=$(process_du "$path2" "$depth")

    # Define ANSI color codes
    RED='\033[0;31m'
    NC='\033[0m'  # No Color

    # Join the results on the common subpath
    join -j 2 <(echo "$output1") <(echo "$output2") | awk -v p1="$path1" -v p2="$path2" -v red="$RED" -v nc="$NC" '
        BEGIN {
            OFS = "\t";
            print "Path", p1, p2, "Difference"
        }
        function abs(value) {
            return (value < 0) ? -value : value
        }
        function hr(bytes) {
            if (bytes >= 1073741824) {
                return sprintf("%.2fG", bytes / 1073741824)
            } else if (bytes >= 1048576) {
                return sprintf("%.2fM", bytes / 1048576)
            } else if (bytes >= 1024) {
                return sprintf("%.2fK", bytes / 1024)
            } else {
                return bytes "B"
            }
        }
        {
            subpath = $1
            size1 = $2 + 0
            size2 = $3 + 0
            diff = abs(size1 - size2)
            if (size1 < size2) {
                print subpath, red hr(size1) nc, hr(size2), hr(diff)
            } else if (size2 < size1) {
                print subpath, hr(size1), red hr(size2) nc, hr(diff)
            } else {
                print subpath, hr(size1), hr(size2), hr(diff)
            }
        }' | column -t
}

# Concatenates and displays the contents of all files within a specified folder, separating each file's content with a line of dashes
# cat in folder
# <path>
usr_cif() {
    # Technical Description:
    #   Iterates through all files in specified directory and displays their contents sequentially
    #   Validates directory existence before processing to prevent errors
    #   Adds visual separators between file contents for clear distinction
    #   Skips subdirectories and only processes regular files in the target directory
    #   Provides file identification headers before each file's content display
    # Dependencies:
    #   - cat command for file content display
    #   - test operators for directory and file validation
    #   - bash file globbing for directory traversal
    #   - Read access to specified directory and contained files
    # Arguments:
    #   $1: path - directory path containing files to concatenate and display
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Check if exactly one argument (directory path) is provided
    if [ $# -ne 1 ]; then
        aux_use
        return 1
    fi

    # Check if the argument is a directory
    if [ ! -d "$1" ]; then
        echo "$1 is not a directory."
        return 1
    fi

    # Concatenate all files within the directory
    for file in "$1"/*; do
        if [ -f "$file" ]; then
            echo "Contents of $file:"
            cat "$file"
            echo "-----------------------------------"
        fi
    done
}

# Replaces strings in files within a specified folder and its subfolders.
# replace strings folder
# <foldername> <old_string> <new_string>
usr_rsf() {
    # Technical Description:
    #   Performs recursive string replacement across all files in specified directory tree
    #   Uses find command to locate all regular files within the directory structure
    #   Applies sed substitution to replace all occurrences of target string
    #   Provides feedback on which files were modified during the operation
    #   Changes working directory to specified folder for relative path processing
    # Dependencies:
    #   - find command for recursive file discovery
    #   - grep for string matching and validation
    #   - sed with -i option for in-place file editing
    #   - cd command for directory navigation
    #   - Write access to target directory and contained files
    # Arguments:
    #   $1: foldername - target directory path for recursive string replacement
    #   $2: old_string - original string pattern to search and replace
    #   $3: new_string - replacement string to substitute for old_string
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    local foldername="$1"
    local old_string="$2"
    local new_string="$3"

    # Navigate to the specified folder
    cd "$foldername" || { echo "Folder not found: $foldername"; return 1; }

    # Run the substitution command with a check for modified files
    find . -type f -exec sh -c '
        for file; do
            if grep -q "$0" "$file"; then
                sed -i -e "s/$0/$1/g" "$file"
                echo "Modified $file"
            fi
        done
    ' "$old_string" "$new_string" {} +
}

# Performs an rsync operation from a source to a destination path. Displays files to be transferred and prompts for confirmation before proceeding
# rsync source (to) destination
# <source_path> <destination_path>
usr_rsd() {
    # Technical Description:
    #   Executes rsync file synchronization with interactive preview and confirmation
    #   Creates destination directory structure if it doesn't exist before transfer
    #   Displays dry-run preview of files to be transferred for user review
    #   Prompts user for explicit confirmation before executing actual transfer operation
    #   Uses rsync with archive mode, verbose output, and human-readable progress
    # Dependencies:
    #   - rsync command with -a, -v, -h, and -n options
    #   - mkdir with -p option for directory creation
    #   - read command for user input capture
    #   - Write access to destination path and parent directories
    # Arguments:
    #   $1: source_path - source directory or file path for rsync operation
    #   $2: destination_path - target destination path for file transfer
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    local source_path="$1"
    local destination_path="$2"

    # Check if destination path exists
    if [ ! -d "$destination_path" ]; then
        echo "Destination path $destination_path will be created."
        mkdir -p "$destination_path"
    fi
    # Check again
    if [ ! -d "$destination_path" ]; then
        echo "Destination path $destination_path could not been created."
        return 1
    fi

    # Display files to be transferred
    echo "Files to be transferred from $source_path to $destination_path:"
    rsync -avhn "$source_path/" "$destination_path/"

    # Ask for confirmation
    read -p "Do you want to proceed with the transfer? (y/n): " confirm
    case $confirm in
        [Yy])   # Proceed with the transfer
                # Perform the transfer
                rsync -avh --human-readable "$source_path/" "$destination_path/"
                echo "Transfer completed successfully."
                ;;
        [Nn])   # Abort the transfer
                echo "Transfer aborted."
                ;;
        *)      # Invalid input
                echo "Invalid input. Please enter 'y' or 'n'."
                ;;
    esac
}

# Schedules a system wake-up using rtcwake. Supports absolute or relative time input and different sleep states (mem/disk)
# sheduled wakeup timer
# <-r for relative or -a for absolute> <time> <state>
usr_swt() {
    # Technical Description:
    #   Implements system sleep scheduling with automatic wake-up using RTC (Real-Time Clock)
    #   Supports both absolute time (specific date/time) and relative time (hours:minutes from now)
    #   Handles multiple time input formats including HH:MM, HH, and full date-time strings
    #   Automatically adjusts absolute times to next occurrence if time has already passed today
    #   Provides interactive confirmation with readable time display before system sleep
    #   Supports different sleep states: 'mem' (suspend-to-RAM) and 'disk' (hibernate)
    # Dependencies:
    #   - rtcwake command with -m, -l, -t, and -v options
    #   - date command for time parsing and calculation
    #   - sudo privileges for system sleep operations
    #   - RTC hardware support for wake-up functionality
    #   - Read command for user confirmation input
    # Arguments:
    #   $1: mode - time mode flag: -r (relative) or -a (absolute)
    #   $2: time - time specification format depends on mode selection
    #   $3: state - sleep state: 'mem' (suspend) or 'disk' (hibernate)
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Check if correct number of arguments is provided
    if [ $# -lt 3 ]; then
        aux_use
        return 1
    fi

    local mode="$1"
    local input_time="$2"
    local state="$3"
    local wake_seconds
    local now=$(date +%s)

    # Validate sleep state
    if [[ "$state" != "mem" && "$state" != "disk" ]]; then
        echo "Invalid sleep state. Use 'mem' or 'disk'."
        return 1
    fi

    case "$mode" in
        -a)
            # Function to parse absolute time and get next occurrence
            get_next_occurrence() {
                local input="$1"
                local parsed_time

                # Try parsing as full date-time
                if date -d "$input" &>/dev/null; then
                    parsed_time=$(date -d "$input" +%s)
                # Try parsing as HH:MM
                elif [[ $input =~ ^[0-9]{1,2}:[0-9]{2}$ ]]; then
                    parsed_time=$(date -d "today $input" +%s)
                # Try parsing as HH
                elif [[ $input =~ ^[0-9]{1,2}$ ]]; then
                    parsed_time=$(date -d "today $input:00" +%s)
                else
                    echo "Invalid time format."
                    return 1
                fi

                # If the parsed time is in the past, add a day
                if [ $parsed_time -le $now ]; then
                    parsed_time=$(date -d "tomorrow $input" +%s)
                fi

                echo $parsed_time
            }

            wake_seconds=$(get_next_occurrence "$input_time")
            if [ $? -ne 0 ]; then
                return 1
            fi
            ;;
        -r)
            # Parse relative time
            local hours=0
            local minutes=0
            if [[ $input_time =~ ^[0-9]+:[0-9]+$ ]]; then
                IFS=':' read hours minutes <<< "$input_time"
            elif [[ $input_time =~ ^[0-9]+$ ]]; then
                hours=$input_time
            else
                echo "Invalid relative time format."
                return 1
            fi
            wake_seconds=$((now + hours*3600 + minutes*60))
            ;;
        *)
            echo "Invalid mode. Use -a for absolute time or -r for relative time."
            return 1
            ;;
    esac

    local duration=$((wake_seconds - now))
    local duration_readable=$(date -u -d @"$duration" +'%-Hh %-Mm %-Ss')
    local wake_time_readable=$(date -d @"$wake_seconds" +'%Y-%m-%d %H:%M:%S')

    echo "System will wake up at: $wake_time_readable"
    echo "Time until wake-up: $duration_readable"
    echo "Sleep state: $state"
    read -p "Do you want to proceed with putting the system to sleep? (y/n): " answer

    if [[ $answer =~ ^[Yy]$ ]]; then
        echo "Putting system to sleep using state '$state'. It will wake up at $wake_time_readable"

        sudo rtcwake -m $state -l -t "$wake_seconds" -v
        sleep_result=$?
        if [ $sleep_result -eq 0 ]; then
            echo "System woke up successfully."
            return 0
        else
            echo "Failed to sleep using state: $state (Exit code: $sleep_result)"
            return 1
        fi
    else
        echo "Operation cancelled."
    fi
}

# Adds a specific line to a target if not already present
# adding line (to) target
# <file> <line>
usr_adr() {
    # Technical Description:
    #   Safely appends a line to a file only if the exact line doesn't already exist
    #   Uses atomic file operations with temporary file to prevent data corruption
    #   Performs exact line matching using grep with fixed string and full line options
    #   Validates file existence and write permissions before attempting modifications
    #   Provides detailed feedback on operation success, failure, or line already present
    # Dependencies:
    #   - grep command with -F (fixed string) and -x (exact line) options
    #   - mktemp for secure temporary file creation
    #   - cat and mv commands for atomic file operations
    #   - rm command for temporary file cleanup on failure
    #   - Write access to target file and temporary file directory
    # Arguments:
    #   $1: file - target file path where line should be added
    #   $2: line - exact line content to add to the file
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local function_name="${FUNCNAME[0]}"
    local file="$1"
    local line_to_add="$2"
    local temp_file=$(mktemp)

    # Check if both arguments were provided (redundant now but keeping for safety)
    if [ -z "$file" ] || [ -z "$line_to_add" ]; then
        aux_log "ERROR" "$function_name: Error: Both file path and line to add must be provided"
        return 1
    fi

    # Check if the file exists and is writable
    if [ ! -w "$file" ]; then
        aux_log "ERROR" "$function_name: Error: $file does not exist or is not writable"
        return 1
    fi

    # Check if the line already exists in the file
    if grep -Fxq "$line_to_add" "$file"; then
        aux_log "INFO" "$function_name: Line already exists in $file"
        return 0
    fi

    # Create a temporary file with the new content
    cat "$file" > "$temp_file"
    echo "$line_to_add" >> "$temp_file"

    # Use mv to atomically replace the original file
    if mv "$temp_file" "$file"; then
        aux_log "INFO" "$function_name: Line added to $file"
        return 0
    else
        aux_log "ERROR" "$function_name: Error: Failed to update $file"
        rm -f "$temp_file"
        return 1
    fi
}

# Appends a line to a file if it does not already exist, preventing duplicate entries and providing feedback on the operation
# check append create
# <file> <line>
usr_cap() {
    # Technical Description:
    #   Checks for line existence in target file before appending to prevent duplicates
    #   Uses grep with fixed string matching to verify line presence or absence
    #   Appends line using shell redirection when line is not found in file
    #   Provides clear feedback indicating whether line was appended or already present
    #   Simpler implementation compared to usr_adr without atomic operations
    # Dependencies:
    #   - grep command with -F (fixed string) and -x (exact line) options
    #   - echo command for line appending via shell redirection
    #   - Write access to target file for append operations
    # Arguments:
    #   $1: file - target file path for line checking and appending
    #   $2: line - exact line content to check and potentially append
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
	aux_use
        return 1
    fi
    
    local file="$1"
    local line="$2"


    # Check if the line is already present in the file
    if ! grep -Fxq "$line" "$file"; then
        # If not, append the line to the file
        echo "$line" >> "$file"
        echo "Line appended to $file"
    else
        echo "Line already present in $file"
    fi
}

# Replaces all occurrences of a string in files within a given folder
# replace in files
# <path> <old_string> <new_string> [options: -d -r -i]
usr_rif() {
    # Technical Description:
    #   Advanced file content replacement tool with multiple operation modes and safety features
    #   Supports recursive directory traversal, interactive confirmation, and dry-run preview
    #   Implements colored output for enhanced readability and file modification tracking
    #   Excludes git directories by default with option to include them if needed
    #   Provides comprehensive summary statistics of files found, modified, and skipped
    #   Uses find with flexible filtering and sed for actual string replacements
    # Dependencies:
    #   - find command with -type, -maxdepth, and -not path options
    #   - grep for string matching and line number identification
    #   - sed with -i option for in-place file editing
    #   - realpath for absolute path conversion
    #   - read command for interactive user input
    #   - ANSI color code support for terminal output
    # Arguments:
    #   $1: path - target directory path for file processing
    #   $2: old_string - original string pattern to search and replace
    #   $3: new_string - replacement string to substitute for old_string
    #   Additional options: -d (dry run), -r (recursive), -i (interactive), --include-git
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Check minimum required arguments (path, old_string, new_string)
    local min_args=3
    local positional_args=0
    
    # Count positional arguments (non-option arguments)
    for arg in "$@"; do
        if [[ ! "$arg" =~ ^- ]]; then
            ((positional_args++))
        fi
    done
    
    if [ $positional_args -lt $min_args ]; then
        aux_use
        return 1
    fi
    
    local recursive=false
    local interactive=false
    local dry_run=false
    local directory=""
    local search_string=""
    local replace_string=""
    local ignore_git=true
    local files_found=0
    local files_modified=0
    local files_skipped=0

    # ANSI color codes
    local GREEN='\033[0;32m'
    local RED='\033[0;31m'
    local YELLOW='\033[0;33m'
    local NC='\033[0m' # No Color

    # Parse options and arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -r|--recursive) recursive=true; shift ;;
            -i|--interactive) interactive=true; shift ;;
            -d|--dry-run) dry_run=true; shift ;;
            --include-git) ignore_git=false; shift ;;
            *)
                if [[ -z "$directory" ]]; then
                    directory="$1"
                elif [[ -z "$search_string" ]]; then
                    search_string="$1"
                elif [[ -z "$replace_string" ]]; then
                    replace_string="$1"
                else
                    echo "Error: Too many arguments."
                    echo "Usage: usr-rif [-r] [-i] [-d] [--include-git] <directory> <search_string> <replace_string>"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Check if required arguments are provided
    if [[ -z "$directory" || -z "$search_string" || -z "$replace_string" ]]; then
        echo "Error: Missing required arguments."
        echo "Usage: usr-rif [-r] [-i] [-d] [--include-git] <directory> <search_string> <replace_string>"
        return 1
    fi

    # Validate and normalize directory path
    directory=$(realpath "$directory")
    if [[ ! -d "$directory" ]]; then
        echo "Error: '$directory' is not a valid directory."
        return 1
    fi

    # Construct find command
    local find_cmd="find \"$directory\" -type f"
    [[ "$recursive" != true ]] && find_cmd+=" -maxdepth 1"
    [[ "$ignore_git" == true ]] && find_cmd+=" -not -path '*/\.git/*'"

    echo "Searching for files containing '$search_string' in '$directory'..."
    while IFS= read -r file; do
        if grep -q "$search_string" "$file" 2>/dev/null; then
            ((files_found++))
            printf "\nFound match in file: ${GREEN}%s${NC}\n" "$file"
            if [[ "$dry_run" == true ]]; then
                echo "Would modify: $file"
                echo "Changes to be made:"
                grep -n "$search_string" "$file" | while IFS= read -r line; do
                    line_num=$(echo "$line" | cut -d: -f1)
                    content=$(echo "$line" | cut -d: -f2-)
                    match_start=$(echo "$content" | grep -b -o "$search_string" | cut -d: -f1)
                    printf "${RED}%s${NC}:%s${YELLOW}%s${NC}%s\n" \
                        "$line_num" \
                        "${content:0:$match_start}" \
                        "$search_string" \
                        "${content:$((match_start + ${#search_string}))}"
                done
            elif [[ "$interactive" == true ]]; then
                echo "=== INTERACTIVE MODE ==="
                echo -e "Modify '${GREEN}$file${NC}'? (${YELLOW}y${NC}/${YELLOW}n${NC}): "
                read -r user_response
                if [[ $user_response =~ ^[Yy]$ ]]; then
                    if sed -i "s/$search_string/$replace_string/g" "$file"; then
                        echo -e "${GREEN}Modified:${NC} $file"
                        ((files_modified++))
                    else
                        echo -e "${RED}Failed to modify:${NC} $file"
                    fi
                else
                    echo -e "${YELLOW}Skipped:${NC} $file"
                    ((files_skipped++))
                fi
            else
                if sed -i "s/$search_string/$replace_string/g" "$file"; then
                    echo -e "${GREEN}Modified:${NC} $file"
                    ((files_modified++))
                else
                    echo -e "${RED}Failed to modify:${NC} $file"
                fi
            fi
        fi
    done < <(eval "$find_cmd")

    echo -e "\nSummary:"
    echo "  Files found with matches: $files_found"
    echo "  Files modified: $files_modified"
    [[ "$interactive" == true ]] && echo "  Files skipped: $files_skipped"

    if [[ "$dry_run" == true ]]; then
        echo "Dry run completed. $files_found file(s) would be modified."
    elif [[ $files_modified -eq 0 ]]; then
        echo "No files were modified in '$directory'."
    else
        echo "$files_modified file(s) were modified in '$directory'."
    fi
}

# Navigates to the Ansible project directory, runs the playbook, then returns to the original directory
# ansible deployment desk
# <ansible_pro_path> <ansible_site_path>
usr_ans() {
    # Technical Description:
    #   Executes Ansible playbook deployment with automatic directory management
    #   Preserves current working directory by storing and restoring it after execution
    #   Navigates to specified Ansible project directory before running playbook
    #   Runs ansible-playbook command with provided site configuration file
    #   Handles directory navigation errors and prevents execution in wrong location
    # Dependencies:
    #   - ansible-playbook command from Ansible installation
    #   - cd command for directory navigation
    #   - pwd command for current directory capture
    #   - Read access to Ansible project directory
    #   - Execute permissions on Ansible playbook files
    # Arguments:
    #   $1: ansible_pro_path - path to Ansible project directory containing playbooks
    #   $2: ansible_site_path - path to Ansible site configuration file or playbook
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Check if two arguments are provided
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi

    # Store the Ansible path and site path from the arguments
    local ansible_pro_path="$1"
    local ansible_site_path="$2"

    # Store the current directory
    local current_dir=$(pwd)

    # Navigate to the specified Ansible directory
    cd "$ansible_pro_path" || return

    # Execute the Ansible playbook with the provided site path
    ansible-playbook "$ansible_site_path"

    # Return to the previous directory
    cd "$current_dir" || return
}
