#!/bin/bash

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Displays an overview of specific functions in the script, showing their usage, shortname, and description
# overview functions
# [function_name_filter]
sto_fun() {
    # Technical Description:
    #   Displays comprehensive overview of available storage functions with optional filtering
    #   Processes all arguments and forwards them to the analysis function
    #   Supports pattern-based filtering for function name matching
    #   Provides formatted output with usage information and descriptions
    # Dependencies:
    #   - 'ana_laf' function for list and filter operations
    #   - Access to function definition files
    #   - Pattern matching utilities for filtering
    # Arguments:
    #   $1: function_name_filter (optional) - pattern to filter function names
    #   Additional arguments are passed through to ana_laf
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Optional parameter - validate if provided
    if [ $# -gt 0 ] && ! aux_val "$1" "not_empty"; then
        aux_err "Function filter cannot be empty"
        aux_use
        return 1
    fi
    
    ana_laf "$FILEPATH_sto" "$@"
}
# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
# -x (execute)
sto_var() {
    # Technical Description:
    #   Scans configuration files for variable definitions and displays usage statistics
    #   Analyzes variable usage patterns across the codebase
    #   Provides insights into configuration management and variable dependencies
    #   Generates formatted output showing variable names, values, and file usage counts
    # Dependencies:
    #   - 'ana_acu' function for variable analysis and configuration processing
    #   - Read access to configuration files and source directories
    #   - Pattern matching utilities for variable identification
    # Arguments:
    #   $1: -x - explicit execution flag required for consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    if ! aux_val "$1" "not_empty"; then
        aux_err "Execution flag cannot be empty"
        aux_use
        return 1
    fi
    
    ana_acu -o "$CONFIG_sto" "$DIR_FUN/.."
}

# Adds auto-mount entries for devices to /etc/fstab using blkid. Allows user to select a device UUID and automatically creates the appropriate fstab entry
# fstab entry auto
# -x (execute)
sto_fea() {
    # Technical Description:
    #   Performs blkid scan to identify available storage devices with UUID information
    #   Filters results to show only sd* devices for safety and relevance
    #   Provides interactive device selection through numbered list interface
    #   Validates root privileges before attempting fstab modifications
    #   Creates standardized fstab entries with default mounting options
    # Dependencies:
    #   - 'blkid' command for device UUID identification
    #   - 'grep' for device filtering
    #   - 'sed' for text processing and UUID extraction
    #   - Root privileges for /etc/fstab modification
    #   - Write access to /etc/fstab file
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    if ! aux_val "$1" "not_empty"; then
        aux_err "Execution flag cannot be empty"
        aux_use
        return 1
    fi
    # Check dependencies
    if ! aux_chk "command" "blkid"; then
        aux_err "blkid command not found - required for device UUID identification"
        return 127
    fi
    
    if ! aux_chk "command" "grep"; then
        aux_err "grep command not found - required for device filtering"
        return 127
    fi
    
    # Check root privileges for fstab modifications
    if [ "$EUID" -ne 0 ]; then
        aux_err "Root privileges required for fstab operations"
        return 1
    fi

    # Perform blkid and filter entries with sd*
    aux_info "Starting device scan" "operation=blkid,filter=sd*"
    if ! blkid_output=$(aux_cmd "blkid"); then
        aux_err "Failed to execute blkid command"
        return 2
    fi
    
    blkid_output=$(echo "$blkid_output" | grep '/dev/sd*')
    
    # Validate scan results
    if [[ -z "$blkid_output" ]]; then
        aux_warn "No sd* devices found during scan"
        return 1
    fi

    # Display filtered results
    aux_info "Device scan completed" "devices_found=$(echo "$blkid_output" | wc -l)"
    echo "Filtered entries with sd*:"
    echo "$blkid_output"

    # Interactive device selection with validation
    local line_number
    line_number=$(aux_ask "Enter the line number to retrieve the UUID" "" "numeric")
    
    if ! aux_val "$line_number" "numeric"; then
        aux_err "Line number must be numeric: $line_number"
        return 1
    fi

    # Retrieve UUID based on the chosen line number
    chosen_line=$(echo "$blkid_output" | sed -n "${line_number}p")
    
    if [[ -z "$chosen_line" ]]; then
        aux_err "Invalid line number - no device found" "line=$line_number"
        return 1
    fi

    # Extract UUID from the chosen line
    TARGET_UUID=$(echo "$chosen_line" | grep -oP ' UUID="\K[^"]*')
    
    if [[ -z "$TARGET_UUID" ]]; then
        aux_err "No UUID found in selected device" "line=$line_number"
        return 1
    fi

    aux_info "UUID selected" "uuid=$TARGET_UUID,device_line=$line_number"

    # Check if the device's UUID is already present in /etc/fstab
    if aux_chk "file_exists" "/etc/fstab" && grep -q "UUID=$TARGET_UUID" /etc/fstab; then
        aux_warn "UUID already exists in fstab" "uuid=$TARGET_UUID"
        return 0
    fi

    # Create mount directory if it doesn't exist
    if ! aux_chk "dir_exists" "/mnt/auto"; then
        aux_info "Creating mount directory" "path=/mnt/auto"
        if ! aux_cmd "mkdir" "-p" "/mnt/auto"; then
            aux_err "Failed to create mount directory" "path=/mnt/auto"
            return 2
        fi
    fi

    # Backup existing fstab before modification
    local backup_file="/etc/fstab.backup.$(date +%s)"
    aux_info "Creating fstab backup" "backup_file=$backup_file"
    if ! aux_cmd "cp" "/etc/fstab" "$backup_file"; then
        aux_err "Failed to create fstab backup"
        return 2
    fi

    # Append entry to /etc/fstab for auto-mounting
    local fstab_entry="UUID=$TARGET_UUID /mnt/auto auto defaults 0 0"
    if echo "$fstab_entry" >> /etc/fstab; then
        aux_info "Fstab entry added successfully" "uuid=$TARGET_UUID,mountpoint=/mnt/auto,backup=$backup_file"
    else
        aux_err "Failed to add fstab entry" "uuid=$TARGET_UUID"
        return 2
    fi
}

# Adds custom entries to /etc/fstab using device UUIDs. Allows user to specify mount point, filesystem, mount options, and other parameters
# fstab entry custom
# <line_number> <mount_point> <filesystem> <mount_options> <fsck_pass_number> <mount_at_boot_priority>
sto_fec() {
  # Technical Description:
  #   Provides advanced fstab entry creation with full customization options
  #   Extracts UUID from blkid output based on user-specified line number
  #   Validates UUID extraction and provides error handling for invalid selections
  #   Creates fully customizable fstab entries with user-specified parameters
  #   Includes device listing functionality when called without parameters
  # Dependencies:
  #   - 'blkid' command for device UUID identification
  #   - 'sed' for UUID extraction from blkid output
  #   - 'nl' for numbered device listing
  #   - 'aux_use' function for usage information display
  #   - Write access to /etc/fstab file
  # Arguments:
  #   Called without parameters: displays numbered list of available devices
  #   $1: line_number - line number from blkid output to extract UUID
  #   $2: mount_point - filesystem mount point path
  #   $3: filesystem - filesystem type (ext4, btrfs, xfs, etc.)
  #   $4: mount_options - mount options (defaults, rw, etc.)
  #   $5: fsck_pass_number - filesystem check pass number (0, 1, 2)
  #   $6: mount_at_boot_priority - mount priority at boot (0, 1, 2)
  
  if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
      aux_tec
      return 0
  fi
  if [ $# -eq 0 ]; then
    # List blkid output with line numbers
    echo "Available devices:"
    blkid | nl -v 1
    aux_use
    return 0
  elif [ $# -ne 6 ]; then
    aux_use
    return 1
  fi

  # Validate all parameters
  if ! aux_val "$1" "numeric"; then
    aux_err "Line number must be numeric: $1"
    aux_use
    return 1
  fi
  
  if ! aux_val "$2" "not_empty"; then
    aux_err "Mount point cannot be empty"
    aux_use
    return 1
  fi
  
  if ! aux_val "$3" "not_empty"; then
    aux_err "Filesystem type cannot be empty"
    aux_use
    return 1
  fi
  
  if ! aux_val "$4" "not_empty"; then
    aux_err "Mount options cannot be empty"
    aux_use
    return 1
  fi
  
  if ! aux_val "$5" "numeric"; then
    aux_err "FSCK pass number must be numeric: $5"
    aux_use
    return 1
  fi
  
  if ! aux_val "$6" "numeric"; then
    aux_err "Mount priority must be numeric: $6"
    aux_use
    return 1
  fi

  line_number=$1
  mount_point=$2
  filesystem=$3
  mount_options=$4
  fsck_pass_number=$5
  mount_at_boot_priority=$6

  # Check dependencies
  if ! aux_chk "command" "blkid"; then
    aux_err "blkid command not found - required for device UUID identification"
    return 127
  fi
  
  if ! aux_chk "command" "sed"; then
    aux_err "sed command not found - required for UUID extraction"
    return 127
  fi
  
  if ! aux_chk "command" "nl"; then
    aux_err "nl command not found - required for device listing"
    return 127
  fi

  # Extract the UUID based on the specified line number with enhanced error handling
  aux_info "Extracting UUID from device list" "line_number=$line_number"
  
  local blkid_output
  if ! blkid_output=$(aux_cmd "blkid"); then
    aux_err "Failed to execute blkid command"
    return 2
  fi
  
  uuid=$(echo "$blkid_output" | sed -n "${line_number}s/.*UUID=\"\([^\"]*\)\".*/\1/p")
  if [ -z "$uuid" ]; then
    aux_err "No UUID found at specified line" "line=$line_number"
    aux_info "Available devices:" 
    echo "$blkid_output" | nl -v 1
    return 1
  fi

  aux_info "UUID extracted successfully" "uuid=$uuid,line=$line_number"
  aux_info "Creating fstab entry" "uuid=$uuid,mountpoint=$mount_point,filesystem=$filesystem,options=$mount_options"

  # Check if mount point directory exists, create if needed
  if ! aux_chk "dir_exists" "$mount_point"; then
    aux_info "Creating mount point directory" "path=$mount_point"
    if ! aux_cmd "mkdir" "-p" "$mount_point"; then
      aux_err "Failed to create mount point directory" "path=$mount_point"
      return 2
    fi
  fi

  # Create backup of fstab before modification
  local backup_file="/etc/fstab.backup.$(date +%s)"
  aux_info "Creating fstab backup" "backup_file=$backup_file"
  if ! aux_cmd "cp" "/etc/fstab" "$backup_file"; then
    aux_err "Failed to create fstab backup"
    return 2
  fi

  # Create the fstab entry
  fstab_entry="UUID=${uuid} ${mount_point} ${filesystem} ${mount_options} ${fsck_pass_number} ${mount_at_boot_priority}"

  # Check if UUID already exists in fstab
  if aux_chk "file_exists" "/etc/fstab" && grep -q "UUID=$uuid" /etc/fstab; then
    aux_warn "UUID already exists in fstab" "uuid=$uuid"
    return 0
  fi

  # Append the entry to /etc/fstab
  if echo "$fstab_entry" >> /etc/fstab; then
    aux_info "Fstab entry created successfully" "entry=$fstab_entry,backup=$backup_file"
  else
    aux_err "Failed to append entry to fstab" "entry=$fstab_entry"
    return 2
  fi
}

# Mounts an NFS share interactively or with provided arguments
# network file share
# <server_ip> <shared_folder> <mount_point> <options>
sto_nfs() {
    # Technical Description:
    #   Establishes NFS mount connections with comprehensive validation and error handling
    #   Creates mount point directories automatically if they don't exist
    #   Performs mount operation with user-specified NFS options
    #   Verifies successful mount through system mount table verification
    #   Provides detailed status reporting throughout the mount process
    # Dependencies:
    #   - 'mount' command with NFS support
    #   - 'mkdir' for mount point creation
    #   - 'grep' for mount verification
    #   - 'sudo' for privileged operations
    #   - NFS client utilities and kernel modules
    #   - Network connectivity to NFS server
    #   - 'aux_use' and 'aux_log' functions for messaging
    # Arguments:
    #   $1: server_ip - IP address or hostname of the NFS server
    #   $2: shared_folder - path to the shared folder on the NFS server
    #   $3: mount_point - local directory path where NFS share will be mounted
    #   $4: options - NFS mount options (e.g., "rw,sync,hard,intr")
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local function_name="${FUNCNAME[0]}"

    if [ $# -ne 4 ]; then
        aux_use
        return 1
    fi

    # Validate all parameters
    if ! aux_val "$1" "not_empty"; then
        aux_err "Server IP cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Shared folder cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$3" "not_empty"; then
        aux_err "Mount point cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$4" "not_empty"; then
        aux_err "Mount options cannot be empty"
        aux_use
        return 1
    fi

    local server_ip="$1"
    local shared_folder="$2"
    local mount_point="$3"
    local options="$4"

    # Check dependencies
    if ! aux_chk "command" "mount"; then
        aux_err "mount command not found - required for NFS mounting"
        return 127
    fi
    
    if ! aux_chk "command" "mkdir"; then
        aux_err "mkdir command not found - required for mount point creation"
        return 127
    fi
    
    if ! aux_chk "command" "sudo"; then
        aux_err "sudo command not found - required for privileged operations"
        return 127
    fi
    
    # Test network connectivity to NFS server
    aux_info "Testing network connectivity" "server=$server_ip"
    if ! aux_chk "network" "$server_ip"; then
        aux_warn "Network connectivity test failed" "server=$server_ip"
        local confirm=$(aux_ask "Continue despite network test failure?" "no" "alpha")
        if [[ "$confirm" != "yes" ]]; then
            aux_err "Operation aborted due to network connectivity issues"
            return 1
        fi
    else
        aux_info "Network connectivity confirmed" "server=$server_ip"
    fi

    # Create the mount point if it doesn't exist
    if ! aux_chk "dir_exists" "$mount_point"; then
        aux_info "Creating mount point" "path=$mount_point"
        if ! aux_cmd "sudo" "mkdir" "-p" "$mount_point"; then
            aux_err "Failed to create mount point" "path=$mount_point"
            return 2
        fi
        aux_info "Mount point created successfully" "path=$mount_point"
    else
        aux_info "Mount point already exists" "path=$mount_point"
    fi

    aux_info "Starting NFS mount operation" "server=$server_ip,share=$shared_folder,mountpoint=$mount_point,options=$options"
    
    # Check if already mounted
    if mount | grep -q "$mount_point"; then
        aux_warn "Mount point already in use" "mountpoint=$mount_point"
        local confirm=$(aux_ask "Unmount existing mount first?" "no" "alpha")
        if [[ "$confirm" == "yes" ]]; then
            aux_info "Unmounting existing mount" "mountpoint=$mount_point"
            if ! aux_cmd "sudo" "umount" "$mount_point"; then
                aux_err "Failed to unmount existing mount" "mountpoint=$mount_point"
                return 2
            fi
        else
            aux_err "Mount point already in use" "mountpoint=$mount_point"
            return 1
        fi
    fi
    
    # Perform the mount using aux_cmd for better error handling
    if aux_cmd "sudo" "mount" "-t" "nfs" "-o" "$options" "${server_ip}:${shared_folder}" "$mount_point"; then
        aux_info "NFS mount successful" "server=$server_ip,share=$shared_folder,mountpoint=$mount_point"
    else
        aux_err "NFS mount failed" "server=$server_ip,share=$shared_folder,options=$options"
        return 2
    fi

    # Verify the mount
    if mount | grep -q "$mount_point"; then
        aux_info "Mount verification successful" "mountpoint=$mount_point"
        # Display mount details
        local mount_info=$(mount | grep "$mount_point")
        aux_info "Mount details" "info=$mount_info"
    else
        aux_err "Mount verification failed" "mountpoint=$mount_point"
        return 2
    fi

    aux_log "INFO" "$function_name: NFS mount completed successfully" "server=$server_ip,share=$shared_folder,mountpoint=$mount_point"
}

# Transforms a folder into a Btrfs subvolume, optionally setting attributes (e.g., disabling COW). Handles multiple folders, preserving content and ownership.
# transforming folder subvolume
# <attribute_flag> <user_name> <folder_name> [additional_folders...]
sto_bfs_tra() {
    # Technical Description:
    #   Converts regular directories to Btrfs subvolumes with attribute management
    #   Preserves directory contents by moving to temporary location during conversion
    #   Sets filesystem attributes like Copy-on-Write (COW) disable for performance
    #   Manages ownership transfer to specified user account
    #   Supports batch processing of multiple directories in single operation
    # Dependencies:
    #   - 'btrfs' command with subvolume support
    #   - 'chattr' for filesystem attribute management
    #   - 'chown' for ownership changes
    #   - 'mv' for directory operations
    #   - 'rm' for cleanup operations
    #   - Btrfs filesystem mounted and accessible
    #   - Root or appropriate privileges for subvolume creation
    # Arguments:
    #   $1: attribute_flag - filesystem attribute to set (C for no-COW, or - for none)
    #   $2: user_name - username for subvolume ownership
    #   $3+: folder_name(s) - one or more folder names to convert to subvolumes
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    if [ $# -lt 3 ]; then
        aux_use
        return 1
    fi

    # Validate required parameters
    if ! aux_val "$1" "not_empty"; then
        aux_err "Attribute flag cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "User name cannot be empty"
        aux_use
        return 1
    fi

    local attr_flag="$1"
    local user_name="$2"
    shift 2

    # Check dependencies
    if ! aux_chk "command" "btrfs"; then
        aux_err "btrfs command not found - required for subvolume operations"
        return 127
    fi
    
    if ! aux_chk "command" "chattr"; then
        aux_err "chattr command not found - required for filesystem attributes"
        return 127
    fi
    
    if ! aux_chk "command" "chown"; then
        aux_err "chown command not found - required for ownership changes"
        return 127
    fi
    
    if ! aux_chk "command" "sudo"; then
        aux_err "sudo command not found - required for privileged operations"
        return 127
    fi
    
    # Validate user exists
    if ! aux_chk "variable" "user_name" || ! id "$user_name" >/dev/null 2>&1; then
        aux_err "User does not exist" "user=$user_name"
        return 1
    fi

    if [[ ! "$attr_flag" =~ ^[acdeijsuACDST-]$ ]]; then
        echo "Error: Invalid attribute flag. Use one of: a, c, d, e, i, j, s, u, A, C, D, S, T, or '-' for no attribute"
        aux_use
        return 1
    fi

    for folder_name in "$@"; do
        aux_info "Processing folder for subvolume conversion" "folder=$folder_name,user=$user_name,attribute=$attr_flag"
        
        # Validate folder exists and is a directory
        if ! aux_chk "dir_exists" "$folder_name"; then
            aux_err "Folder does not exist" "folder=$folder_name"
            continue
        fi
        
        local old_swap="${folder_name}-old"
        
        # Check if backup folder already exists
        if aux_chk "dir_exists" "$old_swap"; then
            aux_err "Backup folder already exists" "backup=$old_swap"
            continue
        fi

        # Move current folder to folder_name-old with error handling
        aux_info "Creating backup of original folder" "original=$folder_name,backup=$old_swap"
        if ! aux_cmd "mv" "$folder_name" "$old_swap"; then
            aux_err "Failed to create backup" "folder=$folder_name"
            continue
        fi

        # Create new subvolume with error handling
        aux_info "Creating Btrfs subvolume" "subvolume=$folder_name"
        if ! aux_cmd "sudo" "btrfs" "subvolume" "create" "$folder_name"; then
            aux_err "Failed to create subvolume" "subvolume=$folder_name"
            # Restore original folder on failure
            aux_cmd "mv" "$old_swap" "$folder_name"
            continue
        fi

        # Change ownership to specified user
        aux_info "Setting ownership" "subvolume=$folder_name,user=$user_name"
        if ! aux_cmd "sudo" "chown" "$user_name:" "$folder_name"; then
            aux_err "Failed to set ownership" "subvolume=$folder_name,user=$user_name"
        fi

        # Set attribute if specified
        if [ "$attr_flag" = "C" ]; then
            if aux_cmd "sudo" "chattr" "+C" "$folder_name"; then
                aux_info "COW disabled successfully" "subvolume=$folder_name"
            else
                aux_warn "Failed to disable COW" "subvolume=$folder_name"
            fi
        elif [ "$attr_flag" != "-" ]; then
            if aux_cmd "sudo" "chattr" "+$attr_flag" "$folder_name"; then
                aux_info "Attribute set successfully" "subvolume=$folder_name,attribute=$attr_flag"
            else
                aux_warn "Failed to set attribute" "subvolume=$folder_name,attribute=$attr_flag"
            fi
        else
            aux_info "No attribute specified" "subvolume=$folder_name"
        fi

        # Move contents from old folder to new one with error handling
        aux_info "Restoring folder contents" "from=$old_swap,to=$folder_name"
        if [ "$(ls -A "$old_swap" 2>/dev/null)" ]; then
            if ! aux_cmd "mv" "$old_swap"/* "$folder_name"; then
                aux_warn "Failed to move some contents" "from=$old_swap,to=$folder_name"
            fi
        else
            aux_info "Original folder was empty" "folder=$old_swap"
        fi

        # Remove old folder with error handling
        aux_info "Cleaning up backup folder" "backup=$old_swap"
        if ! aux_cmd "rm" "-r" "$old_swap"; then
            aux_warn "Failed to remove backup folder" "backup=$old_swap"
        fi

        aux_info "Folder conversion completed" "subvolume=$folder_name,user=$user_name,attribute=$attr_flag"
    done
}

# Creates a Btrfs RAID 1 filesystem on two specified devices, mounts it, and optionally adds an entry to /etc/fstab
# btrfs raid 1
# <device1> <device2> <mount_point>
sto_bfs_ra1() {
    # Technical Description:
    #   Creates a Btrfs RAID 1 filesystem with mirrored data and metadata
    #   Configures both data and metadata redundancy across two devices
    #   Establishes mount point and performs initial filesystem mount
    #   Provides filesystem status verification and space usage reporting
    #   Offers optional /etc/fstab integration with degraded mode support
    # Dependencies:
    #   - 'mkfs.btrfs' command for filesystem creation
    #   - 'btrfs' command for management operations
    #   - 'blkid' for UUID extraction
    #   - 'mkdir' for mount point creation
    #   - 'mount' for filesystem mounting
    #   - Two available block devices for RAID configuration
    #   - 'aux_use' and 'aux_log' functions for messaging
    # Arguments:
    #   $1: device1 - first block device path (e.g., /dev/sdb)
    #   $2: device2 - second block device path (e.g., /dev/sdc)
    #   $3: mount_point - directory path where filesystem will be mounted
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local function_name="${FUNCNAME[0]}"
    local device1="$1"
    local device2="$2"
    local mount_point="$3"
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    # Validate parameters
    if ! aux_val "$device1" "not_empty"; then
        aux_err "Device1 cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$device2" "not_empty"; then
        aux_err "Device2 cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$mount_point" "not_empty"; then
        aux_err "Mount point cannot be empty"
        aux_use
        return 1
    fi
    
    # Check dependencies
    if ! aux_chk "command" "mkfs.btrfs"; then
        aux_err "mkfs.btrfs command not found - required for filesystem creation"
        return 127
    fi
    
    if ! aux_chk "command" "btrfs"; then
        aux_err "btrfs command not found - required for filesystem management"
        return 127
    fi
    
    # Validate devices exist
    if ! aux_chk "file_exists" "$device1"; then
        aux_err "Device1 does not exist" "device=$device1"
        return 1
    fi
    
    if ! aux_chk "file_exists" "$device2"; then
        aux_err "Device2 does not exist" "device=$device2"
        return 1
    fi
    
    # Create Btrfs RAID 1 filesystem with enhanced logging
    aux_info "Creating Btrfs RAID 1 filesystem" "device1=$device1,device2=$device2,mount_point=$mount_point"
    if ! aux_cmd "mkfs.btrfs" "-m" "raid1" "-d" "raid1" "$device1" "$device2"; then
        aux_err "Failed to create Btrfs RAID 1 filesystem" "device1=$device1,device2=$device2"
        return 2
    fi

    # Create mount point and mount the filesystem
    aux_info "Creating mount point" "path=$mount_point"
    if ! aux_cmd "mkdir" "-p" "$mount_point"; then
        aux_err "Failed to create mount point" "path=$mount_point"
        return 2
    fi
    
    aux_info "Mounting filesystem" "device=$device1,mount_point=$mount_point"
    if ! aux_cmd "mount" "$device1" "$mount_point"; then
        aux_err "Failed to mount filesystem" "device=$device1,mount_point=$mount_point"
        return 2
    fi

    # Verify the RAID 1 setup
    aux_info "Verifying RAID 1 setup" "mount_point=$mount_point"
    if ! aux_cmd "btrfs" "filesystem" "show" "$mount_point"; then
        aux_warn "Failed to show filesystem info" "mount_point=$mount_point"
    fi
    
    if ! aux_cmd "btrfs" "filesystem" "df" "$mount_point"; then
        aux_warn "Failed to show filesystem usage" "mount_point=$mount_point"
    fi

    # Optionally add to fstab with enhanced error handling
    local uuid
    aux_info "Extracting UUID for fstab entry" "device=$device1"
    if ! uuid=$(aux_cmd "sudo" "blkid" "-s" "UUID" "-o" "value" "$device1"); then
        aux_err "Failed to extract UUID" "device=$device1"
        return 2
    fi
    
    if [[ -z "$uuid" ]]; then
        aux_err "Empty UUID extracted" "device=$device1"
        return 2
    fi
    
    local fstab_entry="UUID=$uuid $mount_point btrfs defaults,degraded 0 0"
    aux_info "Proposed fstab entry" "entry=$fstab_entry"

    echo "The following line will be added to /etc/fstab:"
    echo "$fstab_entry"
    
    local response=$(aux_ask "Do you want to add this line to /etc/fstab?" "N" "alpha")
    if [[ "$response" =~ ^[Yy]$ ]]; then
        # Create backup before modifying fstab
        local backup_file="/etc/fstab.backup.$(date +%s)"
        aux_info "Creating fstab backup" "backup_file=$backup_file"
        if ! aux_cmd "sudo" "cp" "/etc/fstab" "$backup_file"; then
            aux_err "Failed to create fstab backup"
            return 2
        fi
        
        if echo "$fstab_entry" | sudo tee -a /etc/fstab >/dev/null; then
            aux_info "Fstab entry added successfully" "entry=$fstab_entry,backup=$backup_file"
        else
            aux_err "Failed to add fstab entry" "entry=$fstab_entry"
            return 2
        fi
    else
        aux_info "Fstab entry not added per user choice"
    fi

    aux_log "INFO" "$function_name: Btrfs RAID 1 creation completed successfully" "device1=$device1,device2=$device2,mount_point=$mount_point,uuid=$uuid"
}

# Checks and lists subvolume status of folders in a specified path. Supports filtering by folder type (regular, hidden, or both) and subvolume status.
# check subvolume folder
# <path> <folder_type> <filter>
sto_bfs_csf() {
    # Technical Description:
    #   Analyzes directory structure to identify Btrfs subvolumes vs regular folders
    #   Supports filtering by folder visibility (regular, hidden, or both types)
    #   Cross-references folders with Btrfs subvolume list for accurate status
    #   Provides formatted output showing folder paths and subvolume status
    #   Enables selective display based on subvolume status filtering criteria
    # Dependencies:
    #   - 'btrfs' command with subvolume listing capabilities
    #   - 'find' for directory traversal and filtering
    #   - 'grep' for pattern matching and filtering
    #   - 'sort' for alphabetical ordering
    #   - Access to Btrfs filesystem for subvolume enumeration
    #   - 'aux_use' function for usage information
    # Arguments:
    #   $1: path - directory path to analyze for subvolumes
    #   $2: folder_type - folder visibility filter (1=regular, 2=hidden, 3=both)
    #   $3: filter - subvolume status filter (yes=subvolumes, no=folders, all=both)
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local path="$1"
    local folder_type="$2"
    local filter="$3"

    # Check if arguments are provided
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    # Validate parameters
    if ! aux_val "$path" "not_empty"; then
        aux_err "Path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$folder_type" "numeric"; then
        aux_err "Folder type must be numeric (1, 2, or 3)" "provided=$folder_type"
        aux_use
        return 1
    fi
    
    if ! aux_val "$filter" "not_empty"; then
        aux_err "Filter cannot be empty"
        aux_use
        return 1
    fi

    # Check if the path exists and is a directory
    if ! aux_chk "dir_exists" "$path"; then
        aux_err "Directory does not exist" "path=$path"
        return 1
    fi
    
    # Check dependencies
    if ! aux_chk "command" "btrfs"; then
        aux_err "btrfs command not found - required for subvolume operations"
        return 127
    fi
    
    if ! aux_chk "command" "find"; then
        aux_err "find command not found - required for directory traversal"
        return 127
    fi

    # Get the output of 'btrfs sub list' in the specified directory
    aux_info "Scanning for subvolumes" "path=$path,folder_type=$folder_type,filter=$filter"
    local subvol_output
    if ! subvol_output=$(aux_cmd "btrfs" "sub" "list" "-o" "$path"); then
        aux_err "Failed to list subvolumes" "path=$path"
        return 2
    fi

    # Get the list of folders based on folder type and sort alphabetically
    local all_folders
    if [ "$folder_type" -eq 1 ]; then
        aux_info "Finding regular folders" "path=$path"
        all_folders=$(find "$path" -mindepth 1 -maxdepth 1 ! -name ".*" -type d -exec basename {} \; | sort)
    elif [ "$folder_type" -eq 2 ]; then
        aux_info "Finding hidden folders" "path=$path"
        all_folders=$(find "$path" -mindepth 1 -maxdepth 1 -name ".*" -type d -exec basename {} \; | sort)
    elif [ "$folder_type" -eq 3 ]; then
        aux_info "Finding all folders" "path=$path"
        all_folders=$(find "$path" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)
    else
        aux_err "Invalid folder type argument" "valid_options=1,2,3,provided=$folder_type"
        aux_use
        return 1
    fi
    
    # Count found folders
    local folder_count=$(echo "$all_folders" | wc -w)
    aux_info "Folder scan completed" "folders_found=$folder_count,type=$folder_type"

    # Validate filter argument
    if [[ "$filter" != "yes" && "$filter" != "no" && "$filter" != "all" ]]; then
        aux_err "Invalid filter argument" "valid_options=yes,no,all,provided=$filter"
        aux_use
        return 1
    fi
    
    aux_info "Processing folders with filter" "filter=$filter"
    
    # Iterate over each folder and filter based on the third argument
    local folder_name
    local processed_count=0
    local subvol_count=0
    local regular_count=0
    
    for folder_name in $all_folders; do
        local is_subvol="no"
        if echo "$subvol_output" | grep -q "$path/$folder_name"; then
            is_subvol="yes"
            ((subvol_count++))
        else
            ((regular_count++))
        fi

        # Print the folder path and whether it is a subvolume based on the filter
        if [ "$filter" == "yes" ] && [ "$is_subvol" == "yes" ]; then
            printf "%-40s %-3s\n" "$path/$folder_name" "$is_subvol"
            ((processed_count++))
        elif [ "$filter" == "no" ] && [ "$is_subvol" == "no" ]; then
            printf "%-40s %-3s\n" "$path/$folder_name" "$is_subvol"
            ((processed_count++))
        elif [ "$filter" == "all" ]; then
            printf "%-40s %-3s\n" "$path/$folder_name" "$is_subvol"
            ((processed_count++))
        fi
    done
    
    aux_info "Analysis completed" "total_folders=$folder_count,subvolumes=$subvol_count,regular=$regular_count,displayed=$processed_count"
}

# Creates a new Snapper snapshot for the specified configuration or automatically selects a 'home_*' configuration if multiple exist
# snapper home create
# <configname>
sto_bfs_shc() {
    # Technical Description:
    #   Creates new Snapper snapshots with intelligent configuration selection
    #   Automatically discovers and selects from available home_* configurations
    #   Provides interactive configuration selection when multiple options exist
    #   Handles special 'home' keyword for automatic configuration detection
    #   Executes snapper create command with proper configuration context
    # Dependencies:
    #   - 'snapper' command with configuration management
    #   - 'awk' for configuration list processing
    #   - 'wc' for counting configuration entries
    #   - 'head' for selecting single configuration
    #   - 'grep' for configuration validation
    #   - Properly configured Snapper installation
    #   - 'aux_use' function for usage information
    # Arguments:
    #   $1: configname - Snapper configuration name or 'home' for auto-selection
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local configname=$1

    if [ -z "$configname" ]; then
        aux_use
        return 1
    fi

    if [ "$configname" == "home" ]; then
        # Get the list of configs
        configs=$(snapper list-configs | awk '$1 ~ /^home_/ {print $1}')

        # Count the number of home_ configs
        config_count=$(echo "$configs" | wc -l)

        if [ "$config_count" -eq 0 ]; then
            echo "No configurations found starting with 'home_'."
            return 1
        elif [ "$config_count" -eq 1 ]; then
            configname=$(echo "$configs" | head -n 1)
            echo "Using configuration: $configname"
        else
            echo "Multiple configurations found starting with 'home_':"
            echo "$configs"
            echo "Please enter the configuration name to use:"
            read selected_config
            if echo "$configs" | grep -q "^$selected_config$"; then
                configname=$selected_config
            else
                echo "Invalid configuration selected."
                return 1
            fi
        fi
    fi

    echo "snapper -c "$configname" create"
    snapper -c "$configname" create
}
# Deletes a specified Snapper snapshot from a given configuration or automatically selects a 'home_*' configuration if multiple exist
# snapper home delete
# <snapshot> [configname]
sto_bfs_shd() {
    # Technical Description:
    #   Removes specific Snapper snapshots with flexible configuration handling
    #   Supports both explicit configuration specification and automatic detection
    #   Automatically discovers and selects from available home_* configurations
    #   Provides interactive configuration selection when multiple options exist
    #   Executes snapper delete command with proper configuration and snapshot context
    # Dependencies:
    #   - 'snapper' command with snapshot management capabilities
    #   - 'awk' for configuration list processing
    #   - 'wc' for counting configuration entries
    #   - 'head' for selecting single configuration
    #   - 'grep' for configuration validation
    #   - Properly configured Snapper installation
    # Arguments:
    #   $1: snapshot - snapshot number or identifier to delete
    #   $2: configname (optional) - Snapper configuration name
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local configname
    local snapshot

    if [ $# -eq 0 ]; then
        aux_use
        return 1
    elif [ $# -eq 1 ]; then
        snapshot=$1
    else
        snapshot=$1
        configname=$2
    fi

    if [ -z "$configname" ]; then
        # Get the list of configs
        configs=$(snapper list-configs | awk '$1 ~ /^home_/ {print $1}')

        # Count the number of home_ configs
        config_count=$(echo "$configs" | wc -l)

        if [ "$config_count" -eq 0 ]; then
            echo "No configurations found starting with 'home_'."
            return 1
        elif [ "$config_count" -eq 1 ]; then
            configname=$(echo "$configs" | head -n 1)
            echo "Using configuration: $configname"
        else
            echo "Multiple configurations found starting with 'home_':"
            echo "$configs"
            echo "Please enter the configuration name to use:"
            read selected_config
            if echo "$configs" | grep -q "^$selected_config$"; then
                configname=$selected_config
            else
                echo "Invalid configuration selected."
                return 1
            fi
        fi
    fi

    echo "snapper -c "$configname" delete "$snapshot""
    snapper -c "$configname" delete "$snapshot"
}

# Lists Snapper snapshots for the specified configuration or automatically selects a 'home_*' configuration if multiple exist
# snapper home list
# <configname>
sto_bfs_shl() {
    # Technical Description:
    #   Displays comprehensive Snapper snapshot listings with intelligent configuration selection
    #   Automatically discovers and selects from available home_* configurations
    #   Provides interactive configuration selection when multiple options exist
    #   Handles special 'home' keyword for automatic configuration detection
    #   Executes snapper list command with proper configuration context
    # Dependencies:
    #   - 'snapper' command with snapshot listing capabilities
    #   - 'awk' for configuration list processing
    #   - 'wc' for counting configuration entries
    #   - 'head' for selecting single configuration
    #   - 'grep' for configuration validation
    #   - Properly configured Snapper installation
    #   - 'aux_use' function for usage information
    # Arguments:
    #   $1: configname - Snapper configuration name or 'home' for auto-selection
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local configname=$1

    if [ -z "$configname" ]; then
        aux_use
        return 1
    fi

    if [ "$configname" == "home" ]; then
        # Get the list of configs
        configs=$(snapper list-configs | awk '$1 ~ /^home_/ {print $1}')

        # Count the number of home_ configs
        config_count=$(echo "$configs" | wc -l)

        if [ "$config_count" -eq 0 ]; then
            echo "No configurations found starting with 'home_'."
            return 1
        elif [ "$config_count" -eq 1 ]; then
            configname=$(echo "$configs" | head -n 1)
            echo "Using configuration: $configname"
        else
            echo "Multiple configurations found starting with 'home_':"
            echo "$configs"
            echo "Please enter the configuration name to use:"
            read selected_config
            if echo "$configs" | grep -q "^$selected_config$"; then
                configname=$selected_config
            else
                echo "Invalid configuration selected."
                return 1
            fi
        fi
    fi

    echo "snapper -c "$configname" list"
    snapper -c "$configname" list
}

# Resyncs a Btrfs snapshot subvolume to a flat folder using rsync, excluding specific directories (.snapshots and .ssh) and preserving attributes
# snapshot flat resync
# <snapshot_subvolume> <target_folder>
sto_bfs_sfr() {
    # Technical Description:
    #   Synchronizes Btrfs snapshot contents to regular filesystem directories
    #   Preserves file attributes, permissions, and extended attributes during sync
    #   Excludes sensitive directories (.snapshots, .ssh) for security and consistency
    #   Performs deletions to ensure target matches source exactly
    #   Provides detailed transfer progress and comprehensive error reporting
    # Dependencies:
    #   - 'rsync' with extended attribute support (-aAXv flags)
    #   - Read access to source snapshot subvolume
    #   - Write access to target folder location
    #   - Sufficient disk space for complete synchronization
    #   - 'aux_use' function for usage information
    # Arguments:
    #   $1: snapshot_subvolume - path to source Btrfs snapshot subvolume
    #   $2: target_folder - destination directory for synchronized content
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local snapshot_sub="$1"
    local target_folder="$2"

    # Check if arguments are provided
    if [ -z "$snapshot_sub" ] || [ -z "$target_folder" ]; then
	aux_use
        return 1
    fi

    # Perform rsync with exclusions
    rsync -aAXv --delete \
        --exclude='.snapshots' \
        --exclude='.ssh' \
        "$snapshot_sub/" "$target_folder"

    # Check rsync exit status
    local rsync_status=$?
    if [ $rsync_status -ne 0 ]; then
        echo "rsync encountered an error. Exit status: $rsync_status"
    fi
}
# Creates a backup subvolume for a user's home directory on a backup drive, then sends and receives Btrfs snapshots incrementally, managing full and incremental backups
# home user backups
# <username> <snapshot_option>
sto_bfs_hub() {
    # Technical Description:
    #   Manages comprehensive Btrfs snapshot backup system for user home directories
    #   Creates backup subvolumes and directory structures automatically
    #   Performs incremental Btrfs send/receive operations for efficient transfers
    #   Handles both full initial backups and subsequent incremental updates
    #   Manages snapshot metadata (info.xml) preservation and logging
    #   Provides detailed logging with timestamps for audit and troubleshooting
    # Dependencies:
    #   - 'btrfs' command with send/receive capabilities
    #   - 'date' for timestamp generation
    #   - 'ls' and 'sort' for snapshot enumeration
    #   - 'mkdir' for directory creation
    #   - 'cp' for metadata file copying
    #   - 'xmllint' for XML processing
    #   - Source and backup Btrfs filesystems
    #   - Appropriate permissions for snapshot operations
    #   - 'aux_use' function for usage information
    # Arguments:
    #   $1: username - target user account name for backup operations
    #   $2: snapshot_option - snapshot processing mode (typically "all")
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local username="$1"
    local snapshot_option="$2"
    local source_sub="/home/$username"
    local source_dir="$source_sub/.snapshots"
    local backup_home="/bak"
    local backup_sub="$backup_home/$username"
    local backup_dir="$backup_sub/.snapshots"
    local log_file="$backup_home/.$username.log"

    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi

    log() {
       local message="$1"
       local short_timestamp=$(date '+%H:%M')
       local full_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
       echo "$short_timestamp - $message"
       echo "$full_timestamp - $message" >> "$log_file"
    }

    log_variables() {
        log "Username: $username"
        log "Snapshot option: $snapshot_option"
        log "Source user sub: $source_sub"
        log "Source snapshot dir: $source_dir"
        log "Backup drive: $backup_drive"
        log "Backup home: $backup_home"
        log "Backup user sub: $backup_sub"
        log "Backup snapshot dir: $backup_dir"
    }

    check_directories() {

	if [ ! -d "$source_sub" ]; then
            log "User home directory $source_sub does not exist."
            exit 1
        fi

        if [ ! -d "$backup_sub" ]; then
            log "Creating backup subvolume $backup_sub."
            btrfs subvolume create "$backup_sub"
        fi

        if [ ! -d "$backup_dir" ]; then
            log "Creating backup directory $backup_dir."
            mkdir -p "$backup_dir"
        fi
    }

    get_snapshots() {
        local dir="$1"
        echo $(ls "$dir" 2>/dev/null | sort -n)
    }

    log_snapshots() {
        log "Source snapshots : ${src_snapshots[*]}"
        log "Backup snapshots : ${tgt_snapshots[*]}"
    }

    copy_info_file() {
        local snapshot="$1"
        local info_source="$source_dir/$snapshot/info.xml"
        local info_target="$backup_dir/$snapshot/info.xml"

        if [ -f "$info_source" ]; then
            log "$(date '+%H:%M') - Copying $info_source to $info_target"
            mkdir -p "$(dirname "$info_target")"
            cp "$info_source" "$info_target"

            local timestamp=$(xmllint --xpath 'string(/snapshot/date)' "$info_source")
            log "$(date '+%H:%M') - Info.xml copied - containing snapshot timestamp: $timestamp"
        else
            log "$(date '+%H:%M') - Info.xml not found at $info_source for snapshot: $snapshot"
        fi
    }

    full_backup() {
        local snapshot="$1"
        log "Starting full backup of smallest snapshot: $snapshot"
        mkdir -p "$backup_dir/$snapshot"
        btrfs send "$source_dir/$snapshot/snapshot" | btrfs receive "$backup_dir/$snapshot"
        copy_info_file "$snapshot"
        log "Full backup of smallest snapshot $snapshot completed."
    }

    incremental_backup() {
        local parent_snapshot="$1"
        local snapshot="$2"
        log "Starting incremental backup of snapshot: $snapshot with parent snapshot: $parent_snapshot"
        mkdir -p "$backup_dir/$snapshot"
        if [ -n "$parent_snapshot" ]; then
            btrfs send -p "$source_dir/$parent_snapshot/snapshot" "$source_dir/$snapshot/snapshot" | btrfs receive "$backup_dir/$snapshot"
        else
            btrfs send "$source_dir/$snapshot/snapshot" | btrfs receive "$backup_dir/$snapshot"
        fi
        copy_info_file "$snapshot"
        log "Incremental backup of snapshot $snapshot completed."
    }


    perform_backups() {
        if [ ${#src_snapshots[@]} -gt 0 ] && [ ${#tgt_snapshots[@]} -eq 0 ]; then
            log "Target is empty and source has snapshots. Performing full and incremental backups."
            full_backup "${src_snapshots[0]}"
            prev_snapshot="${src_snapshots[0]}"
            for snapshot in "${src_snapshots[@]:1}"; do
                incremental_backup "$prev_snapshot" "$snapshot"
                prev_snapshot="$snapshot"
            done
        elif [ ${#src_snapshots[@]} -gt ${#tgt_snapshots[@]} ]; then
            log "There are fewer snapshots in the target. Performing incremental backups for missing snapshots."
            prev_snapshot=""
            for snapshot in "${src_snapshots[@]}"; do
                if ! [[ " ${tgt_snapshots[*]} " =~ " $snapshot " ]]; then
                    incremental_backup "$prev_snapshot" "$snapshot"
                fi
                prev_snapshot="$snapshot"
            done
        else
            log "No actions needed. Exiting."
        fi
    }

    check_directories
    log_variables
    src_snapshots=($(get_snapshots "$source_dir"))
    tgt_snapshots=($(get_snapshots "$backup_dir"))
    log_snapshots

    if [ ${#src_snapshots[@]} -eq 0 ] && [ ${#tgt_snapshots[@]} -eq 0 ]; then
        log "Both source and target snapshots are empty. Exiting."
        return 0
    fi

    perform_backups
}

# Recursively deletes a Btrfs parent subvolume and all its nested child subvolumes, with options for interactive mode and forced deletion
# subvolume nested delete
# [-i|-f] <parent_subvolume>
sto_bfs_snd() {
    # Technical Description:
    #   Performs recursive deletion of Btrfs subvolume hierarchies safely
    #   Traverses subvolume tree from leaves to root for proper deletion order
    #   Supports interactive confirmation mode for safety (-i flag)
    #   Provides forced deletion mode for automated operations (-f flag)
    #   Handles both absolute and relative path specifications
    #   Includes comprehensive error handling and rollback on failures
    # Dependencies:
    #   - 'btrfs' command with subvolume management capabilities
    #   - 'awk' and 'sed' for output processing
    #   - POSIX getopts for flag parsing
    #   - Access to Btrfs filesystem for subvolume operations
    #   - Appropriate permissions for subvolume deletion
    # Arguments:
    #   -i: interactive mode - prompts for confirmation before each deletion
    #   -f: force mode - performs deletion without confirmation prompts
    #   $1: parent_subvolume - path to parent subvolume for recursive deletion
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local target_path=""
    local interactive=false
    local force=false

    OPTIND=1

    while getopts "if" opt; do
        case $opt in
            i) interactive=true ;;
            f) force=true ;;
            \?) echo "Invalid option: -$OPTARG" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    if [ $# -eq 0 ]; then
        echo "Error: Target path not provided" >&2
        echo "Usage: sto-bfs-snd [-i|-f] <target_path>" >&2
        return 1
    fi

    target_path="$1"
    local full_path

    error() {
        echo "[ERROR] $1" >&2
    }

    list_subvolumes() {
        local path="$1"
        btrfs subvolume list -o "$path" | awk '{print $NF}' | sed 's|@/||g'
    }

    if [[ "$target_path" = /* ]]; then
        full_path="$target_path"
    else
        full_path="$(pwd)/$target_path"
    fi

    delete_subvolumes() {
        local current_path="$1"
        local subvolumes
        local can_delete=true

        mapfile -t subvolumes < <(list_subvolumes "$current_path")

        if [ ${#subvolumes[@]} -eq 0 ]; then
            if $interactive; then
                read -p "Delete subvolume $current_path? (y/n): " answer
                if [[ $answer != [Yy]* ]]; then
                    return 1
                fi
            fi
            if ! btrfs subvolume delete "$current_path"; then
                error "Failed to delete subvolume: $current_path"
                return 1
            fi
            return 0
        fi

        for subvol in "${subvolumes[@]}"; do
            local subvol_path="${current_path}/${subvol##*/}"
            if ! delete_subvolumes "$subvol_path"; then
                can_delete=false
                break  # Stop processing further subvolumes if one fails
            fi
        done

        if $can_delete; then
            if $interactive; then
                read -p "Delete subvolume $current_path? (y/n): " answer
                if [[ $answer != [Yy]* ]]; then
                    return 1
                fi
            fi
            if ! btrfs subvolume delete "$current_path"; then
                error "Failed to delete subvolume: $current_path"
                return 1
            fi
            return 0
        else
            return 1
        fi
    }

    if ! delete_subvolumes "$full_path"; then
        error "Failed to complete the subvolume deletion process"
        return 1
    fi

    echo "Subvolume deletion process completed successfully"
    return 0
}


# Creates a ZFS pool on a specified drive in a Proxmox VE environment
# zfs create pool
# <pool_name> <drive_name_or_path>
sto_zfs_cpo() {
    # Technical Description:
    #   Creates new ZFS storage pools on specified block devices
    #   Validates pool name uniqueness and device availability before creation
    #   Performs safety checks to prevent data loss on existing devices
    #   Provides interactive confirmation for destructive operations
    #   Displays pool status and configuration after successful creation
    # Dependencies:
    #   - 'zpool' command for ZFS pool management
    #   - 'sudo' for privileged operations
    #   - ZFS kernel modules loaded and functional
    #   - Target block device available and accessible
    #   - 'aux_use' and 'aux_log' functions for messaging
    # Arguments:
    #   $1: pool_name - name for the new ZFS pool
    #   $2: drive_name_or_path - block device path (e.g., /dev/sdX)
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local function_name="${FUNCNAME[0]}"
    local pool_name="$1"
    local drive_name="$2"

    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Validate parameters
    if ! aux_val "$pool_name" "not_empty"; then
        aux_err "Pool name cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$drive_name" "not_empty"; then
        aux_err "Drive name cannot be empty"
        aux_use
        return 1
    fi
    
    # Check dependencies
    if ! aux_chk "command" "zpool"; then
        aux_err "zpool command not found - required for ZFS pool management"
        return 127
    fi
    
    if ! aux_chk "command" "sudo"; then
        aux_err "sudo command not found - required for privileged operations"
        return 127
    fi

    # Check if the pool already exists
    aux_info "Checking for existing pool" "pool_name=$pool_name"
    if zpool list "$pool_name" &>/dev/null; then
        aux_err "ZFS pool already exists" "pool_name=$pool_name"
        return 1
    fi

    # Check if the drive exists (enhanced validation)
    aux_info "Validating drive" "drive_name=$drive_name"
    if ! aux_chk "file_exists" "$drive_name"; then
        aux_err "Drive not found" "drive_name=$drive_name"
        aux_info "Expected format" "examples=/dev/sdx,/dev/disk/by-id/your-disk-id"
        return 1
    fi
    
    # Additional safety check for block device
    if [ ! -b "$drive_name" ]; then
        aux_warn "Drive exists but may not be a block device" "drive_name=$drive_name"
        local confirm=$(aux_ask "Continue anyway?" "no" "alpha")
        if [[ "$confirm" != "yes" ]]; then
            aux_info "Operation cancelled by user"
            return 1
        fi
    fi

    aux_warn "This operation will DESTROY all data" "drive=$drive_name"
    aux_info "Pool creation parameters" "pool_name=$pool_name,drive_name=$drive_name"
    
    local confirmation=$(aux_ask "Are you sure you want to proceed? This will erase data on '$drive_name'" "N" "alpha")

    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
        aux_info "Starting ZFS pool creation" "pool_name=$pool_name,drive_name=$drive_name"
        if aux_cmd "sudo" "zpool" "create" "$pool_name" "$drive_name"; then
            aux_info "ZFS pool created successfully" "pool_name=$pool_name,drive_name=$drive_name"
            
            # Display pool status
            aux_info "Displaying pool status"
            if ! aux_cmd "sudo" "zpool" "status" "$pool_name"; then
                aux_warn "Failed to display pool status" "pool_name=$pool_name"
            fi
            
            aux_log "INFO" "$function_name: ZFS pool creation completed successfully" "pool_name=$pool_name,drive_name=$drive_name"
        else
            aux_err "Failed to create ZFS pool" "pool_name=$pool_name,drive_name=$drive_name"
            return 2
        fi
    else
        aux_info "ZFS pool creation cancelled by user" "pool_name=$pool_name"
        return 1
    fi
}


# Creates a new ZFS dataset or uses an existing one, sets its mountpoint, and ensures it's mounted at the specified path
# zfs directory mount
# <pool_name> <dataset_name> <mountpoint_path>
sto_zfs_dim() {
    # Technical Description:
    #   Manages ZFS dataset creation and mountpoint configuration
    #   Creates datasets automatically if they don't exist in the specified pool
    #   Establishes and configures custom mountpoint locations
    #   Creates required directory structures for mountpoints
    #   Validates and reports final mounting status with detailed feedback
    # Dependencies:
    #   - 'zfs' command for dataset management
    #   - 'mkdir' for directory creation
    #   - Existing ZFS pool for dataset creation
    #   - Appropriate permissions for ZFS operations
    #   - 'aux_use' and 'aux_log' functions for messaging
    # Arguments:
    #   $1: pool_name - existing ZFS pool name
    #   $2: dataset_name - name for the dataset within the pool
    #   $3: mountpoint_path - local directory path for dataset mounting
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local function_name="${FUNCNAME[0]}"
    local pool_name="$1"
    local dataset_name="$2"
    local mountpoint_path="$3"
    local dataset_path="$pool_name/$dataset_name"
    local newly_created=false
    if [ $# -ne 3 ]; then
	aux_use
        return 1
    fi

    # Check if the dataset exists, create it if not
    if ! zfs list "$dataset_path" &>/dev/null; then
        echo "Creating ZFS dataset '$dataset_path'."
        zfs create "$dataset_path" || { echo "Failed to create ZFS dataset '$dataset_path'"; exit 1; }
        echo "ZFS dataset '$dataset_path' created."
        newly_created=true
    else
        echo "ZFS dataset '$dataset_path' already exists."
    fi

    # Check if the mountpoint directory exists, create it if not
    if [ ! -d "$mountpoint_path" ]; then
        mkdir -p "$mountpoint_path" || { echo "Failed to create mountpoint directory '$mountpoint_path'"; exit 1; }
        echo "Mountpoint directory '$mountpoint_path' created."
    fi

    # Get the current mountpoint and compare with the expected mountpoint
    current_mountpoint=$(zfs get -H -o value mountpoint "$dataset_path")
    expected_mountpoint="$mountpoint_path"

    if [ "$current_mountpoint" != "$expected_mountpoint" ]; then
        zfs set mountpoint="$expected_mountpoint" "$dataset_path" || { echo "Failed to set mountpoint for ZFS dataset '$dataset_path'"; exit 1; }
        echo "ZFS dataset '$dataset_path' mounted at '$expected_mountpoint'."
    elif [ "$newly_created" = true ]; then
        echo "ZFS dataset '$dataset_path' newly mounted at '$expected_mountpoint'."
    else
        echo "ZFS dataset '$dataset_path' is already mounted at '$expected_mountpoint'."
    fi

    aux_log "INFO" "$function_name: executed ( $pool_name / $dataset_name )"
}

# Creates and sends ZFS snapshots from a source pool to a destination pool. Supports initial full sends and incremental sends for efficiency
# zfs dataset backup
# <sourcepoolname> <destinationpoolname> <datasetname>
sto_zfs_dbs() {
    # Technical Description:
    #   Manages ZFS snapshot creation and replication between pools
    #   Creates timestamped snapshots with hour-based naming convention
    #   Handles both initial full sends and incremental transfers for efficiency
    #   Automatically detects existing snapshots for incremental operations
    #   Provides interactive confirmation and detailed command preview
    # Dependencies:
    #   - 'zfs' command with snapshot and send/receive capabilities
    #   - 'date' for timestamp generation
    #   - 'grep' and 'tail' for snapshot discovery
    #   - Source and destination ZFS pools accessible
    #   - Appropriate permissions for ZFS snapshot operations
    #   - 'aux_use' function for usage information
    # Arguments:
    #   $1: sourcepoolname - source ZFS pool name
    #   $2: destinationpoolname - destination ZFS pool name
    #   $3: datasetname - dataset name within both pools
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    local sourcepoolname="$1"
    local destinationpoolname="$2"
    local datasetname="$3"

     if [ $# -ne 3 ]; then
	aux_use
        return 1
    fi

    # Generate a unique snapshot name based on the current date and hour
    local snapshot_name="$(date +%Y%m%d_%H)"
    local full_snapshot_name="${sourcepoolname}/${datasetname}@${snapshot_name}"

    # Check if the snapshot already exists
    if zfs list -t snapshot -o name | grep -q "^${full_snapshot_name}$"; then
        echo "Snapshot ${full_snapshot_name} already exists."
        read -p "Do you want to delete the existing snapshot? [y/N]: " delete_snapshot

        if [[ "$delete_snapshot" =~ ^[Yy]$ ]]; then
            # Delete the existing snapshot
            local delete_snapshot_cmd="zfs destroy ${full_snapshot_name}"
            echo "Deleting snapshot: ${delete_snapshot_cmd}"
            eval "${delete_snapshot_cmd}"
        else
            echo "Aborting backup to avoid overwriting existing snapshot."
            return 1
        fi
    fi

    # Create the snapshot
    local create_snapshot_cmd="zfs snapshot ${full_snapshot_name}"
    echo "Creating snapshot: ${create_snapshot_cmd}"
    eval "${create_snapshot_cmd}"

    # Determine the correct send and receive commands
    if zfs list -H -t snapshot -o name | grep -q "^${destinationpoolname}/${datasetname}@"; then
        # Get the name of the most recent snapshot in the destination pool
        local last_snapshot=$(zfs list -H -t snapshot -o name | grep "^${destinationpoolname}/${datasetname}@" | tail -1)

        # Prepare the incremental send and receive commands
        local send_cmd="zfs send -i ${last_snapshot} ${full_snapshot_name}"
        local receive_cmd="zfs receive ${destinationpoolname}/${datasetname}"

        echo "Incremental send command: ${send_cmd} | ${receive_cmd}"
    else
        # Prepare the initial full send and receive commands
        local send_cmd="zfs send ${full_snapshot_name}"
        local receive_cmd="zfs receive ${destinationpoolname}/${datasetname}"

        echo "Initial send command: ${send_cmd} | ${receive_cmd}"
    fi

    # Wait for user confirmation before executing the commands
    read -p "Press enter to execute the above command..."

    # Execute the send and receive commands
    eval "${send_cmd} | ${receive_cmd}"
}
