# filepath: /home/es/lab/lib/ops/ssh
#!/bin/bash

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Source auxiliary functions library for .std compliance
source "${DIR_FUN}/../gen/aux"

# Displays an overview of SSH-related functions in the script, showing their usage, shortname, and description
# overview functions
# <script_path>
ssh_fun() {
    # Technical Description:
    #   Invokes the 'ana_laf' (list available functions) utility.
    #   Accepts script path as explicit parameter for analysis.
    #   All remaining arguments are forwarded to 'ana_laf'.
    #   Primarily used for introspection of script capabilities.
    # Dependencies:
    #   - 'ana_laf' function from aux module
    #   - LIB_GEN_DIR environment variable
    #   - Read access to script files
    # Arguments:
    #   $1: script_path - path to the script file to analyze
    #   $@: additional arguments forwarded to ana_laf
    # Returns:
    #   Exit status of ana_laf command
    # Examples:
    #   ssh_fun "/path/to/script"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Parameter validation using aux_val (optional parameters allowed)
    if [ $# -gt 0 ]; then
        if ! aux_val "$FILEPATH_ssh" "file_exists"; then
            aux_err "SSH script file not found: $FILEPATH_ssh"
            aux_use
            return 1
        fi
    fi
    
    ana_laf "$FILEPATH_ssh" "$@"
}

# Displays an overview of SSH-specific variables defined in the configuration file, showing their names, values, and usage
# overview variables  
# <config_file> <lib_parent_dir>
ssh_var() {
    # Technical Description:
    #   Invokes the 'aux-lav' (list available variables) utility.
    #   Accepts config file path and library parent directory as explicit parameters.
    #   Searches for SSH-related variables and displays their definitions.
    # Dependencies:
    #   - 'aux-lav' function from aux module
    #   - LIB_GEN_DIR environment variable
    #   - Read access to configuration files
    # Arguments:
    #   $1: config_file - path to configuration file to analyze
    #   $2: lib_parent_dir - parent directory of libraries for context
    # Returns:
    #   Exit status of aux-lav command
    # Examples:
    #   ssh_var "/path/to/config" "/path/to/lib/.."
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Config file path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Library parent directory cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$1" "file_exists"; then
        aux_err "Config file not found: $1"
        return 2
    fi
    
    if ! aux_val "$2" "dir_exists"; then
        aux_err "Library parent directory not found: $2"
        return 2
    fi
    
    local config_file="$1"
    local lib_parent_dir="$2"
    source "${LIB_GEN_DIR}/aux"
    aux-lav "$config_file" "$lib_parent_dir" "ssh"
}

# Adds SSH keys to the SSH agent for authentication, supporting multiple key types and paths
# add ssh keys
# <key_paths_array[@]>
ssh_key() {
    # Technical Description:
    #   Loads specified SSH keys into the SSH agent if not already loaded.
    #   Starts SSH agent if not running. Validates key existence before loading.
    #   Uses ssh-keygen fingerprint comparison to avoid duplicate key loading.
    #   Processes array reference to handle multiple keys efficiently.
    # Dependencies:
    #   - ssh-add command for key management
    #   - ssh-agent command for agent management
    #   - ssh-keygen command for fingerprint generation
    #   - awk for fingerprint extraction
    # Arguments:
    #   $1: key_paths_array[@] - nameref to array of SSH key file paths to load
    # Returns:
    #   0 on success, non-zero on failure
    # Examples:
    #   ssh_key "SSH_KEY_PATHS"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Array name cannot be empty"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for SSH key management"
        return 127
    fi
    
    if ! aux_chk "command" "ssh-agent"; then
        aux_err "ssh-agent command not found - required for SSH agent management"
        return 127
    fi
    
    if ! aux_chk "command" "ssh-keygen"; then
        aux_err "ssh-keygen command not found - required for fingerprint generation"
        return 127
    fi
    
    if ! aux_chk "command" "awk"; then
        aux_err "awk command not found - required for fingerprint extraction"
        return 127
    fi
    
    local -n key_paths_ref=$1
    
    aux_info "Adding SSH keys to the agent" "array_name=$1"
    
    # Start SSH agent if not running
    if [ -z "$SSH_AUTH_SOCK" ]; then
        aux_info "Starting ssh-agent"
        if ! eval "$(ssh-agent -s)" > /dev/null; then
            aux_err "Failed to start ssh-agent"
            return 2
        fi
        aux_info "SSH agent started successfully"
    fi
    
    # Load each key if not already loaded
    for key in "${key_paths_ref[@]}"; do
        aux_info "Processing SSH key" "key_path=$key"
        
        if ! aux_val "$key" "file_exists"; then
            aux_warn "SSH key file not found" "key_path=$key"
            continue
        fi
        
        # Check if key is already loaded using fingerprint comparison
        local key_fingerprint
        key_fingerprint=$(ssh-keygen -lf "$key" 2>/dev/null | awk '{print $2}')
        
        if [[ -n "$key_fingerprint" ]] && ! ssh-add -l 2>/dev/null | grep -q "$key_fingerprint"; then
            if ssh-add "$key"; then
                aux_info "SSH key added successfully" "key_path=$key,fingerprint=$key_fingerprint"
            else
                aux_err "Failed to add SSH key" "key_path=$key"
            fi
        else
            aux_info "SSH key already loaded or invalid" "key_path=$key"
        fi
    done
    
    aux_info "SSH keys processing completed" "array_name=$1"
}

# Lists SSH keys currently loaded in the agent with detailed information
# list ssh keys
# -x (execute)
ssh_lst() {
    # Technical Description:
    #   Displays all SSH keys currently loaded in the SSH agent.
    #   Shows key fingerprints, types, and associated files.
    #   Provides clear status when no keys are loaded or agent is not running.
    # Dependencies:
    #   - ssh-add command for listing keys
    #   - Running SSH agent with SSH_AUTH_SOCK set
    # Arguments:
    #   $1: -x - explicit execution flag required for consistency
    # Returns:
    #   0 if keys found, 1 if no keys or agent not running
    # Examples:
    #   ssh_lst -x
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for listing SSH keys"
        return 127
    fi
    
    aux_info "Listing SSH keys in the agent"
    
    if ssh-add -l; then
        aux_info "SSH keys listed successfully"
        return 0
    else
        aux_warn "No SSH keys found or ssh-agent is not running"
        return 1
    fi
}

# Removes all SSH keys from the agent for security cleanup
# remove ssh keys
# -x (execute)
ssh_rmv() {
    # Technical Description:
    #   Removes all SSH keys from the SSH agent for security purposes.
    #   Useful for cleanup or when switching between different key sets.
    #   Provides clear feedback on operation success or failure.
    # Dependencies:
    #   - ssh-add command for key removal
    #   - Running SSH agent with loaded keys
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    # Returns:
    #   0 on success, 1 on failure
    # Examples:
    #   ssh_rmv -x
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for SSH key removal"
        return 127
    fi
    
    aux_info "Removing all SSH keys from the agent"
    
    if ssh-add -D; then
        aux_info "All SSH keys removed successfully from agent"
        return 0
    else
        aux_err "Failed to remove SSH keys from agent"
        return 2
    fi
}

# Generates new SSH keys with specified type and comment
# generate ssh key
# <key_type> <comment> [output_path]
ssh_gen() {
    # Technical Description:
    #   Creates new SSH key pair using specified algorithm and comment.
    #   Supports ed25519 (recommended) and rsa key types with appropriate parameters.
    #   Sets default output path if not specified, creates directory structure if needed.
    #   Provides comprehensive logging throughout the generation process.
    # Dependencies:
    #   - ssh-keygen command for key generation
    #   - log function for status reporting
    #   - Write permissions to output directory
    #   - HOME environment variable for default paths
    # Arguments:
    #   $1: key_type - type of key to generate (ed25519, rsa)
    #   $2: comment - comment to embed in the key for identification
    #   $3: output_path - path where to save the key (optional, defaults to ~/.ssh/id_<type>)
    # Returns:
    #   0 on success, non-zero on failure
    # Examples:
    #   ssh_gen "ed25519" "user@lab" "/root/.ssh/id_ed25519"
    #   ssh_gen "rsa" "user@lab"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -lt 2 ] || [ $# -gt 3 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Key type cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Comment cannot be empty"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-keygen"; then
        aux_err "ssh-keygen command not found - required for SSH key generation"
        return 127
    fi
    
    local key_type="$1"
    local comment="$2"
    local output_path="$3"
    
    # Set default output path if not specified
    if [[ -z "$output_path" ]]; then
        output_path="$HOME/.ssh/id_${key_type}"
    fi
    
    aux_info "Generating SSH key" "type=$key_type,comment=$comment,path=$output_path"
    
    case "$key_type" in
        ed25519)
            ssh-keygen -t ed25519 -C "$comment" -f "$output_path" || {
                aux_err "Failed to generate ed25519 key" "path=$output_path"
                return 1
            }
            ;;
        rsa)
            ssh-keygen -t rsa -b 4096 -C "$comment" -f "$output_path" || {
                aux_err "Failed to generate RSA key" "path=$output_path"
                return 1
            }
            ;;
        *)
            aux_err "Unsupported key type" "type=$key_type"
            return 1
            ;;
    esac
    
    aux_info "SSH key generated successfully" "path=$output_path,type=$key_type"
}

# Copies SSH public key to remote host for passwordless authentication
# copy ssh key
# <public_key_path> <target_host>
ssh_cpy() {
    # Technical Description:
    #   Copies SSH public key to remote host's authorized_keys file.
    #   Enables passwordless SSH authentication to the target host.
    #   Validates key file existence before attempting copy operation.
    #   Uses ssh-copy-id for secure and proper key installation.
    # Dependencies:
    #   - ssh-copy-id command for secure key copying
    #   - log function for status reporting
    #   - Network connectivity to target host
    #   - SSH access to target host (may require password)
    # Arguments:
    #   $1: public_key_path - absolute path to the public key file
    #   $2: target_host - target host in format [user@]hostname[:port]
    # Returns:
    #   0 on success, non-zero on failure
    # Examples:
    #   ssh_cpy "/root/.ssh/id_ed25519.pub" "root@192.168.1.100"
    #   ssh_cpy "/root/.ssh/id_rsa.pub" "user@example.com"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Public key path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Target host cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$1" "file_exists"; then
        aux_err "Public key file not found" "path=$1"
        return 2
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-copy-id"; then
        aux_err "ssh-copy-id command not found - required for SSH key copying"
        return 127
    fi
    
    local public_key_path="$1"
    local target_host="$2"
    
    aux_info "Copying SSH key to host" "key_path=$public_key_path,target=$target_host"
    
    if ssh-copy-id -i "$public_key_path" "$target_host"; then
        aux_info "SSH key copied successfully" "target=$target_host"
        return 0
    else
        aux_err "Failed to copy SSH key" "target=$target_host"
        return 2
    fi
}

# Starts SSH agent and ensures it's running for key management
# start ssh agent
# -x (execute)
ssh_agt() {
    # Technical Description:
    #   Starts SSH agent if not already running and exports environment variables.
    #   Ensures SSH_AUTH_SOCK and SSH_AGENT_PID are properly set.
    #   Checks for existing agent before starting new one to avoid conflicts.
    #   Provides clear feedback on agent status and startup success.
    # Dependencies:
    #   - ssh-agent command for agent management
    #   - ssh-add command for agent testing
    #   - log function for status reporting
    #   - eval for environment variable setting
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    # Returns:
    #   0 if agent started or already running, 1 on failure
    # Examples:
    #   ssh_agt -x
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-agent"; then
        aux_err "ssh-agent command not found - required for SSH agent management"
        return 127
    fi
    
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for SSH agent testing"
        return 127
    fi
    
    if [ -n "$SSH_AUTH_SOCK" ] && ssh-add -l >/dev/null 2>&1; then
        aux_info "SSH agent is already running" "auth_sock=$SSH_AUTH_SOCK"
        return 0
    fi
    
    aux_info "Starting SSH agent"
    
    if eval "$(ssh-agent -s)"; then
        aux_info "SSH agent started successfully" "auth_sock=$SSH_AUTH_SOCK,pid=$SSH_AGENT_PID"
        return 0
    else
        aux_err "Failed to start ssh-agent"
        return 2
    fi
}

# Resolves custom SSH aliases using the configuration file. Supports connecting to single or multiple servers, executing commands remotely
# ssh custom aliases
# <usershortcut> <servershortcut> <ssh_users_array_name> <all_ip_arrays_array_name> <array_aliases_array_name> [command]
ssh_sca() {
    # Technical Description:
    #   Resolves user and server shortcuts from configuration arrays using nameref declarations.
    #   Supports single server, multiple servers, or entire arrays for batch operations.
    #   Can execute commands remotely on multiple servers with proper error handling.
    #   Uses dynamic array access for flexible configuration management.
    #   Handles 'all' keyword for operations across all server arrays.
    #   Provides comprehensive logging throughout the connection process.
    # Dependencies:
    #   - ssh command for remote connections
    #   - declare with nameref support for dynamic array access
    #   - aux_val for parameter validation
    #   - aux_cmd for safe command execution
    #   - aux_dbg, aux_info, aux_warn, aux_err for logging
    #   - Array variables passed by name for configuration
    # Arguments:
    #   $1: usershortcut - shortcut key for user lookup in ssh_users_array
    #   $2: servershortcut - shortcut key(s) for server lookup, supports comma-separated values
    #   $3: ssh_users_array_name - name of associative array containing user mappings
    #   $4: all_ip_arrays_array_name - name of array containing all IP array names
    #   $5: array_aliases_array_name - name of associative array containing array aliases
    #   $6+: command - optional command to execute on remote server(s)
    # Returns:
    #   0 on success, 1 on parameter validation failure or connection errors
    # Examples:
    #   ssh_sca "r" "web1" "SSH_USERS" "ALL_IP_ARRAYS" "ARRAY_ALIASES"
    #   ssh_sca "r" "web1,web2" "SSH_USERS" "ALL_IP_ARRAYS" "ARRAY_ALIASES" "uptime"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -lt 5 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "User shortcut cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Server shortcut cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$3" "not_empty"; then
        aux_err "SSH users array name cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$4" "not_empty"; then
        aux_err "All IP arrays name cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$5" "not_empty"; then
        aux_err "Array aliases name cannot be empty"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh"; then
        aux_err "ssh command not found - required for SSH connections"
        return 127
    fi

    aux_dbg "Starting SSH custom aliases resolution" "args=$#,user_shortcut=$1,server_shortcuts=$2"

    local user_shortcut=$1
    local server_shortcuts=$2
    local ssh_users_array_name=$3
    local all_ip_arrays_name=$4
    local array_aliases_name=$5
    shift 5
    local command="$*"

    # Declare namerefs to the passed associative array names
    declare -n _ssh_users_ref="$ssh_users_array_name"
    declare -n _all_ip_arrays_ref="$all_ip_arrays_name"
    declare -n _array_aliases_ref="$array_aliases_name"

    aux_dbg "Resolving user shortcut" "shortcut=$user_shortcut"

    # Resolve user name from shortcut
    local user_name="${_ssh_users_ref[$user_shortcut]}"
    aux_dbg "User resolution result" "user_name=$user_name"

    if [[ -z $user_name ]]; then
        aux_err "Unknown user shortcut" "shortcut=$user_shortcut,available_keys=${!_ssh_users_ref[*]}"
        return 1
    fi

    aux_info "SSH alias resolution started" "user=$user_name,server_shortcuts=$server_shortcuts"

    # Function to handle an array of servers
    handle_server_array() {
        local array_name=$1
        declare -n server_array=$array_name
        aux_dbg "Processing server array" "array_name=$array_name,server_count=${#server_array[@]}"
        
        for server_shortcut in "${!server_array[@]}"; do
            local server_ip=${server_array[$server_shortcut]}
            aux_dbg "Processing server" "shortcut=$server_shortcut,ip=$server_ip"
            
            # Construct and execute the SSH command
            if [[ -n $command ]]; then
                aux_info "Executing remote command" "server=$server_shortcut,ip=$server_ip,command=$command"
                if aux_cmd "ssh" "${user_name}@${server_ip}" "$command"; then
                    aux_info "Remote command executed successfully" "server=$server_shortcut"
                else
                    aux_err "Remote command failed" "server=$server_shortcut,ip=$server_ip"
                fi
            else
                aux_info "Opening SSH session" "server=$server_shortcut,ip=$server_ip"
                if aux_cmd "ssh" "${user_name}@${server_ip}"; then
                    aux_info "SSH session completed" "server=$server_shortcut"
                else
                    aux_err "SSH session failed" "server=$server_shortcut,ip=$server_ip"
                fi
            fi
        done
    }

    # Function to normalize server shortcuts
    normalize_shortcut() {
        local input=$1
        local normalized=$input

        # Check if input matches any array name or alias (case-insensitive)
        for array in "${!_array_aliases_ref[@]}"; do
            local aliases=(${_array_aliases_ref[$array]})
            for alias in "${aliases[@]}"; do
                if [[ ${input,,} == ${alias,,} ]]; then
                    normalized=$array
                    aux_dbg "Alias match found" "input=$input,normalized=$normalized"
                    break 2
                fi
            done
        done

        aux_dbg "Shortcut normalization" "input=$input,output=$normalized"
        echo "$normalized"
    }

    # Function to find server IP
    find_server_ip() {
        local shortcut=$1
        local ip=""
        local array_name_found=""
        
        for current_array_name in "${_all_ip_arrays_ref[@]}"; do
            aux_dbg "Searching for server" "shortcut=$shortcut,array=$current_array_name"
            declare -n current_array_ref=$current_array_name
            
            if [[ -n ${current_array_ref[$shortcut]} ]]; then
                ip=${current_array_ref[$shortcut]}
                array_name_found=$current_array_name
                aux_dbg "Server found" "shortcut=$shortcut,ip=$ip,array=$array_name_found"
                break
            fi
        done
        
        if [[ -z "$ip" ]]; then
            aux_warn "Server not found" "shortcut=$shortcut"
        fi
        
        echo "$ip"
    }

    # Function to check if input is an array name
    is_array_name() {
        local input=$1
        aux_dbg "Checking if input is array name" "input=$input"
        
        if [[ $input == "all" ]]; then
            aux_dbg "Input is 'all' keyword" "input=$input"
            return 0
        fi
        
        for array_iter_name in "${_all_ip_arrays_ref[@]}"; do
            if [[ $input == $array_iter_name ]]; then
                aux_dbg "Input matches array name" "input=$input,array=$array_iter_name"
                return 0
            fi
        done
        
        aux_dbg "Input is not an array name" "input=$input"
        return 1
    }

    # Normalize the server shortcuts
    local normalized_shortcuts=$(normalize_shortcut "$server_shortcuts")
    aux_dbg "Server shortcuts normalized" "original=$server_shortcuts,normalized=$normalized_shortcuts"

    # Handle server_shortcuts
    if is_array_name "$normalized_shortcuts"; then
        aux_info "Processing as array operation" "array=$normalized_shortcuts"
        
        if [[ $normalized_shortcuts == "all" ]]; then
            aux_info "Processing all server arrays" "total_arrays=${#_all_ip_arrays_ref[@]}"
            for array_to_handle in "${_all_ip_arrays_ref[@]}"; do
                handle_server_array $array_to_handle
            done
        else
            aux_info "Processing specific server array" "array=$normalized_shortcuts"
            handle_server_array $normalized_shortcuts
        fi
    else
        aux_info "Processing as individual server(s)" "servers=$normalized_shortcuts"
        IFS=',' read -ra servers <<< "$normalized_shortcuts"
        
        if [[ ${#servers[@]} -gt 1 && -z $command ]]; then
            aux_err "No command provided for multiple servers" "server_count=${#servers[@]}"
            return 1
        fi
        
        for server_shortcut_iter in "${servers[@]}"; do
            local server_ip=$(find_server_ip "$server_shortcut_iter")
            if [[ -z $server_ip ]]; then
                aux_err "Unknown server shortcut" "shortcut=$server_shortcut_iter"
                return 1
            fi
            
            if [[ -n $command ]]; then
                aux_info "Executing remote command on single server" "server=$server_shortcut_iter,ip=$server_ip,command=$command"
                if aux_cmd "ssh" "${user_name}@${server_ip}" "$command"; then
                    aux_info "Remote command executed successfully" "server=$server_shortcut_iter"
                else
                    aux_err "Remote command failed" "server=$server_shortcut_iter,ip=$server_ip"
                fi
            else
                aux_info "Opening SSH session to single server" "server=$server_shortcut_iter,ip=$server_ip"
                if aux_cmd "ssh" "${user_name}@${server_ip}"; then
                    aux_info "SSH session completed" "server=$server_shortcut_iter"
                else
                    aux_err "SSH session failed" "server=$server_shortcut_iter,ip=$server_ip"
                fi
            fi
        done
    fi
    
    aux_info "SSH custom aliases operation completed" "user=$user_name,servers=$server_shortcuts"
}

# Uploads an SSH key from a plugged-in device to a specified folder (default: /root/.ssh). Handles mounting, file copying, and unmounting of the device
# ssh upload keyfile
# <device_path> <mount_point> <subfolder_path> <upload_path> <file_name>
ssh_suk() {
    # Technical Description:
    #   Mounts external device at specified mount point and copies SSH key files.
    #   Creates mount point directory if it doesn't exist for seamless operation.
    #   Copies SSH key from device subfolder to target location with validation.
    #   Safely unmounts device after operation to prevent data corruption.
    #   Validates all required parameters before proceeding.
    #   Displays system information (lsblk, /mnt contents) for user guidance.
    #   Uses auxiliary functions for proper validation, logging, and safe command execution.
    # Dependencies:
    #   - mount/umount commands for device management
    #   - cp command for file copying
    #   - mkdir command for directory creation
    #   - lsblk command for device listing
    #   - ls command for directory listing
    #   - aux_val for parameter validation
    #   - aux_chk for dependency checking
    #   - aux_cmd for safe command execution
    #   - aux_info, aux_warn, aux_err for logging
    #   - Device must be properly formatted and accessible
    # Arguments:
    #   $1: device_path - path to the device (e.g., /dev/sdb1)
    #   $2: mount_point - directory where device will be mounted
    #   $3: subfolder_path - path within the mounted device to the key file
    #   $4: upload_path - destination directory for the key file
    #   $5: file_name - name of the key file to copy
    # Returns:
    #   0 on success, 1 on parameter validation failure, 2 on operation failure
    # Examples:
    #   ssh_suk "/dev/sdb1" "/mnt/usb" "ssh_keys" "/root/.ssh" "id_ed25519"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 5 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Device path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Mount point cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$3" "not_empty"; then
        aux_err "Subfolder path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$4" "not_empty"; then
        aux_err "Upload path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$5" "not_empty"; then
        aux_err "File name cannot be empty"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "mount"; then
        aux_err "mount command not found - required for device mounting"
        return 127
    fi
    
    if ! aux_chk "command" "umount"; then
        aux_err "umount command not found - required for device unmounting"
        return 127
    fi
    
    if ! aux_chk "command" "cp"; then
        aux_err "cp command not found - required for file copying"
        return 127
    fi
    
    if ! aux_chk "command" "mkdir"; then
        aux_err "mkdir command not found - required for directory creation"
        return 127
    fi
    
    local device_path="$1"
    local mount_point="$2"
    local subfolder_path="$3"
    local upload_path="$4"
    local file_name="$5"
    local full_path="$mount_point/$subfolder_path/$file_name"
    local upload_full_path="$upload_path/$file_name"

    aux_info "Starting SSH key upload from device" "device=$device_path,mount_point=$mount_point,file=$file_name"

    # Display system information for user guidance
    aux_info "Displaying current block devices"
    if aux_chk "command" "lsblk"; then
        lsblk
    else
        aux_warn "lsblk command not available - skipping device listing"
    fi
    
    aux_info "Displaying current /mnt contents"
    if aux_cmd "ls" "/mnt"; then
        aux_dbg "Successfully listed /mnt contents"
    else
        aux_warn "Could not list /mnt contents" "/mnt may not exist or be accessible"
    fi

    # Validate device path exists
    if ! aux_chk "file_exists" "$device_path"; then
        aux_err "Device not found" "device_path=$device_path"
        return 2
    fi

    # Validate upload directory exists
    if ! aux_val "$upload_path" "dir_exists"; then
        aux_warn "Upload directory does not exist, creating it" "path=$upload_path"
        if ! aux_cmd "mkdir" "-p" "$upload_path"; then
            aux_err "Failed to create upload directory" "path=$upload_path"
            return 2
        fi
    fi

    # Check if mount point exists, create if needed
    if ! aux_val "$mount_point" "dir_exists"; then
        aux_info "Creating mount point directory" "path=$mount_point"
        if ! aux_cmd "mkdir" "-p" "$mount_point"; then
            aux_err "Failed to create mount point directory" "path=$mount_point"
            return 2
        fi
    fi

    # Mount the device
    aux_info "Mounting device" "device=$device_path,mount_point=$mount_point"
    if ! aux_cmd "mount" "$device_path" "$mount_point"; then
        aux_err "Failed to mount device" "device=$device_path,mount_point=$mount_point"
        return 2
    fi
    
    aux_info "Device mounted successfully" "device=$device_path,mount_point=$mount_point"

    # Validate the source file exists on the mounted device
    if ! aux_val "$full_path" "file_exists"; then
        aux_err "SSH key file not found on mounted device" "path=$full_path"
        # Clean up by unmounting
        if aux_cmd "umount" "$mount_point"; then
            aux_info "Device unmounted after error" "mount_point=$mount_point"
        else
            aux_warn "Failed to unmount device after error" "mount_point=$mount_point"
        fi
        return 2
    fi

    # Copy the SSH key to the upload path
    aux_info "Copying SSH key file" "source=$full_path,destination=$upload_full_path"
    if ! aux_cmd "cp" "$full_path" "$upload_full_path"; then
        aux_err "Failed to copy SSH key file" "source=$full_path,destination=$upload_full_path"
        # Clean up by unmounting
        if aux_cmd "umount" "$mount_point"; then
            aux_info "Device unmounted after copy failure" "mount_point=$mount_point"
        else
            aux_warn "Failed to unmount device after copy failure" "mount_point=$mount_point"
        fi
        return 2
    fi
    
    aux_info "SSH key file copied successfully" "destination=$upload_full_path"

    # Set proper permissions on the copied key
    if aux_chk "command" "chmod"; then
        if aux_cmd "chmod" "600" "$upload_full_path"; then
            aux_info "SSH key permissions set" "file=$upload_full_path,permissions=600"
        else
            aux_warn "Failed to set SSH key permissions" "file=$upload_full_path"
        fi
    fi

    # Unmount the device
    aux_info "Unmounting device" "mount_point=$mount_point"
    if ! aux_cmd "umount" "$mount_point"; then
        aux_err "Failed to unmount device" "mount_point=$mount_point"
        # Note: We don't return error here as the copy was successful
        aux_warn "SSH key copied but device unmount failed - manual unmount may be required"
    else
        aux_info "Device unmounted successfully" "mount_point=$mount_point"
    fi

    aux_info "SSH key upload completed successfully" "file=$upload_full_path"
}


# Appends a private SSH key identifier to the SSH config file for a specified user. Creates the .ssh directory and config file if they don't exist
# ssh private identifier
# <user> <keyname>
ssh_spi() {
    # Technical Description:
    #   Creates .ssh directory structure if missing with proper permissions.
    #   Adds IdentityFile entry to SSH config for specified key with Host * scope.
    #   Handles both root and regular user configurations with appropriate paths.
    #   Sets proper ownership and permissions (600) for security compliance.
    #   Avoids duplicate entries by checking existing config content.
    #   Creates config file with proper structure if it doesn't exist.
    #   Uses auxiliary functions for validation, logging, and safe command execution.
    # Dependencies:
    #   - mkdir command for directory creation
    #   - grep command for duplicate detection
    #   - echo command for config file writing
    #   - chown command for ownership setting
    #   - chmod command for permission setting
    #   - aux_val for parameter validation
    #   - aux_chk for dependency checking
    #   - aux_cmd for safe command execution
    #   - aux_info, aux_warn, aux_err for logging
    #   - Appropriate privileges for user directory access
    # Arguments:
    #   $1: user - username (root or regular user) for configuration
    #   $2: keyname - name of the SSH key file (without path)
    # Returns:
    #   0 on success, 1 on parameter validation failure, 2 on operation failure
    # Examples:
    #   ssh_spi "root" "id_ed25519_lab"
    #   ssh_spi "alice" "id_rsa_work"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Username cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Key name cannot be empty"
        aux_use
        return 1
    fi
    
    # Validate username contains only valid characters
    if ! aux_val "$1" "alphanum"; then
        aux_err "Username must contain only alphanumeric characters" "user=$1"
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "mkdir"; then
        aux_err "mkdir command not found - required for directory creation"
        return 127
    fi
    
    if ! aux_chk "command" "grep"; then
        aux_err "grep command not found - required for duplicate detection"
        return 127
    fi
    
    if ! aux_chk "command" "chown"; then
        aux_err "chown command not found - required for ownership setting"
        return 127
    fi
    
    if ! aux_chk "command" "chmod"; then
        aux_err "chmod command not found - required for permission setting"
        return 127
    fi
    
    local user="$1"
    local keyname="$2"
    local ssh_dir
    local config_file
    local user_home

    aux_info "Starting SSH private identifier configuration" "user=$user,keyname=$keyname"

    # Determine user paths
    if [ "$user" == "root" ]; then
        ssh_dir="/root/.ssh"
        user_home="/root"
        aux_dbg "Configuring for root user" "ssh_dir=$ssh_dir"
    else
        ssh_dir="/home/$user/.ssh"
        user_home="/home/$user"
        aux_dbg "Configuring for regular user" "user=$user,ssh_dir=$ssh_dir"
        
        # Validate user home directory exists
        if ! aux_val "$user_home" "dir_exists"; then
            aux_err "User home directory does not exist" "user=$user,home=$user_home"
            return 2
        fi
    fi

    config_file="$ssh_dir/config"
    local identity_file_line="    IdentityFile $user_home/.ssh/$keyname"

    # Create the .ssh directory if it doesn't exist
    if ! aux_val "$ssh_dir" "dir_exists"; then
        aux_info "Creating SSH directory" "directory=$ssh_dir"
        if ! aux_cmd "mkdir" "-p" "$ssh_dir"; then
            aux_err "Failed to create SSH directory" "directory=$ssh_dir"
            return 2
        fi
        
        # Set proper permissions on .ssh directory
        if ! aux_cmd "chmod" "700" "$ssh_dir"; then
            aux_warn "Failed to set SSH directory permissions" "directory=$ssh_dir"
        fi
        
        # Set proper ownership on .ssh directory (skip for root)
        if [ "$user" != "root" ]; then
            if ! aux_cmd "chown" "$user:$user" "$ssh_dir"; then
                aux_warn "Failed to set SSH directory ownership" "directory=$ssh_dir,user=$user"
            fi
        fi
    fi

    # Validate the SSH key file exists
    local key_file_path="$user_home/.ssh/$keyname"
    if ! aux_val "$key_file_path" "file_exists"; then
        aux_warn "SSH key file does not exist" "path=$key_file_path"
        # Continue anyway as key might be added later
    fi

    aux_dbg "Checking for existing configuration" "config_file=$config_file,identity_line=$identity_file_line"

    # Check if the IdentityFile line already exists
    if [ -f "$config_file" ] && grep -qx "$identity_file_line" "$config_file" 2>/dev/null; then
        aux_info "SSH key configuration already exists" "config_file=$config_file,keyname=$keyname"
        return 0
    fi

    # Append the configuration to the config file
    aux_info "Adding SSH key configuration" "config_file=$config_file,keyname=$keyname"
    
    # Create config file with proper Host * block if it doesn't exist
    if [ ! -f "$config_file" ]; then
        aux_dbg "Creating new SSH config file" "config_file=$config_file"
        if ! echo -e "Host *\n$identity_file_line" > "$config_file"; then
            aux_err "Failed to create SSH config file" "config_file=$config_file"
            return 2
        fi
    else
        aux_dbg "Appending to existing SSH config file" "config_file=$config_file"
        if ! echo -e "\nHost *\n$identity_file_line" >> "$config_file"; then
            aux_err "Failed to append to SSH config file" "config_file=$config_file"
            return 2
        fi
    fi

    # Set the correct permissions on config file
    if ! aux_cmd "chmod" "600" "$config_file"; then
        aux_err "Failed to set SSH config file permissions" "config_file=$config_file"
        return 2
    fi
    
    # Set proper ownership on config file (skip for root)
    if [ "$user" != "root" ]; then
        if ! aux_cmd "chown" "$user:$user" "$config_file"; then
            aux_err "Failed to set SSH config file ownership" "config_file=$config_file,user=$user"
            return 2
        fi
    fi

    aux_info "SSH key configuration completed successfully" "config_file=$config_file,keyname=$keyname"
}


# Generates an SSH key pair and handles the transfer process
# ssh key swap
# <mode> <remote_address> <key_name> [encryption_type]
ssh_sks() {
    # Technical Description:
    #   Generates SSH key pairs with flexible client-server distribution options.
    #   Client-side generation (-c) creates keys locally and transfers public key to server.
    #   Server-side generation (-s) creates keys on server and transfers private key to client.
    #   Supports multiple encryption types with ed25519 as secure default.
    #   Optional deduplication (-d) removes original key after successful transfer.
    #   Handles secure key transfer via SCP with proper error checking.
    #   Sets appropriate permissions and handles directory creation automatically.
    # Dependencies:
    #   - ssh-keygen command for key generation
    #   - scp command for secure file transfer
    #   - ssh command for remote operations
    #   - mkdir command for directory creation
    #   - rm command for deduplication
    #   - chmod command for permission setting
    #   - Network connectivity to remote host
    #   - SSH access to remote host
    # Arguments:
    #   $1: mode - operation mode (-c for client-side, -s for server-side)
    #   $2: remote_address - target host in format [user@]hostname[:port]
    #   $3: key_name - name for the generated key files
    #   $4: encryption_type - key algorithm (ed25519, rsa, dsa, ecdsa) [optional, default: ed25519]
    #   Additional flags: -d for deduplication (removes original after transfer)
    # Returns:
    #   0 on success, 1 on parameter validation failure or operation errors
    # Examples:
    #   ssh_sks "-c" "root@192.168.1.100" "lab_key" "ed25519"
    #   ssh_sks "-s" "-d" "user@server.com" "work_key" "rsa"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    local mode=""
    local deduplicate=false
    local remote_address=""
    local key_name=""
    local encryption_type="ed25519"  # Default to ed25519
    local ssh_dir="/root/.ssh"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|-s) mode="$1" ;;
            -d) deduplicate=true ;;
            *)
                if [[ -z "$remote_address" ]]; then
                    remote_address="$1"
                elif [[ -z "$key_name" ]]; then
                    key_name="$1"
                else
                    encryption_type="$1"
                fi
                ;;
        esac
        shift
    done

    # Check if required arguments are provided
    if [[ -z "$mode" || -z "$remote_address" || -z "$key_name" ]]; then
        aux_use
        return 1
    fi

    # Function to generate SSH key
    generate_key() {
        local key_path="$1"
        case "$encryption_type" in
            rsa)
                ssh-keygen -t rsa -b 4096 -f "$key_path" -N ""
                ;;
            dsa)
                ssh-keygen -t dsa -f "$key_path" -N ""
                ;;
            ecdsa)
                ssh-keygen -t ecdsa -b 521 -f "$key_path" -N ""
                ;;
            ed25519|*)
                ssh-keygen -t ed25519 -f "$key_path" -N ""
                ;;
        esac
    }

    case "$mode" in
        -s) # Server-side generation
            mkdir -p "$ssh_dir"
            chmod 700 "$ssh_dir"
            generate_key "$ssh_dir/$key_name"
            if [ $? -ne 0 ]; then
                aux_err "SSH key pair generation failed" "component=ssh,operation=key_generation,location=server,key_type=$encryption_type"
                return 1
            fi
            aux_info "SSH key pair generated on server" "component=ssh,operation=key_generation,encryption_type=$encryption_type,location=server"
            aux_info "Transferring private key to client" "component=ssh,operation=key_transfer,direction=server_to_client,key_type=private"
            scp "$ssh_dir/$key_name" "${remote_address}:~/.ssh/"
            if [ $? -ne 0 ]; then
                aux_err "Private key transfer to client failed" "component=ssh,operation=key_transfer,remote_address=$remote_address"
                return 1
            fi
            aux_info "Private key transferred to client successfully" "component=ssh,operation=key_transfer,remote_address=$remote_address,status=success"
            if $deduplicate; then
                rm "$ssh_dir/$key_name"
                aux_info "Private key removed from server" "component=ssh,operation=deduplication,key_type=private,reason=cleanup"
            fi
            aux_info "Public key file location" "component=ssh,operation=key_generation,file_path=$ssh_dir/${key_name}.pub,key_type=public"
            ;;
        -c) # Client-side generation
            generate_key "$HOME/.ssh/$key_name"
            if [ $? -ne 0 ]; then
                aux_err "SSH key pair generation failed" "component=ssh,operation=key_generation,location=client,key_type=$encryption_type"
                return 1
            fi
            aux_info "SSH key pair generated on client" "component=ssh,operation=key_generation,encryption_type=$encryption_type,location=client"
            aux_info "Transferring public key to server" "component=ssh,operation=key_transfer,direction=client_to_server,key_type=public"
            scp "$HOME/.ssh/${key_name}.pub" "${remote_address}:/tmp/"
            if [ $? -ne 0 ]; then
                aux_err "Public key transfer to server failed" "component=ssh,operation=key_transfer,remote_address=$remote_address"
                return 1
            fi
            ssh "$remote_address" "mkdir -p $ssh_dir && mv /tmp/${key_name}.pub $ssh_dir/"
            if [ $? -ne 0 ]; then
                aux_err "Failed to move public key on server" "component=ssh,operation=key_placement,remote_address=$remote_address"
                return 1
            fi
            aux_info "Public key transferred and saved on server" "component=ssh,operation=key_transfer,file_path=$ssh_dir/${key_name}.pub,status=success"
            aux_info "Private key file location on client" "component=ssh,operation=key_generation,file_path=$HOME/.ssh/$key_name,key_type=private"

            if $deduplicate; then
                rm "$HOME/.ssh/${key_name}.pub"
                aux_info "Public key removed from client" "component=ssh,operation=deduplication,key_type=public,reason=cleanup"
            fi
            ;;
        *)
            aux_err "Invalid mode specified for SSH key generation" "component=ssh,operation=key_generation,mode=$mode,valid_modes=-s,-c"
            return 1
            ;;
    esac
    aux_info "SSH key generation and transfer completed successfully" "component=ssh,operation=key_generation,mode=$mode,remote_address=$remote_address,key_name=$key_name"
}


# Appends the content of a specified public SSH key file to the authorized_keys file.
# ssh append key
# <mode> <remote_address> <key_name>
ssh_sak() {
    # Technical Description:
    #   Manages authorized_keys file updates for SSH key-based authentication.
    #   Client-side operation (-c) transfers local public key to remote authorized_keys.
    #   Server-side operation (-s) appends local public key to local authorized_keys.
    #   Creates .ssh directory structure if missing with proper permissions.
    #   Sets secure permissions (600) on authorized_keys file for security compliance.
    #   Restarts SSH service after key addition to ensure configuration reload.
    #   Validates key file existence before attempting operations.
    # Dependencies:
    #   - ssh command for remote operations
    #   - cat command for file content operations
    #   - mkdir command for directory creation
    #   - chmod command for permission setting
    #   - systemctl command for service management
    #   - File system access to SSH directories
    #   - Network connectivity for client-side operations
    # Arguments:
    #   $1: mode - operation mode (-c for client-side, -s for server-side)
    #   $2: remote_address - target host in format [user@]hostname[:port] (for client mode)
    #   $3: key_name - name of the SSH key file (without .pub extension)
    # Returns:
    #   0 on success, 1 on parameter validation failure or operation errors
    # Examples:
    #   ssh_sak "-c" "root@192.168.1.100" "id_ed25519"
    #   ssh_sak "-s" "localhost" "lab_key"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    local mode="$1"
    local remote_address="$2"
    local key_name="$3"
    local ssh_dir="/root/.ssh"
    local authorized_keys_path="$ssh_dir/authorized_keys"
    case "$mode" in
        -c) # Client-side operation
            local public_key_path="$HOME/.ssh/${key_name}.pub"
            # Check if the public key exists
            if [ ! -f "$public_key_path" ]; then
                aux_err "Public key file not found" "component=ssh,operation=key_append,key_path=$public_key_path,location=client"
                return 1
            fi
            # Transfer and append the public key on the server
            ssh "$remote_address" "mkdir -p $ssh_dir && cat >> $authorized_keys_path" < "$public_key_path"
            if [ $? -ne 0 ]; then
                aux_err "Failed to append public key to authorized_keys on server" "component=ssh,operation=key_append,remote_address=$remote_address"
                return 1
            fi
            aux_info "Public key appended to authorized_keys on server" "component=ssh,operation=key_append,remote_address=$remote_address,status=success"
            ;;
        -s) # Server-side operation
            local public_key_path="$ssh_dir/${key_name}.pub"
            # Check if the public key exists
            if [ ! -f "$public_key_path" ]; then
                aux_err "Public key file not found on server" "component=ssh,operation=key_append,key_path=$public_key_path,location=server"
                return 1
            fi
            # Append the public key to authorized_keys
            cat "$public_key_path" >> "$authorized_keys_path"
            if [ $? -ne 0 ]; then
                aux_err "Failed to append public key to authorized_keys" "component=ssh,operation=key_append,authorized_keys_path=$authorized_keys_path"
                return 1
            fi
            aux_info "Public key appended to authorized_keys on server" "component=ssh,operation=key_append,authorized_keys_path=$authorized_keys_path,status=success"
            ;;
        *)
            aux_err "Invalid mode specified for SSH key append" "component=ssh,operation=key_append,mode=$mode,valid_modes=-c,-s"
            return 1
            ;;
    esac
    # Ensure correct permissions
    chmod 600 "$authorized_keys_path"
    # Restart SSH service
    aux_info "Restarting SSH service" "component=ssh,operation=service_restart"
    if systemctl restart sshd; then
        aux_info "SSH service restarted successfully" "component=ssh,operation=service_restart,status=success"
    else
        aux_err "Failed to restart SSH service" "component=ssh,operation=service_restart,status=failed"
        return 1
    fi
    aux_info "SSH key append operation completed successfully" "component=ssh,operation=key_append,remote_address=$remote_address,key_name=$key_name"
}

# Loops a specified SSH operation (bypass StrictHostKeyChecking or refresh known_hosts) through a range of IPs defined in the configuration
# loop operation ip
# <ip_array> <operation>
ssh_loi() {
    # Technical Description:
    #   Performs batch SSH operations across IP ranges defined in configuration arrays.
    #   Bypass operation performs initial SSH login to accept host keys automatically.
    #   Refresh operation removes SSH host keys from known_hosts for clean reconnections.
    #   Dynamically resolves IP array names using uppercase convention with _IPS suffix.
    #   Iterates through all IPs in specified array and performs operation with error handling.
    #   Uses auxiliary functions for proper validation, logging, and safe command execution.
    # Dependencies:
    #   - ssh command with StrictHostKeyChecking option
    #   - ssh-keygen command for known_hosts management
    #   - declare command with nameref support
    #   - aux_val for parameter validation
    #   - aux_chk for dependency checking
    #   - aux_cmd for safe command execution
    #   - aux_info, aux_warn, aux_err for logging
    #   - Configuration arrays with proper naming convention
    #   - Network connectivity to target hosts
    # Arguments:
    #   $1: ip_array - IP array identifier (e.g., 'hy', 'ct') resolves to HY_IPS, CT_IPS
    #   $2: operation - operation type ('bypass' for host key acceptance, 'refresh' for known_hosts cleanup)
    # Returns:
    #   0 on success, 1 on parameter validation failure or invalid array/operation
    # Examples:
    #   ssh_loi "hy" "bypass"
    #   ssh_loi "ct" "refresh"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "IP array identifier cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Operation type cannot be empty"
        aux_use
        return 1
    fi
    
    # Validate operation type
    if [[ "$2" != "bypass" && "$2" != "refresh" ]]; then
        aux_err "Invalid operation type" "operation=$2,valid_operations=bypass,refresh"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh"; then
        aux_err "ssh command not found - required for SSH operations"
        return 127
    fi
    
    if [[ "$2" == "refresh" ]] && ! aux_chk "command" "ssh-keygen"; then
        aux_err "ssh-keygen command not found - required for known_hosts management"
        return 127
    fi
    
    local ip_type=$1
    local operation=$2
    local ip_array_name="${ip_type^^}_IPS"

    aux_info "Starting SSH loop operation" "ip_array=$ip_array_name,operation=$operation"

    # Ensure the array exists
    if ! declare -p "$ip_array_name" >/dev/null 2>&1; then
        aux_err "Invalid IP array identifier" "ip_type=$ip_type,expected_array=$ip_array_name"
        return 1
    fi

    # Get the associative array
    declare -n IP_ARRAY="$ip_array_name"
    
    local total_ips=${#IP_ARRAY[@]}
    local processed_ips=0
    local successful_ops=0
    local failed_ops=0

    aux_info "Processing IP array" "array=$ip_array_name,total_ips=$total_ips,operation=$operation"

    for KEY in "${!IP_ARRAY[@]}"; do
        IP=${IP_ARRAY[$KEY]}
        ((processed_ips++))

        if ! aux_val "$IP" "not_empty"; then
            aux_warn "Empty IP address found" "key=$KEY,array=$ip_array_name"
            ((failed_ops++))
            continue
        fi

        aux_dbg "Processing IP" "key=$KEY,ip=$IP,progress=$processed_ips/$total_ips"

        case "$operation" in
            "bypass")
                aux_info "Bypassing StrictHostKeyChecking" "ip=$IP,key=$KEY"
                if aux_cmd "ssh" "-o" "StrictHostKeyChecking=no" "-o" "ConnectTimeout=10" "root@$IP" "exit"; then
                    aux_info "SSH bypass successful" "ip=$IP,key=$KEY"
                    ((successful_ops++))
                else
                    aux_err "SSH bypass failed" "ip=$IP,key=$KEY"
                    ((failed_ops++))
                fi
                ;;
            "refresh")
                aux_info "Removing SSH key from known_hosts" "ip=$IP,key=$KEY"
                if aux_cmd "ssh-keygen" "-R" "$IP"; then
                    aux_info "SSH key removal successful" "ip=$IP,key=$KEY"
                    ((successful_ops++))
                else
                    aux_err "SSH key removal failed" "ip=$IP,key=$KEY"
                    ((failed_ops++))
                fi
                ;;
        esac
    done

    aux_info "SSH loop operation completed" "array=$ip_array_name,operation=$operation,total=$total_ips,successful=$successful_ops,failed=$failed_ops"
    
    # Return success if at least some operations succeeded
    if [[ $successful_ops -gt 0 ]]; then
        return 0
    else
        aux_err "All SSH operations failed" "operation=$operation,failed_count=$failed_ops"
        return 2
    fi
}