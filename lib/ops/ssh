# filepath: /home/es/lab/lib/ops/ssh
#!/bin/bash

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Source auxiliary functions library for .std compliance
source "${DIR_FUN}/../gen/aux"

# Displays an overview of SSH-related functions in the script, showing their usage, shortname, and description
# overview functions
# <script_path>
ssh_fun() {
    # Technical Description:
    #   Invokes the 'ana_laf' (list available functions) utility.
    #   Accepts script path as explicit parameter for analysis.
    #   All remaining arguments are forwarded to 'ana_laf'.
    #   Primarily used for introspection of script capabilities.
    # Dependencies:
    #   - 'ana_laf' function from aux module
    #   - LIB_GEN_DIR environment variable
    #   - Read access to script files
    # Arguments:
    #   $1: script_path - path to the script file to analyze
    #   $@: additional arguments forwarded to ana_laf
    # Returns:
    #   Exit status of ana_laf command
    # Examples:
    #   ssh_fun "/path/to/script"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    # Parameter validation using aux_val (optional parameters allowed)
    if [ $# -gt 0 ]; then
        if ! aux_val "$FILEPATH_ssh" "file_exists"; then
            aux_err "SSH script file not found: $FILEPATH_ssh"
            aux_use
            return 1
        fi
    fi
    
    ana_laf "$FILEPATH_ssh" "$@"
}

# Displays an overview of SSH-specific variables defined in the configuration file, showing their names, values, and usage
# overview variables  
# <config_file> <lib_parent_dir>
ssh_var() {
    # Technical Description:
    #   Invokes the 'aux-lav' (list available variables) utility.
    #   Accepts config file path and library parent directory as explicit parameters.
    #   Searches for SSH-related variables and displays their definitions.
    # Dependencies:
    #   - 'aux-lav' function from aux module
    #   - LIB_GEN_DIR environment variable
    #   - Read access to configuration files
    # Arguments:
    #   $1: config_file - path to configuration file to analyze
    #   $2: lib_parent_dir - parent directory of libraries for context
    # Returns:
    #   Exit status of aux-lav command
    # Examples:
    #   ssh_var "/path/to/config" "/path/to/lib/.."
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Config file path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Library parent directory cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$1" "file_exists"; then
        aux_err "Config file not found: $1"
        return 2
    fi
    
    if ! aux_val "$2" "dir_exists"; then
        aux_err "Library parent directory not found: $2"
        return 2
    fi
    
    local config_file="$1"
    local lib_parent_dir="$2"
    source "${LIB_GEN_DIR}/aux"
    aux-lav "$config_file" "$lib_parent_dir" "ssh"
}

# Adds SSH keys to the SSH agent for authentication, supporting multiple key types and paths
# add ssh keys
# <key_paths_array[@]>
ssh_key() {
    # Technical Description:
    #   Loads specified SSH keys into the SSH agent if not already loaded.
    #   Starts SSH agent if not running. Validates key existence before loading.
    #   Uses ssh-keygen fingerprint comparison to avoid duplicate key loading.
    #   Processes array reference to handle multiple keys efficiently.
    # Dependencies:
    #   - ssh-add command for key management
    #   - ssh-agent command for agent management
    #   - ssh-keygen command for fingerprint generation
    #   - awk for fingerprint extraction
    # Arguments:
    #   $1: key_paths_array[@] - nameref to array of SSH key file paths to load
    # Returns:
    #   0 on success, non-zero on failure
    # Examples:
    #   ssh_key "SSH_KEY_PATHS"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Array name cannot be empty"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for SSH key management"
        return 127
    fi
    
    if ! aux_chk "command" "ssh-agent"; then
        aux_err "ssh-agent command not found - required for SSH agent management"
        return 127
    fi
    
    if ! aux_chk "command" "ssh-keygen"; then
        aux_err "ssh-keygen command not found - required for fingerprint generation"
        return 127
    fi
    
    if ! aux_chk "command" "awk"; then
        aux_err "awk command not found - required for fingerprint extraction"
        return 127
    fi
    
    local -n key_paths_ref=$1
    
    aux_info "Adding SSH keys to the agent" "array_name=$1"
    
    # Start SSH agent if not running
    if [ -z "$SSH_AUTH_SOCK" ]; then
        aux_info "Starting ssh-agent"
        if ! eval "$(ssh-agent -s)" > /dev/null; then
            aux_err "Failed to start ssh-agent"
            return 2
        fi
        aux_info "SSH agent started successfully"
    fi
    
    # Load each key if not already loaded
    for key in "${key_paths_ref[@]}"; do
        aux_info "Processing SSH key" "key_path=$key"
        
        if ! aux_val "$key" "file_exists"; then
            aux_warn "SSH key file not found" "key_path=$key"
            continue
        fi
        
        # Check if key is already loaded using fingerprint comparison
        local key_fingerprint
        key_fingerprint=$(ssh-keygen -lf "$key" 2>/dev/null | awk '{print $2}')
        
        if [[ -n "$key_fingerprint" ]] && ! ssh-add -l 2>/dev/null | grep -q "$key_fingerprint"; then
            if ssh-add "$key"; then
                aux_info "SSH key added successfully" "key_path=$key,fingerprint=$key_fingerprint"
            else
                aux_err "Failed to add SSH key" "key_path=$key"
            fi
        else
            aux_info "SSH key already loaded or invalid" "key_path=$key"
        fi
    done
    
    aux_info "SSH keys processing completed" "array_name=$1"
}

# Lists SSH keys currently loaded in the agent with detailed information
# list ssh keys
# -x (execute)
ssh_lst() {
    # Technical Description:
    #   Displays all SSH keys currently loaded in the SSH agent.
    #   Shows key fingerprints, types, and associated files.
    #   Provides clear status when no keys are loaded or agent is not running.
    # Dependencies:
    #   - ssh-add command for listing keys
    #   - Running SSH agent with SSH_AUTH_SOCK set
    # Arguments:
    #   $1: -x - explicit execution flag required for consistency
    # Returns:
    #   0 if keys found, 1 if no keys or agent not running
    # Examples:
    #   ssh_lst -x
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for listing SSH keys"
        return 127
    fi
    
    aux_info "Listing SSH keys in the agent"
    
    if ssh-add -l; then
        aux_info "SSH keys listed successfully"
        return 0
    else
        aux_warn "No SSH keys found or ssh-agent is not running"
        return 1
    fi
}

# Removes all SSH keys from the agent for security cleanup
# remove ssh keys
# -x (execute)
ssh_rmv() {
    # Technical Description:
    #   Removes all SSH keys from the SSH agent for security purposes.
    #   Useful for cleanup or when switching between different key sets.
    #   Provides clear feedback on operation success or failure.
    # Dependencies:
    #   - ssh-add command for key removal
    #   - Running SSH agent with loaded keys
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    # Returns:
    #   0 on success, 1 on failure
    # Examples:
    #   ssh_rmv -x
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for SSH key removal"
        return 127
    fi
    
    aux_info "Removing all SSH keys from the agent"
    
    if ssh-add -D; then
        aux_info "All SSH keys removed successfully from agent"
        return 0
    else
        aux_err "Failed to remove SSH keys from agent"
        return 2
    fi
}

# Generates new SSH keys with specified type and comment
# generate ssh key
# <key_type> <comment> [output_path]
ssh_gen() {
    # Technical Description:
    #   Creates new SSH key pair using specified algorithm and comment.
    #   Supports ed25519 (recommended) and rsa key types with appropriate parameters.
    #   Sets default output path if not specified, creates directory structure if needed.
    #   Provides comprehensive logging throughout the generation process.
    # Dependencies:
    #   - ssh-keygen command for key generation
    #   - log function for status reporting
    #   - Write permissions to output directory
    #   - HOME environment variable for default paths
    # Arguments:
    #   $1: key_type - type of key to generate (ed25519, rsa)
    #   $2: comment - comment to embed in the key for identification
    #   $3: output_path - path where to save the key (optional, defaults to ~/.ssh/id_<type>)
    # Returns:
    #   0 on success, non-zero on failure
    # Examples:
    #   ssh_gen "ed25519" "user@lab" "/root/.ssh/id_ed25519"
    #   ssh_gen "rsa" "user@lab"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -lt 2 ] || [ $# -gt 3 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Key type cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Comment cannot be empty"
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-keygen"; then
        aux_err "ssh-keygen command not found - required for SSH key generation"
        return 127
    fi
    
    local key_type="$1"
    local comment="$2"
    local output_path="$3"
    
    # Set default output path if not specified
    if [[ -z "$output_path" ]]; then
        output_path="$HOME/.ssh/id_${key_type}"
    fi
    
    aux_info "Generating SSH key" "type=$key_type,comment=$comment,path=$output_path"
    
    case "$key_type" in
        ed25519)
            ssh-keygen -t ed25519 -C "$comment" -f "$output_path" || {
                aux_err "Failed to generate ed25519 key" "path=$output_path"
                return 1
            }
            ;;
        rsa)
            ssh-keygen -t rsa -b 4096 -C "$comment" -f "$output_path" || {
                aux_err "Failed to generate RSA key" "path=$output_path"
                return 1
            }
            ;;
        *)
            aux_err "Unsupported key type" "type=$key_type"
            return 1
            ;;
    esac
    
    aux_info "SSH key generated successfully" "path=$output_path,type=$key_type"
}

# Copies SSH public key to remote host for passwordless authentication
# copy ssh key
# <public_key_path> <target_host>
ssh_cpy() {
    # Technical Description:
    #   Copies SSH public key to remote host's authorized_keys file.
    #   Enables passwordless SSH authentication to the target host.
    #   Validates key file existence before attempting copy operation.
    #   Uses ssh-copy-id for secure and proper key installation.
    # Dependencies:
    #   - ssh-copy-id command for secure key copying
    #   - log function for status reporting
    #   - Network connectivity to target host
    #   - SSH access to target host (may require password)
    # Arguments:
    #   $1: public_key_path - absolute path to the public key file
    #   $2: target_host - target host in format [user@]hostname[:port]
    # Returns:
    #   0 on success, non-zero on failure
    # Examples:
    #   ssh_cpy "/root/.ssh/id_ed25519.pub" "root@192.168.1.100"
    #   ssh_cpy "/root/.ssh/id_rsa.pub" "user@example.com"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    # Parameter validation using aux_val
    if ! aux_val "$1" "not_empty"; then
        aux_err "Public key path cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$2" "not_empty"; then
        aux_err "Target host cannot be empty"
        aux_use
        return 1
    fi
    
    if ! aux_val "$1" "file_exists"; then
        aux_err "Public key file not found" "path=$1"
        return 2
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-copy-id"; then
        aux_err "ssh-copy-id command not found - required for SSH key copying"
        return 127
    fi
    
    local public_key_path="$1"
    local target_host="$2"
    
    aux_info "Copying SSH key to host" "key_path=$public_key_path,target=$target_host"
    
    if ssh-copy-id -i "$public_key_path" "$target_host"; then
        aux_info "SSH key copied successfully" "target=$target_host"
        return 0
    else
        aux_err "Failed to copy SSH key" "target=$target_host"
        return 2
    fi
}

# Starts SSH agent and ensures it's running for key management
# start ssh agent
# -x (execute)
ssh_agt() {
    # Technical Description:
    #   Starts SSH agent if not already running and exports environment variables.
    #   Ensures SSH_AUTH_SOCK and SSH_AGENT_PID are properly set.
    #   Checks for existing agent before starting new one to avoid conflicts.
    #   Provides clear feedback on agent status and startup success.
    # Dependencies:
    #   - ssh-agent command for agent management
    #   - ssh-add command for agent testing
    #   - log function for status reporting
    #   - eval for environment variable setting
    # Arguments:
    #   $1: -x - explicit execution flag required for safety and consistency
    # Returns:
    #   0 if agent started or already running, 1 on failure
    # Examples:
    #   ssh_agt -x
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 1 ] || [ "$1" != "-x" ]; then
        aux_use
        return 1
    fi
    
    # Dependency checks using aux_chk
    if ! aux_chk "command" "ssh-agent"; then
        aux_err "ssh-agent command not found - required for SSH agent management"
        return 127
    fi
    
    if ! aux_chk "command" "ssh-add"; then
        aux_err "ssh-add command not found - required for SSH agent testing"
        return 127
    fi
    
    if [ -n "$SSH_AUTH_SOCK" ] && ssh-add -l >/dev/null 2>&1; then
        aux_info "SSH agent is already running" "auth_sock=$SSH_AUTH_SOCK"
        return 0
    fi
    
    aux_info "Starting SSH agent"
    
    if eval "$(ssh-agent -s)"; then
        aux_info "SSH agent started successfully" "auth_sock=$SSH_AUTH_SOCK,pid=$SSH_AGENT_PID"
        return 0
    else
        aux_err "Failed to start ssh-agent"
        return 2
    fi
}

# Resolves custom SSH aliases using the configuration file. Supports connecting to single or multiple servers, executing commands remotely
# ssh custom aliases
# <usershortcut> <servershortcut> <ssh_users_array_name> <all_ip_arrays_array_name> <array_aliases_array_name> [command]
ssh_sca() {
    # Technical Description:
    #   Resolves user and server shortcuts from configuration arrays using nameref declarations.
    #   Supports single server, multiple servers, or entire arrays for batch operations.
    #   Can execute commands remotely on multiple servers with proper error handling.
    #   Uses dynamic array access for flexible configuration management.
    #   Handles 'all' keyword for operations across all server arrays.
    #   Provides comprehensive debugging output for troubleshooting connections.
    # Dependencies:
    #   - ssh command for remote connections
    #   - declare with nameref support for dynamic array access
    #   - eval for command execution
    #   - Array variables passed by name for configuration
    # Arguments:
    #   $1: usershortcut - shortcut key for user lookup in ssh_users_array
    #   $2: servershortcut - shortcut key(s) for server lookup, supports comma-separated values
    #   $3: ssh_users_array_name - name of associative array containing user mappings
    #   $4: all_ip_arrays_array_name - name of array containing all IP array names
    #   $5: array_aliases_array_name - name of associative array containing array aliases
    #   $6+: command - optional command to execute on remote server(s)
    # Returns:
    #   0 on success, 1 on parameter validation failure or connection errors
    # Examples:
    #   ssh_sca "r" "web1" "SSH_USERS" "ALL_IP_ARRAYS" "ARRAY_ALIASES"
    #   ssh_sca "r" "web1,web2" "SSH_USERS" "ALL_IP_ARRAYS" "ARRAY_ALIASES" "uptime"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -lt 5 ]; then
        aux_use
        return 1
    fi
    
    echo "Debug: Number of arguments: $#"
    echo "Debug: All arguments: $*"

    local user_shortcut=$1
    local server_shortcuts=$2
    local ssh_users_array_name=$3
    local all_ip_arrays_name=$4
    local array_aliases_name=$5
    shift 5
    local command="$*"

    # Declare namerefs to the passed associative array names
    declare -n _ssh_users_ref="$ssh_users_array_name"
    declare -n _all_ip_arrays_ref="$all_ip_arrays_name"
    declare -n _array_aliases_ref="$array_aliases_name"

    echo "Debug: User shortcut: $user_shortcut"

    # Resolve user name from shortcut
    local user_name="${_ssh_users_ref[$user_shortcut]}"
    echo "Debug: Resolved user name: $user_name"

    if [[ -z $user_name ]]; then
        echo "Error: Unknown user shortcut '$user_shortcut'"
        echo "Debug: SSH _ USERS (passed name: $ssh_users_array_name) array contents: ${_ssh_users_ref[@]}"
        echo "Debug: SSH _ USERS (passed name: $ssh_users_array_name) keys: ${!_ssh_users_ref[@]}"
        return 1
    fi

    echo "Debug: Server shortcuts (raw): $server_shortcuts"
    echo "Debug: ALL_IP_ARRAYS (passed name: $all_ip_arrays_name): ${_all_ip_arrays_ref[*]}"

    # Function to handle an array of servers
    handle_server_array() {
        local array_name=$1
        declare -n server_array=$array_name # This correctly refers to an individual IP array by its name
        echo "Debug: Processing array: $array_name"
        echo "Debug: Array contents: ${!server_array[*]}"
        for server_shortcut in "${!server_array[@]}"; do
            local server_ip=${server_array[$server_shortcut]}
            echo "Debug: Resolved server IP for $server_shortcut: $server_ip"
            # Construct the SSH command
            local ssh_command="ssh ${user_name}@${server_ip}"
            if [[ -n $command ]]; then
                ssh_command+=" \"$command\""
            fi
            # Execute the SSH command
            echo "Executing: $ssh_command"
            eval $ssh_command
        done
    }

    # Function to normalize server shortcuts
    normalize_shortcut() {
        local input=$1
        local normalized=$input

        # Check if input matches any array name or alias (case-insensitive)
        for array in "${!_array_aliases_ref[@]}"; do
            local aliases=(${_array_aliases_ref[$array]})
            for alias in "${aliases[@]}"; do
                if [[ ${input,,} == ${alias,,} ]]; then
                    normalized=$array
                    echo "Debug: Match found, normalized '$input' to '$normalized'" >&2
                    break 2
                fi
            done
        done

        echo "Debug: Normalized '$input' to '$normalized'" >&2
        echo "$normalized"
    }

    # Function to find server IP
    find_server_ip() {
        local shortcut=$1
        local ip=""
        local array_name_found="" # Renamed to avoid conflict with outer scope 'array_name' if any
        for current_array_name in "${_all_ip_arrays_ref[@]}"; do # Iterate over names in _all_ip_arrays_ref
            echo "Debug: Searching for '$shortcut' in '$current_array_name'" >&2
            declare -n current_array_ref=$current_array_name # Nameref to the actual IP array
            echo "Debug: $current_array_name contents: ${!current_array_ref[*]}" >&2
            if [[ -n ${current_array_ref[$shortcut]} ]]; then
                ip=${current_array_ref[$shortcut]}
                array_name_found=$current_array_name
                echo "Debug: Found '$shortcut' in '$current_array_name'" >&2
                break
            fi
        done
        echo "Debug: Found IP for $shortcut: $ip (from $array_name_found)" >&2
        echo "$ip"
    }

    # Function to check if input is an array name
    is_array_name() {
        local input=$1
        echo "Debug: Checking if '$input' is an array name" >&2
        if [[ $input == "all" ]]; then
            echo "Debug: '$input' is 'all'" >&2
            return 0
        fi
        for array_iter_name in "${_all_ip_arrays_ref[@]}"; do # Iterate over names in _all_ip_arrays_ref
            if [[ $input == $array_iter_name ]]; then
                echo "Debug: '$input' matches array '$array_iter_name'" >&2
                return 0
            fi
        done
        echo "Debug: '$input' is not an array name" >&2
        return 1
    }

    # Normalize the server shortcuts
    local normalized_shortcuts=$(normalize_shortcut "$server_shortcuts")
    echo "Debug: Normalized server shortcuts: $normalized_shortcuts"

    # Handle server_shortcuts
    if is_array_name "$normalized_shortcuts"; then
        echo "Debug: Processing as array name"
        if [[ $normalized_shortcuts == "all" ]]; then
            echo "Debug: Processing all servers"
            for array_to_handle in "${_all_ip_arrays_ref[@]}"; do # Iterate over names in _all_ip_arrays_ref
                handle_server_array $array_to_handle
            done
        else
            echo "Debug: Processing specific IP array: $normalized_shortcuts"
            handle_server_array $normalized_shortcuts
        fi
    else
        echo "Debug: Processing as individual server(s)"
        IFS=',' read -ra servers <<< "$normalized_shortcuts"
        if [[ ${#servers[@]} -gt 1 && -z $command ]]; then
            echo "Error: No command provided for multiple servers"
            return 1
        fi
        for server_shortcut_iter in "${servers[@]}"; do
            local server_ip=$(find_server_ip "$server_shortcut_iter")
            if [[ -z $server_ip ]]; then
                echo "Error: Unknown server shortcut '$server_shortcut_iter'"
                return 1
            fi
            local ssh_command="ssh ${user_name}@${server_ip}"
            if [[ -n $command ]]; then
                ssh_command+=" \"$command\""
            fi
            echo "Executing: $ssh_command"
            eval $ssh_command
        done
    fi
    echo "Debug: Raw command: $command"
}

# Uploads an SSH key from a plugged-in device to a specified folder (default: /root/.ssh). Handles mounting, file copying, and unmounting of the device
# ssh upload keyfile
# <device_path> <mount_point> <subfolder_path> <upload_path> <file_name>
ssh_suk() {
    # Technical Description:
    #   Mounts external device at specified mount point and copies SSH key files.
    #   Creates mount point directory if it doesn't exist for seamless operation.
    #   Copies SSH key from device subfolder to target location with validation.
    #   Safely unmounts device after operation to prevent data corruption.
    #   Validates all required parameters before proceeding.
    #   Displays system information (lsblk, /mnt contents) for user guidance.
    # Dependencies:
    #   - mount/umount commands for device management
    #   - cp command for file copying
    #   - mkdir command for directory creation
    #   - lsblk command for device listing
    #   - ls command for directory listing
    #   - Device must be properly formatted and accessible
    # Arguments:
    #   $1: device_path - path to the device (e.g., /dev/sdb1)
    #   $2: mount_point - directory where device will be mounted
    #   $3: subfolder_path - path within the mounted device to the key file
    #   $4: upload_path - destination directory for the key file
    #   $5: file_name - name of the key file to copy
    # Returns:
    #   0 on success, 1 on mount, copy, or unmount failure
    # Examples:
    #   ssh_suk "/dev/sdb1" "/mnt/usb" "ssh_keys" "/root/.ssh" "id_ed25519"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 5 ]; then
        aux_use
        return 1
    fi
    
    local device_path="$1"
    local mount_point="$2"
    local subfolder_path="$3"
    local upload_path="$4"
    local file_name="$5"

    local full_path
    local upload_full_path

    echo ""
    lsblk
    echo ""
    echo "ls /mnt output :"
    ls /mnt
    echo ""

    # Evaluate and confirm variables
    full_path="$mount_point/$subfolder_path/$file_name"
    upload_full_path="$upload_path/$file_name"

    # Check if mount point exists
    if [ ! -d "$mount_point" ]; then
        echo "Mount Point $mount_point will be created."
	mkdir -p $mount_point
    fi

    # Mount the device
    mount $device_path $mount_point

    # Check if mount was successful
    if [ $? -ne 0 ]; then
        echo "Failed to mount $device_path at $mount_point"
        return 1
    fi

    # Copy the SSH key to the upload path
    cp $full_path $upload_full_path

    # Check if copy was successful
    if [ $? -ne 0 ]; then
        echo "Failed to copy $full_path to $upload_path"
        umount $mount_point
        return 1
    fi

    # Unmount the device
    umount $mount_point

    echo "SSH key successfully uploaded to $upload_path"
}


# Appends a private SSH key identifier to the SSH config file for a specified user. Creates the .ssh directory and config file if they don't exist
# ssh private identifier
# <user> <keyname>
ssh_spi() {
    # Technical Description:
    #   Creates .ssh directory structure if missing with proper permissions.
    #   Adds IdentityFile entry to SSH config for specified key with Host * scope.
    #   Handles both root and regular user configurations with appropriate paths.
    #   Sets proper ownership and permissions (600) for security compliance.
    #   Avoids duplicate entries by checking existing config content.
    #   Creates config file with proper structure if it doesn't exist.
    # Dependencies:
    #   - mkdir command for directory creation
    #   - grep command for duplicate detection
    #   - echo command for config file writing
    #   - chown command for ownership setting
    #   - chmod command for permission setting
    #   - Appropriate privileges for user directory access
    # Arguments:
    #   $1: user - username (root or regular user) for configuration
    #   $2: keyname - name of the SSH key file (without path)
    # Returns:
    #   0 on success, 1 on failure or invalid user
    # Examples:
    #   ssh_spi "root" "id_ed25519_lab"
    #   ssh_spi "alice" "id_rsa_work"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local user="$1"
    local keyname="$2"
    local ssh_dir
    local config_file
    local user_home

    if [ "$user" == "root" ]; then
        ssh_dir="/root/.ssh"
        user_home="/root"
    else
        ssh_dir="/home/$user/.ssh"
        user_home="/home/$user"
    fi

    config_file="$ssh_dir/config"

    # Create the .ssh directory if it doesn't exist
    mkdir -p $ssh_dir

    # Define the configuration line to add
    identity_file_line="    IdentityFile $user_home/.ssh/$keyname"

    # Check if the IdentityFile line already exists
    if ! grep -qx "$identity_file_line" "$config_file" 2>/dev/null; then
        # Append the configuration to the config file
        echo -e "\nHost *\n$identity_file_line" >> $config_file

        # Set the correct permissions
        chown $user:$user $config_file
        chmod 600 $config_file

        echo "SSH config file updated at $config_file"
    else
        echo "Configuration already exists in $config_file"
    fi
}


# Generates an SSH key pair and handles the transfer process
# ssh key swap
# <mode> <remote_address> <key_name> [encryption_type]
ssh_sks() {
    # Technical Description:
    #   Generates SSH key pairs with flexible client-server distribution options.
    #   Client-side generation (-c) creates keys locally and transfers public key to server.
    #   Server-side generation (-s) creates keys on server and transfers private key to client.
    #   Supports multiple encryption types with ed25519 as secure default.
    #   Optional deduplication (-d) removes original key after successful transfer.
    #   Handles secure key transfer via SCP with proper error checking.
    #   Sets appropriate permissions and handles directory creation automatically.
    # Dependencies:
    #   - ssh-keygen command for key generation
    #   - scp command for secure file transfer
    #   - ssh command for remote operations
    #   - mkdir command for directory creation
    #   - rm command for deduplication
    #   - chmod command for permission setting
    #   - Network connectivity to remote host
    #   - SSH access to remote host
    # Arguments:
    #   $1: mode - operation mode (-c for client-side, -s for server-side)
    #   $2: remote_address - target host in format [user@]hostname[:port]
    #   $3: key_name - name for the generated key files
    #   $4: encryption_type - key algorithm (ed25519, rsa, dsa, ecdsa) [optional, default: ed25519]
    #   Additional flags: -d for deduplication (removes original after transfer)
    # Returns:
    #   0 on success, 1 on parameter validation failure or operation errors
    # Examples:
    #   ssh_sks "-c" "root@192.168.1.100" "lab_key" "ed25519"
    #   ssh_sks "-s" "-d" "user@server.com" "work_key" "rsa"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    local mode=""
    local deduplicate=false
    local remote_address=""
    local key_name=""
    local encryption_type="ed25519"  # Default to ed25519
    local ssh_dir="/root/.ssh"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|-s) mode="$1" ;;
            -d) deduplicate=true ;;
            *)
                if [[ -z "$remote_address" ]]; then
                    remote_address="$1"
                elif [[ -z "$key_name" ]]; then
                    key_name="$1"
                else
                    encryption_type="$1"
                fi
                ;;
        esac
        shift
    done

    # Check if required arguments are provided
    if [[ -z "$mode" || -z "$remote_address" || -z "$key_name" ]]; then
        aux_use
        return 1
    fi

    # Function to generate SSH key
    generate_key() {
        local key_path="$1"
        case "$encryption_type" in
            rsa)
                ssh-keygen -t rsa -b 4096 -f "$key_path" -N ""
                ;;
            dsa)
                ssh-keygen -t dsa -f "$key_path" -N ""
                ;;
            ecdsa)
                ssh-keygen -t ecdsa -b 521 -f "$key_path" -N ""
                ;;
            ed25519|*)
                ssh-keygen -t ed25519 -f "$key_path" -N ""
                ;;
        esac
    }

    case "$mode" in
        -s) # Server-side generation
            mkdir -p "$ssh_dir"
            chmod 700 "$ssh_dir"
            generate_key "$ssh_dir/$key_name"
            if [ $? -ne 0 ]; then
                echo "Failed to generate SSH key pair."
                return 1
            fi
            echo "SSH key pair generated on server using $encryption_type encryption."
            echo "Transferring private key to client..."
            scp "$ssh_dir/$key_name" "${remote_address}:~/.ssh/"
            if [ $? -ne 0 ]; then
                echo "Failed to transfer private key to client."
                return 1
            fi
            echo "Private key transferred to client successfully."
            if $deduplicate; then
                rm "$ssh_dir/$key_name"
                echo "Private key removed from server (deduplication)."
            fi
            echo "Public key file: $ssh_dir/${key_name}.pub"
            ;;
        -c) # Client-side generation
            generate_key "$HOME/.ssh/$key_name"
            if [ $? -ne 0 ]; then
                echo "Failed to generate SSH key pair."
                return 1
            fi
            echo "SSH key pair generated on client using $encryption_type encryption."
            echo "Transferring public key to server..."
            scp "$HOME/.ssh/${key_name}.pub" "${remote_address}:/tmp/"
            if [ $? -ne 0 ]; then
                echo "Failed to transfer public key to server."
                return 1
            fi
            ssh "$remote_address" "mkdir -p $ssh_dir && mv /tmp/${key_name}.pub $ssh_dir/"
            if [ $? -ne 0 ]; then
                echo "Failed to move public key on server."
                return 1
            fi
            echo "Public key transferred to server and saved in $ssh_dir/${key_name}.pub"
            echo "Private key file on client: $HOME/.ssh/$key_name"

            if $deduplicate; then
                rm "$HOME/.ssh/${key_name}.pub"
                echo "Public key removed from client's .ssh folder (deduplication)."
            fi
            ;;
        *)
            echo "Invalid mode. Use -s for server-side or -c for client-side generation."
            return 1
            ;;
    esac
    echo "SSH key generation and transfer completed successfully."
}


# Appends the content of a specified public SSH key file to the authorized_keys file.
# ssh append key
# <mode> <remote_address> <key_name>
ssh_sak() {
    # Technical Description:
    #   Manages authorized_keys file updates for SSH key-based authentication.
    #   Client-side operation (-c) transfers local public key to remote authorized_keys.
    #   Server-side operation (-s) appends local public key to local authorized_keys.
    #   Creates .ssh directory structure if missing with proper permissions.
    #   Sets secure permissions (600) on authorized_keys file for security compliance.
    #   Restarts SSH service after key addition to ensure configuration reload.
    #   Validates key file existence before attempting operations.
    # Dependencies:
    #   - ssh command for remote operations
    #   - cat command for file content operations
    #   - mkdir command for directory creation
    #   - chmod command for permission setting
    #   - systemctl command for service management
    #   - File system access to SSH directories
    #   - Network connectivity for client-side operations
    # Arguments:
    #   $1: mode - operation mode (-c for client-side, -s for server-side)
    #   $2: remote_address - target host in format [user@]hostname[:port] (for client mode)
    #   $3: key_name - name of the SSH key file (without .pub extension)
    # Returns:
    #   0 on success, 1 on parameter validation failure or operation errors
    # Examples:
    #   ssh_sak "-c" "root@192.168.1.100" "id_ed25519"
    #   ssh_sak "-s" "localhost" "lab_key"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 3 ]; then
        aux_use
        return 1
    fi
    
    local mode="$1"
    local remote_address="$2"
    local key_name="$3"
    local ssh_dir="/root/.ssh"
    local authorized_keys_path="$ssh_dir/authorized_keys"
    case "$mode" in
        -c) # Client-side operation
            local public_key_path="$HOME/.ssh/${key_name}.pub"
            # Check if the public key exists
            if [ ! -f "$public_key_path" ]; then
                echo "Error: Public key '$public_key_path' does not exist."
                return 1
            fi
            # Transfer and append the public key on the server
            ssh "$remote_address" "mkdir -p $ssh_dir && cat >> $authorized_keys_path" < "$public_key_path"
            if [ $? -ne 0 ]; then
                echo "Error: Failed to append public key to authorized_keys on the server."
                return 1
            fi
            echo "Public key appended to authorized_keys on the server."
            ;;
        -s) # Server-side operation
            local public_key_path="$ssh_dir/${key_name}.pub"
            # Check if the public key exists
            if [ ! -f "$public_key_path" ]; then
                echo "Error: Public key '$public_key_path' does not exist on the server."
                return 1
            fi
            # Append the public key to authorized_keys
            cat "$public_key_path" >> "$authorized_keys_path"
            if [ $? -ne 0 ]; then
                echo "Error: Failed to append public key to authorized_keys."
                return 1
            fi
            echo "Public key appended to authorized_keys on the server."
            ;;
        *)
            echo "Invalid mode. Use -c for client-side or -s for server-side operation."
            return 1
            ;;
    esac
    # Ensure correct permissions
    chmod 600 "$authorized_keys_path"
    # Restart SSH service
    echo "Restarting SSH service..."
    if systemctl restart sshd; then
        echo "SSH service restarted successfully."
    else
        echo "Error: Failed to restart SSH service. Please check the service manually."
        return 1
    fi
    echo "SSH key append operation completed successfully."
}

# Loops a specified SSH operation (bypass StrictHostKeyChecking or refresh known_hosts) through a range of IPs defined in the configuration
# loop operation ip
# <ip_array> <operation>
ssh_loi() {
    # Technical Description:
    #   Performs batch SSH operations across IP ranges defined in configuration arrays.
    #   Bypass operation performs initial SSH login to accept host keys automatically.
    #   Refresh operation removes SSH host keys from known_hosts for clean reconnections.
    #   Dynamically resolves IP array names using uppercase convention with _IPS suffix.
    #   Iterates through all IPs in specified array and performs operation with error handling.
    #   Provides detailed feedback for each operation including success/failure status.
    # Dependencies:
    #   - ssh command with StrictHostKeyChecking option
    #   - ssh-keygen command for known_hosts management
    #   - declare command with nameref support
    #   - Configuration arrays with proper naming convention
    #   - Network connectivity to target hosts
    # Arguments:
    #   $1: ip_array - IP array identifier (e.g., 'hy', 'ct') resolves to HY_IPS, CT_IPS
    #   $2: operation - operation type ('bypass' for host key acceptance, 'refresh' for known_hosts cleanup)
    # Returns:
    #   0 on success, 1 on parameter validation failure or invalid array/operation
    # Examples:
    #   ssh_loi "hy" "bypass"
    #   ssh_loi "ct" "refresh"
    
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        aux_tec
        return 0
    fi
    
    if [ $# -ne 2 ]; then
        aux_use
        return 1
    fi
    
    local ip_type=$1
    local operation=$2
    local ip_array_name="${ip_type^^}_IPS"

    # Ensure the array exists
    if ! declare -p "$ip_array_name" >/dev/null 2>&1; then
        echo "Invalid IP type: $ip_type"
        return 1
    fi

    # Get the associative array
    declare -n IP_ARRAY="$ip_array_name"

    for KEY in "${!IP_ARRAY[@]}"; do
        IP=${IP_ARRAY[$KEY]}

        if [ -n "$IP" ]; then
            if [ "$operation" == "bypass" ]; then
                echo "Performing SSH login to bypass StrictHostKeyChecking for $IP"
                ssh -o StrictHostKeyChecking=no root@"$IP" "exit"
                if [ $? -ne 0 ]; then
                    echo "Failed to SSH into $IP"
                fi
            elif [ "$operation" == "refresh" ]; then
                echo "Removing SSH key for $IP from known_hosts"
                ssh-keygen -R "$IP"
                if [ $? -ne 0 ]; then
                    echo "Failed to remove SSH key for $IP"
                fi
            else
                echo "Invalid operation: $operation"
                return 1
            fi
        else
            echo "IP is empty for key $KEY"
        fi
    done
}