#!/bin/bash

# ============================================================================
# aux/src - Function Summary
#
#   aux-fun      : Shows a summary of selected functions in the script, displaying their usage, shortname, and description.
#   aux-var      : Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files.
#   aux-log      : Logging function. Prints a timestamped log message with a log level.
#   aux-ffl      : Recursively processes files in a directory and its subdirectories using a specified function, allowing for additional arguments to be passed.
#   aux-laf      : Lists all functions in a file, displaying their usage, shortname, and description. Supports truncation and line break options for better readability.
#   aux-acu      : Analyzes the usage of variables from a config file across a target folder, displaying variable names, values, and occurrence counts in various files.
#   aux-mev      : Prompts the user to input or confirm a variable's value, allowing for easy customization of script parameters.
#   aux-nos      : Logs a function's execution status with a timestamp, providing a simple way to track script progress and debugging information.
#   aux-flc      : Displays the source code of a specified function from the library folder, including its description, shortname, and usage.
#   aux-use      : Displays the usage information, shortname, and description of the calling function, helping users understand how to use it.
#
# ============================================================================

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of selected functions in the script, displaying their usage, shortname, and description
# overview functions
#
aux-fun() {
    # Pass all arguments directly to aux-laf
    aux-laf "$FILEPATH_lib" "$@"
}

# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
#
aux-var() {
    aux-acu -o "$CONFIG_gpu" "$DIR_FUN/.."
}

# Logging function
aux-log() {
    local log_level="$1"
    local message="$2"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$log_level] $message"
}

# Recursively processes files in a directory and its subdirectories using a specified function, allowing for additional arguments to be passed
# function folder loop
# <function> <flag> <path> [extra_args ..]
aux-ffl() {
    local fnc
    local flag
    local folder
    local extra_args=()
    fnc="$1"
    flag="$2"
    folder="$3"
    shift 3
    # Collect remaining arguments as extra_args
    while [[ $# -gt 0 ]]; do
        extra_args+=("$1")
        shift
    done

    if [[ -d "$folder" ]]; then
        for file in "$folder"/{*,.[!.]*,..?*}; do
            if [[ -f "$file" ]]; then
                line_count=$(wc -l < "$file")
                
                # Get the file extension
                file_extension="${file##*.}"
                
                if [[ "$file_extension" == "conf" ]]; then
                    # Count variables in .conf files
                    variable_count=$(grep -cE '^[a-zA-Z0-9_]+=' "$file")
                    count_type="Variables"
                    count_value=$variable_count
                else
                    # Count functions in other files
                    function_count=$(grep -cE '^[a-zA-Z0-9_-]+\(\)[[:space:]]*\{' "$file")
                    count_type="Functions"
                    count_value=$function_count
                fi
                
                # Get the real path of the file
                real_path=$(realpath "$file")
                # Extract the filename (prefix) from the path
                filename=$(basename "$real_path")
                # Extract the prefix (part before the first dot)
                prefix="${filename%%.*}"
                # Get the directory path with the trailing slash
                dir_path=$(dirname "$real_path")/
                
                echo -e "$dir_path\e[32m$prefix\e[0m${filename#$prefix} - Contains \e[31m$line_count\e[0m Lines and \e[33m$count_value\e[0m $count_type"
                
                "$fnc" "$flag" "$file" "${extra_args[@]}"
            elif [[ -d "$file" && "$file" != "$folder"/. && "$file" != "$folder"/.. ]]; then
                aux-ffl "$fnc" "$flag" "$file" "${extra_args[@]}"
            fi
        done
    else
        echo "Invalid folder: $folder"
        return 1
    fi
}

# Lists all functions in a file, displaying their usage, shortname, and description. Supports truncation and line break options for better readability
# list all functions
# <file name> [-t] [-b]
aux-laf() {
    local truncate_mode=false
    local break_mode=false
    local file_name

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t)
                truncate_mode=true
                shift
                ;;
            -b)
                break_mode=true
                shift
                ;;
            *)
                file_name="$1"
                shift
                ;;
        esac
    done

    if [ -z "$file_name" ]; then
        aux-use
        return 1
    fi

    # Column width parameters
    local col_width_1=7
    local col_width_2=16
    local col_width_3=18
    local col_width_4=36
    local col_width_5=4
    local col_width_6=4
    local col_width_7=4
    local col_width_8=4
    local col_width_9=4

    # Function to truncate and pad strings
    truncate_and_pad() {
        local str="$1"
        local width="$2"
        if [ ${#str} -gt $width ]; then
            echo "${str:0:$((width-2))}.."
        else
            printf "%-${width}s" "$str"
        fi
    }

    # Function to wrap text
    wrap_text() {
        local text="$1"
        local width="$2"
        echo "$text" | fold -s -w "$width"
    }

    # Function to print a row (including header and data rows)
    print_row() {
        if $break_mode; then
            local col1=$(wrap_text "$1" $col_width_1)
            local col2=$(wrap_text "$2" $col_width_2)
            local col3=$(wrap_text "$3" $col_width_3)
            local col4=$(wrap_text "$4" $col_width_4)
            local col5=$(wrap_text "$5" $col_width_5)
            local col6=$(wrap_text "$6" $col_width_6)
            local col7=$(wrap_text "$7" $col_width_7)
            local col8=$(wrap_text "$8" $col_width_8)
            local col9=$(wrap_text "$9" $col_width_9)
            
            local IFS=$'\n'
            local lines1=($col1)
            local lines2=($col2)
            local lines3=($col3)
            local lines4=($col4)
            local lines5=($col5)
            local lines6=($col6)
            local lines7=($col7)
            local lines8=($col8)
            local lines9=($col9)
            
            local max_lines=$(( ${#lines1[@]} > ${#lines2[@]} ? ${#lines1[@]} : ${#lines2[@]} ))
            max_lines=$(( max_lines > ${#lines3[@]} ? max_lines : ${#lines3[@]} ))
            max_lines=$(( max_lines > ${#lines4[@]} ? max_lines : ${#lines4[@]} ))
            max_lines=$(( max_lines > ${#lines5[@]} ? max_lines : ${#lines5[@]} ))
            max_lines=$(( max_lines > ${#lines6[@]} ? max_lines : ${#lines6[@]} ))
            max_lines=$(( max_lines > ${#lines7[@]} ? max_lines : ${#lines7[@]} ))
            max_lines=$(( max_lines > ${#lines8[@]} ? max_lines : ${#lines8[@]} ))
            max_lines=$(( max_lines > ${#lines9[@]} ? max_lines : ${#lines9[@]} ))
            
            for i in $(seq 0 $((max_lines-1))); do
                printf "| %-${col_width_1}s | %-${col_width_2}s | %-${col_width_3}s | %-${col_width_4}s | %-${col_width_5}s | %-${col_width_6}s | %-${col_width_7}s | %-${col_width_8}s | %-${col_width_9}s |\n" \
                    "${lines1[$i]:-}" \
                    "${lines2[$i]:-}" \
                    "${lines3[$i]:-}" \
                    "${lines4[$i]:-}" \
                    "${lines5[$i]:-}" \
                    "${lines6[$i]:-}" \
                    "${lines7[$i]:-}" \
                    "${lines8[$i]:-}" \
                    "${lines9[$i]:-}"
            done
        elif $truncate_mode; then
            printf "| %s | %s | %s | %s | %s | %s | %s | %s | %s |\n" \
                "$(truncate_and_pad "$1" $col_width_1)" \
                "$(truncate_and_pad "$2" $col_width_2)" \
                "$(truncate_and_pad "$3" $col_width_3)" \
                "$(truncate_and_pad "$4" $col_width_4)" \
                "$(truncate_and_pad "$5" $col_width_5)" \
                "$(truncate_and_pad "$6" $col_width_6)" \
                "$(truncate_and_pad "$7" $col_width_7)" \
                "$(truncate_and_pad "$8" $col_width_8)" \
                "$(truncate_and_pad "$9" $col_width_9)"
        else
            printf "| %s | %s | %s | %s | %s | %s | %s | %s | %s |\n" \
                "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
        fi
    }

    # Function to print a separator line
    print_separator() {
        local total_width=$((col_width_1 + col_width_2 + col_width_3 + col_width_4 + col_width_5 + col_width_6 + col_width_7 + col_width_8 + col_width_9 + 26))
        printf "+%s+\n" "$(printf '%*s' $total_width '' | tr ' ' '-')"
    }

    print_separator_2() {
        local total_width=$((col_width_1 + col_width_2 + col_width_3 + col_width_4 + col_width_5 + col_width_6 + col_width_7 + col_width_8 + col_width_9 + 26))
        printf "+%s+\n" "$(printf '%*s' $total_width '' | tr ' ' ' ')"
    }

    local line_number=0
    declare -a comments=()

    # Read all comments into an array
    while IFS= read -r line; do
        ((line_number++))
        if [[ $line =~ ^[[:space:]]*# ]]; then
            comments[$line_number]="${line#"${line%%[![:space:]]*}"}"  # Remove leading whitespace
            comments[$line_number]="${comments[$line_number]#\# }"    # Remove leading '# '
            comments[$line_number]="${comments[$line_number]#\#}"     # Remove leading '#' if there's no space after it
        fi
    done < "$file_name"

    # Counts all function calls
    count_calls() {
        local func_name="$1"
        local count=$(awk -v func_name="$func_name" '{ for (i=1; i<=NF; i++) if ($i == func_name) count++ } END { print count }' "$file_name")
        echo "${count}"
    }

    # Counts all function calls in a folder, excluding a specific file
    count_calls_folder() {
        local func_name="$1"
        local folder_name="$2"
        local exclude_file="$3"
        local count=$(find "$folder_name" -type f ! -name "$(basename "$exclude_file")" -exec awk -v func_name="$func_name" '{ for (i=1; i<=NF; i++) if ($i == func_name) count++ } END { print count }' {} + | awk '{sum += $1} END {if (sum == 0) print ""; else print sum}')
        echo "${count}"
    }

    # Function to get comment or empty string
    get_comment() {
        local line_num=$1
        local comment="${comments[$line_num]:-}"
        # Return empty string if comment is just whitespace
        if [[ -z "${comment// }" ]]; then
            echo ""
        else
            echo "$comment"
        fi
    }

    # Print table header
    print_separator
    print_row "Func" "Arguments" "Shortname" "Description" "Size" "Loc" "file" "func" "gens"
    print_separator

    # Loop through all lines in the file again
    line_number=0
    while IFS= read -r line; do
        ((line_number++))
        if [[ $line =~ ^[a-zA-Z_][a-zA-Z0-9_-]*\(\) ]]; then
            # Extract function name without parentheses
            func_name=$(echo "$line" | awk -F '[(|)]' '{print $1}')
            # Calculate function size
            func_start_line=$line_number
            func_end_line=$(tail -n +$((func_start_line+1)) "$file_name" | grep -n '^}' | head -1 | cut -d: -f1)
            func_size=$((func_end_line + 1))  # +1 to include the closing brace
            
            # Count the number of calls to the function
            func_calls=$(count_calls "$func_name")
            callsfun=$(count_calls_folder "$func_name" "$LIB_DEP_DIR" "$file_name")
            callsgen=$(count_calls_folder "$func_name" "$SRC_SET_DIR" "$file_name")
            
            # Get comments for arguments, shortname, and description
            description=$(get_comment $((line_number-3)))
            shortname=$(get_comment $((line_number-2)))
            arguments=$(get_comment $((line_number-1)))

            # Print function information
            print_row "$func_name" "$arguments" "$shortname" "$description" "$func_size" "$line_number" "$func_calls" "$callsfun" "$callsgen"
            if $break_mode; then
                print_separator_2
            fi
        fi
    done < "$file_name"

    if ! $break_mode; then
        print_separator
    fi
    echo ""
}

# Analyzes the usage of variables from a config file across a target folder, displaying variable names, values, and occurrence counts in various files
# analyze config usage
# <sort mode: -o|-a > <config file or directory> <target folder>
aux-acu() {
    local sort_mode_arg="$1"
    local conf_source="$2"
    local target_folder="$3"

    # Customizable column widths
    local tab_width_var_names=24
    local tab_width_var_values=30
    local tab_width_total_occ=10
    local tab_width_files_list=50

    if [ $# -ne 3 ]; then
        echo "Usage: aux-acu <-o|-a|\"\"> <config file or directory> <target folder>"
        echo "  -o: original order from config file"
        echo "  -a: alphanumeric order of variable names"
        echo "  \"\": defaults to -o (original order)"
        return 1
    fi

    local sort_mode
    if [[ -z "$sort_mode_arg" ]]; then
        sort_mode="-o" # Default to original order if sort_mode_arg is empty
    else
        sort_mode="$sort_mode_arg"
    fi

    if [[ "$sort_mode" != "-o" && "$sort_mode" != "-a" ]]; then
        echo "Invalid sort mode: '$sort_mode_arg'. Use -o, -a, or an empty string (which defaults to -o)."
        aux-use # Assuming aux-use would print usage for aux-acu
        return 1
    fi

    if [[ ! -f "$conf_source" && ! -d "$conf_source" ]]; then
        echo "Config source '$conf_source' is not a valid file or directory."
        return 1
    fi

    if [[ ! -d "$target_folder" ]]; then
        echo "Target folder '$target_folder' does not exist."
        return 1
    fi

    declare -A config_vars
    declare -a var_order # To store variables in their original order from the config

    # --- Helper function to read config file ---
    _aux_acu_read_config_file() {
        local current_conf_source_path="$1"
        local files_to_process=()

        if [[ -d "$current_conf_source_path" ]]; then
            local item
            for item in "$current_conf_source_path"/*; do
                if [[ -f "$item" ]]; then
                    files_to_process+=("$item")
                fi
            done
            if [ ${#files_to_process[@]} -eq 0 ]; then
                echo "Warning: No configuration files found in directory '$current_conf_source_path'." >&2
                return
            fi
        elif [[ -f "$current_conf_source_path" ]]; then
            files_to_process+=("$current_conf_source_path")
        else
            # This case should have been caught by earlier checks, but as a safeguard:
            echo "Error: Invalid config source path '$current_conf_source_path' in _aux_acu_read_config_file." >&2
            return 1
        fi

        local current_conf_file var value line
        for current_conf_file in "${files_to_process[@]}"; do
            while IFS= read -r line || [[ -n "$line" ]]; do
                # Skip comments, empty lines, declare statements, and lines without '='
                if [[ "$line" =~ ^[[:space:]]*# || -z "$line" || "$line" =~ ^[[:space:]]*declare || ! "$line" =~ = ]]; then
                    continue
                fi

                local var_raw value_raw
                var_raw=$(echo "$line" | cut -d'=' -f1)
                value_raw=$(echo "$line" | cut -d'=' -f2-)

                # Trim whitespace from var_raw and ensure it's a valid variable name
                var=$(echo "$var_raw" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                if [[ ! "$var" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then # Basic validation for var name
                    continue
                fi
                
                # Trim whitespace from value_raw and remove surrounding quotes (single or double)
                value=$(echo "$value_raw" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^"\\(.*\\)"$/\\1/' -e "s/^'\\([^']*\)'$/\\1/")

                if [[ -n "$var" ]]; then
                    config_vars["$var"]="$value"
                    # Add to var_order only if not already present, to maintain first-seen order
                    if ! printf '%s\\n' "${var_order[@]}" | grep -qFx "$var"; then
                        var_order+=("$var")
                    fi
                fi
            done < "$current_conf_file"
        done
    }

    # --- Helper function to list target files ---
    local -a target_files=()
    _aux_acu_list_target_files() {
        local search_path="$1"
        # Exclude common VCS and build artifact directories, and filter for actual files
        # Using find for more robust file listing
        mapfile -t target_files < <(find "$search_path" \( -name ".git" -o -name ".svn" -o -name "node_modules" -o -name "vendor" \) -prune -o -type f -print | sort)
    }

    # --- Helper function to truncate strings ---
    _aux_acu_truncate_string() {
        local str="$1"
        local max_length="$2"
        if [ "${#str}" -gt "$max_length" ]; then
            if [ "$max_length" -lt 2 ]; then # Cannot add ".." if max_length is less than 2
                 printf "%.*s" "$max_length" "$str"
            else
                printf "%.*s.." "$((max_length-2))" "$str"
            fi
        else
            printf "%-${max_length}s" "$str"
        fi
    }
    
    # --- Helper functions for table printing ---
    _aux_acu_print_separator() {
        printf "+-%-${tab_width_var_names}s-+-%-${tab_width_var_values}s-+-%-${tab_width_total_occ}s-+-%-${tab_width_files_list}s-+\n" \
            "$(printf '%*s' "$tab_width_var_names" '' | tr ' ' '-')" \
            "$(printf '%*s' "$tab_width_var_values" '' | tr ' ' '-')" \
            "$(printf '%*s' "$tab_width_total_occ" '' | tr ' ' '-')" \
            "$(printf '%*s' "$tab_width_files_list" '' | tr ' ' '-')"
    }

    _aux_acu_print_header() {
        _aux_acu_print_separator
        printf "| %-${tab_width_var_names}s | %-${tab_width_var_values}s | %-${tab_width_total_occ}s | %-${tab_width_files_list}s |\n" \
            "Variable" "Value" "Total Occ." "Files (hits)"
        _aux_acu_print_separator
    }

    _aux_acu_print_row() {
        local var_name="$1"
        local var_value="$2"
        local total_occurrences="$3"
        local files_list_str="$4"

        local trunc_var_name=$(_aux_acu_truncate_string "$var_name" "$tab_width_var_names")
        local trunc_var_value=$(_aux_acu_truncate_string "$var_value" "$tab_width_var_values")
        local trunc_files_list=$(_aux_acu_truncate_string "$files_list_str" "$tab_width_files_list")
        local trunc_total_occ=$(_aux_acu_truncate_string "$total_occurrences" "$tab_width_total_occ")

        printf "| %s | %s | %s | %s |\n" \
            "$trunc_var_name" \
            "$trunc_var_value" \
            "$trunc_total_occ" \
            "$trunc_files_list"
    }

    _aux_acu_print_footer() {
        _aux_acu_print_separator
    }

    # --- Main logic ---
    _aux_acu_read_config_file "$conf_source"
    if [ ${#var_order[@]} -eq 0 ]; then
        echo "No variables found in config source '$conf_source'."
        return
    fi

    _aux_acu_list_target_files "$target_folder"
    if [ ${#target_files[@]} -eq 0 ]; then
        echo "No files found in target folder '$target_folder'."
        # Proceed to print variables without occurrence data if desired, or return
        # For now, let's print the table header and then variables with 0 occurrences.
    fi
    
    local -a vars_to_iterate
    if [[ "$sort_mode" == "-a" ]]; then
        mapfile -t vars_to_iterate < <(printf "%s\n" "${var_order[@]}" | sort)
    else # -o (original order)
        vars_to_iterate=("${var_order[@]}")
    fi

    _aux_acu_print_header

    for var_name in "${vars_to_iterate[@]}"; do
        local var_value="${config_vars[$var_name]}"
        local total_occurrences_for_var=0
        local files_with_occurrences_details=()

        if [ ${#target_files[@]} -gt 0 ]; then
            for target_file in "${target_files[@]}"; do
                if [[ -f "$target_file" && -r "$target_file" ]]; then # Ensure target_file is a readable file
                    # Search for the variable name as a whole word.
                    # This counts occurrences of the variable name itself (e.g., "MY_VAR").
                    # It won't distinguish between $MY_VAR, ${MY_VAR}, or MY_VAR=, but gives a general idea of usage.
                    # Using grep with -o lists each match on a new line, wc -l counts these lines.
                    # The pattern \bVAR_NAME\b ensures whole word matching.
                    occurrences_in_file=$(grep -E -o "\\b${var_name}\\b" "$target_file" 2>/dev/null | wc -l)
                    if [[ "$occurrences_in_file" -gt 0 ]]; then
                        total_occurrences_for_var=$((total_occurrences_for_var + occurrences_in_file))
                        files_with_occurrences_details+=("$(basename "$target_file"):$occurrences_in_file")
                    fi
                fi
            done
        fi

        local files_list_display_str=""
        if [ ${#files_with_occurrences_details[@]} -gt 0 ]; then
            files_list_display_str=$(IFS=,; echo "${files_with_occurrences_details[*]}")
        fi
        
        _aux_acu_print_row "$var_name" "$var_value" "$total_occurrences_for_var" "$files_list_display_str"
    done

    _aux_acu_print_footer
}

# Prompts the user to input or confirm a variable's value, allowing for easy customization of script parameters
# main eval variable
# <var_name> <prompt_message> <current_value>
aux-mev() {
    local var_name=$1
    local prompt_message=$2
    local current_value=$3

    if [ $# -ne 3 ]; then
	aux-use
        return 1
    fi

    read -p "$prompt_message [$current_value]: " input
    if [ -n "$input" ]; then
        eval "$var_name=\"$input\""
    else
        eval "$var_name=\"$current_value\""
    fi
}

# Logs a function's execution status with a timestamp, providing a simple way to track script progress and debugging information
# main display notification
# <function_name> <status>
aux-nos() {
    local function_name="$1"
    local status="$2"


    echo "[$(date +"%Y-%m-%d %H:%M:%S")] $function_name: $status"
}

# Displays the source code of a specified function from the library folder, including its description, shortname, and usage
# function library cat
# <function_name>
aux-flc() {
    # Check if a function name is provided
    if [ -z "$1" ]; then
        aux-use
        return 1
    fi

    # Extract the library prefix from the function name
    func_name="$1"
    lib_prefix="${func_name%%-*}"
    lib_file="/root/lab/lib/${lib_prefix}.bash"

    # Check if the library file exists
    if [ ! -f "$lib_file" ]; then
        echo "Library file $lib_file not found!"
        return 1
    fi

    # Search for the function definition in the library file
    start_line=$(grep -n "^[[:space:]]*${func_name}[[:space:]]*()" "$lib_file" | cut -d: -f1)
    start_line=$((start_line - 3))

    if [ -z "$start_line" ]; then
        echo "Function $func_name not found in $lib_file"
        return 1
    fi

    # Extract the function source code
    awk "NR >= $start_line { print; if (/^\}$/) exit }" "$lib_file"
}

# Displays the usage information, shortname, and description of the calling function, helping users understand how to use it
# function usage information
#
aux-use() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Use grep to locate the function's declaration line number
    local function_start_line=$(grep -n -m 1 "^[[:space:]]*${caller_function}()" "$script_file" | cut -d: -f1)

    if [ -z "$function_start_line" ]; then
        echo "Function not found."
        return
    fi

    # Calculate the line number of the comment
    local description_line=$((function_start_line - 3))
    local shortname_line=$((function_start_line - 2))
    local usage_line=$((function_start_line - 1))

    # Use sed to get the comment line and strip off leading "# "
    local description=$(sed -n "${description_line}s/^# //p" "$script_file")
    local shortname=$(sed -n "${shortname_line}s/^# //p" "$script_file")
    local usage=$(sed -n "${usage_line}s/^# //p" "$script_file")
    local funcname=${caller_function}

    # Display the comment
    echo "Description:    $description"
    echo "Shortname:      $shortname"
    echo "Usage:          $funcname" "$usage"

}
