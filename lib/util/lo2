#!/bin/bash
#
# -----------------------------------------------------------------------------
# Module: Runtime Control Structure Tracking (lo2)
# -----------------------------------------------------------------------------
# Purpose:     Monitor and report the depth of nested control structures (if, for,
#              while, etc.) during script execution.
# File:        lib/util/lo2
#
# Description: This module provides functionality to track the depth of shell
#              control structures at runtime. It uses a DEBUG trap to monitor
#              commands and identify control flow statements, maintaining a stack
#              to calculate the current depth. It also includes debug logging
#              for its own operations.
#
# Dependencies: Relies on 'verify_module' for module integrity.
#               Uses environment variables: LOG_DEBUG_ENABLED, LOG_DEBUG_FILE,
#               LOG_CONTROL_STATE_FILE, HOME, LOG_DIR, TMP_DIR.
#
# Usage:       Sourced by other scripts or modules.
#              'setlogcontrol on/off' enables/disables the tracking.
#              'calculate_final_depth' can be used to get the current depth,
#              potentially combined with a base depth from other modules (e.g., lo1).
#              'lo2_debug_log' provides specific debug messages for this module.
#
# Notes:       The core functionality relies on setting a DEBUG trap.
#              LOG_CONTROL_DEPTH_ENABLED globally controls if this tracking is active.
#              The module attempts to deduplicate control structures to avoid
#              over-counting in certain scenarios.
# -----------------------------------------------------------------------------

verify_module "lo2" || exit 1

# Enhanced debug logging - moved to top
lo2_debug_log() {
    local message="$1"
    local context="${2:-lo2_module}" # Use the second argument as context/sub-component
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S.%N')

    # Log to LO2_LOG_FILE, with a fallback similar to what's used elsewhere in the script.
    printf "[%s] [lo2:%s] %s\n" "$timestamp" "$context" "$message" >> "${LO2_LOG_FILE:-/tmp/lo2_fallback.log}"
}

lo2_debug_log "lo2_debug_log defined" "init"

# Initialize lo2 log file (simple version, can be expanded)
if [[ ! -f "$LO2_LOG_FILE" ]]; then
    touch "$LO2_LOG_FILE"
fi

lo2_debug_log "LO2_LOG_FILE check done" "init"

# Clear log on module load/init - ensure LO2_LOG_FILE is set or default
: > "${LO2_LOG_FILE:-/tmp/lo2_fallback.log}"
lo2_debug_log "LO2_LOG_FILE cleared" "init"

lo2_debug_log "Entering lo2 module initialization" "init"
lo2_debug_log "Validating environment variables in lo2" "init"
lo2_debug_log "HOME=$HOME" "init"
lo2_debug_log "LOG_DIR=$LOG_DIR" "init"
lo2_debug_log "TMP_DIR=$TMP_DIR" "init"
lo2_debug_log "Setting up lo2 module directories" "init"

lo2_debug_log "Point A - After 'Setting up lo2 module directories' log" "init"

# Global state
lo2_debug_log "Point B - Before declare LOG_CONTROL_DEPTH_ENABLED" "init"
declare -g LOG_CONTROL_DEPTH_ENABLED=false
lo2_debug_log "Point C - After declare LOG_CONTROL_DEPTH_ENABLED" "init"

lo2_debug_log "Point D - Before declare CONTROL_DEPTH_STACK" "init"
declare -ga CONTROL_DEPTH_STACK=() # UNCOMMENTED
lo2_debug_log "Point E - After declare CONTROL_DEPTH_STACK" "init"

lo2_debug_log "Point F - Before declare LAST_COMMAND_SIGNATURE" "init"
declare -g LAST_COMMAND_SIGNATURE="" # UNCOMMENTED
lo2_debug_log "Point G - After declare LAST_COMMAND_SIGNATURE" "init"

lo2_debug_log "Point H - After all global var declares, before func defs" "init"

# Add a hash function to identify unique control structures
hash_command() {
    local cmd="$1"
    local src_file="$2" # Source file of the command
    local line_num="$3" # Line number of the command
    echo "${src_file}:${line_num}:${cmd}"
}

# Modified tracking function with deduplication
track_control_depth() {
    local command="$1"
    local source_file="$2" # Directly use the argument from the trap
    local line_number="$3" # Directly use the argument from the trap

    local current_signature="${source_file}:${line_number}:${command}"
    if [[ -n "${LAST_COMMAND_SIGNATURE+isset}" && "$current_signature" == "$LAST_COMMAND_SIGNATURE" ]]; then
        return
    fi
    LAST_COMMAND_SIGNATURE="$current_signature"

    local cmd_hash=$(hash_command "$command" "$source_file" "$line_number")
    lo2_debug_log "Processing: '${command}' (hash: ${cmd_hash}, src: ${source_file}:${line_number})" "track_depth"

    local control_keyword=""
    if [[ "$command" =~ ^if(\s|\[|$) ]];      then control_keyword="if";
    elif [[ "$command" =~ ^for([\(\s]|$) ]];  then control_keyword="for";
    elif [[ "$command" =~ ^while(\s|\[|$) ]]; then control_keyword="while";
    elif [[ "$command" =~ ^until(\s|\[|$) ]]; then control_keyword="until";
    elif [[ "$command" =~ ^case(\s|$) ]];   then control_keyword="case";
    elif [[ "$command" =~ ^select(\s|$) ]]; then control_keyword="select";
    elif [[ "$command" == "{" || "$command" =~ ^\{\s+.* ]]; then control_keyword="block_open";
    fi

    if [[ -n "$control_keyword" ]]; then
        CONTROL_DEPTH_STACK+=("$cmd_hash")
        lo2_debug_log "Entered '$control_keyword': ${command} (depth: ${#CONTROL_DEPTH_STACK[@]}) (src: $source_file:$line_number)" "track_depth"
        return
    fi

    local closing_keyword=""
    if [[ "$command" == "fi" ]];    then closing_keyword="fi";
    elif [[ "$command" == "done" ]];  then closing_keyword="done";
    elif [[ "$command" == "esac" ]];  then closing_keyword="esac";
    elif [[ "$command" == "}" ]]; then closing_keyword="block_close";
    fi

    if [[ -n "$closing_keyword" ]]; then
        if [ ${#CONTROL_DEPTH_STACK[@]} -gt 0 ]; then
            local last_structure_hash="${CONTROL_DEPTH_STACK[-1]}"
            local last_command_in_hash="${last_structure_hash##*:}"

            local should_pop=false
            case "$closing_keyword" in
                "fi")
                    [[ "$last_command_in_hash" =~ ^if(\s|\[|$) ]] && should_pop=true ;;
                "done")
                    if [[ "$last_command_in_hash" =~ ^for([\(\s]|$) || \
                          "$last_command_in_hash" =~ ^while(\s|\[|$) || \
                          "$last_command_in_hash" =~ ^until(\s|\[|$) || \
                          "$last_command_in_hash" =~ ^select(\s|$) ]]; then
                        should_pop=true
                    fi
                    ;;
                "esac")
                    [[ "$last_command_in_hash" =~ ^case(\s|$) ]] && should_pop=true ;;
                "block_close")
                    [[ "$last_command_in_hash" == "{" || "$last_command_in_hash" =~ ^\{\s+.* ]] && should_pop=true ;;
            esac

            if $should_pop; then
                unset 'CONTROL_DEPTH_STACK[-1]'
                lo2_debug_log "Exited control for '$closing_keyword' (new depth: ${#CONTROL_DEPTH_STACK[@]}) (matched open: '$last_command_in_hash')" "track_depth"
            else
                lo2_debug_log "Mismatched exit: '$closing_keyword'. Stack top cmd: '$last_command_in_hash' (hash: '$last_structure_hash')" "track_depth"
            fi
        else
            lo2_debug_log "Attempted to exit '$closing_keyword', but stack empty." "track_depth"
        fi
        return
    fi
}

get_current_control_depth() {
    lo2_debug_log "Current control depth: ${#CONTROL_DEPTH_STACK[@]}" "get_depth"
    echo ${#CONTROL_DEPTH_STACK[@]}
}

print_control_stack() {
    lo2_debug_log "Control structure stack:" "stack_debug"
    local i=0
    for structure in "${CONTROL_DEPTH_STACK[@]}"; do
        local cmd="${structure##*:}"
        lo2_debug_log "  $i: $cmd (hash: $structure)" "stack_debug"
        ((i++))
    done
}

calculate_control_depth() {
    local depth=$(get_current_control_depth)
    lo2_debug_log "Calculated control depth: $depth" "calc_depth"
    if ((depth > 0)); then
        print_control_stack
    fi
    echo "$depth"
}

calculate_final_depth() {
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local base_depth
        base_depth=$(get_base_depth)
        lo2_debug_log "Base depth: $base_depth" "final_depth"

        local control_depth
        control_depth=$(calculate_control_depth)
        local total_depth=$((base_depth + control_depth))

        lo2_debug_log "Control depth: $control_depth, Total depth: $total_depth" "final_depth"
        echo "$total_depth"
    else
        get_base_depth
    fi
}

install_depth_tracking() {
    lo2_debug_log "install_depth_tracking CALLED" "init"
    local old_trap
    old_trap=$(trap -p DEBUG)
    lo2_debug_log "install_depth_tracking: old_trap='$old_trap'" "init"
    
    # Correctly define the command string for the trap
    local new_trap_command='echo "RAW DEBUG TRAP FIRED: CMD=$BASH_COMMAND SRC=${BASH_SOURCE[0]} LINE=${BASH_LINENO[0]} Timestamp: $(date '\\''+%H:%M:%S.%N'\\'')'" >> "/home/es/lab/.log/lo2_trap_fire.log"'
    
    lo2_debug_log "install_depth_tracking: new_trap_command='$new_trap_command'" "init"

    if [[ -n "$old_trap" && "$old_trap" != *"lo2_trap_command_wrapper"* ]]; then
        # Preserve existing trap by creating a wrapper
        # Extract existing command: remove "trap -- '" at the beginning and "' DEBUG" at the end
        local existing_command
        existing_command=${old_trap#trap -- \'}
        existing_command=${existing_command%\' DEBUG}

        # Define a wrapper function name that's unlikely to clash
        local wrapper_func_name="lo2_trap_command_wrapper"

        # Create the wrapper function dynamically
        eval "function $wrapper_func_name() { $existing_command; $new_trap_command; }"
        lo2_debug_log "install_depth_tracking: Defined wrapper $wrapper_func_name" "init"
        
        # Set the trap to call the wrapper
        trap "$wrapper_func_name" DEBUG
        lo2_debug_log "install_depth_tracking: DEBUG trap SET to wrapper '$wrapper_func_name'. Current: '$(trap -p DEBUG)'" "init"
    else
        # No existing trap, or it's already our wrapper (or a previous version of our simple trap)
        trap "$new_trap_command" DEBUG
        lo2_debug_log "install_depth_tracking: DEBUG trap SET (simplified or overwriting previous lo2 trap). Current: '$(trap -p DEBUG)'" "init"
    fi
    
    lo2_debug_log "Installed control structure tracking (simplified for diagnosis)" "init"
}

remove_depth_tracking() {
    trap - DEBUG
    lo2_debug_log "Removed control structure tracking" "cleanup"
}

setlogcontrol() {
    lo2_debug_log "setlogcontrol CALLED with $1" "init"
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            echo "on" > "$LOG_CONTROL_STATE_FILE"
            lo2_debug_log "setlogcontrol ON: calling install_depth_tracking" "init"
            install_depth_tracking
            CONTROL_DEPTH_STACK=()
            lo2_debug_log "Control structure depth tracking enabled" "setlogcontrol"
            printf "%s      └─ Control structure depth tracking enabled%s\n" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            echo "off" > "$LOG_CONTROL_STATE_FILE"
            lo2_debug_log "setlogcontrol OFF: calling remove_depth_tracking" "init"
            remove_depth_tracking
            CONTROL_DEPTH_STACK=()
            lo2_debug_log "Control structure depth tracking disabled" "setlogcontrol"
            printf "%s      └─ Control structure depth tracking disabled%s\n" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlogcontrol on|off\n"
            return 1
            ;;
    esac
}

cleanup_lo2() {
    lo2_debug_log "Starting cleanup" "cleanup_lo2"
    remove_depth_tracking
    CONTROL_DEPTH_STACK=()
    LAST_COMMAND_SIGNATURE=""
    lo2_debug_log "Cleanup complete" "cleanup_lo2"
}

debug_message() {
    local message="$1"
    local component="${2:-${FUNCNAME[1]:-main}}"
    local level="${3:-1}"
    
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local depth=$(get_current_control_depth)
    local indent=$(printf '%*s' "$depth" "" | tr ' ' '·')
    
    local formatted_message="[$component] ${indent}$message"
    
    printf "[DEBUG] %s - %s\n" "$timestamp" "$formatted_message" >> "$LOG_DEBUG_FILE"
    
    if (( DEBUG_VERBOSITY >= level )); then
        printf "[DEBUG] %s - %s\n" "$timestamp" "$formatted_message" >&2
    fi
    
    return 0
}

debug_with_timer() {
    local message="$1"
    local component="${2:-${FUNCNAME[1]:-main}}"
    local level="${3:-1}"
    
    if type -t get_elapsed_time &>/dev/null; then
        local elapsed=$(get_elapsed_time "$component")
        debug_message "$message (elapsed: ${elapsed}s)" "$component" "$level"
    else
        debug_message "$message (timing unavailable)" "$component" "$level"
    fi
    
    return 0
}

lo2_debug_log "Point I - After all func defs, before exports" "init"

export LOG_CONTROL_DEPTH_ENABLED
export -f setlogcontrol
export -f lo2_debug_log debug_message debug_with_timer
export -f calculate_final_depth
export -f track_control_depth
export -f get_current_control_depth

trap cleanup_lo2 EXIT
lo2_debug_log "Point J - After trap cleanup_lo2 EXIT" "init"

if [[ -z "$LOG_CONTROL_STATE_FILE" ]]; then
    lo2_debug_log "LOG_CONTROL_STATE_FILE variable is not set. Cannot manage control tracking state persistence. Control tracking will be 'on' by default for this session." "init"
    setlogcontrol "on"
elif [[ -f "$LOG_CONTROL_STATE_FILE" && -s "$LOG_CONTROL_STATE_FILE" ]]; then
    local saved_control_state
    saved_control_state=$(<"$LOG_CONTROL_STATE_FILE")
    lo2_debug_log "Found control state file: $LOG_CONTROL_STATE_FILE with content: $saved_control_state" "init"
    if [[ "$saved_control_state" == "on" ]]; then
        setlogcontrol "on"
    elif [[ "$saved_control_state" == "off" ]]; then
        setlogcontrol "off"
    else
        lo2_debug_log "Invalid content in $LOG_CONTROL_STATE_FILE: '$saved_control_state'. Defaulting to 'on'." "init"
        setlogcontrol "on"
    fi
else
    lo2_debug_log "Control state file '$LOG_CONTROL_STATE_FILE' not found or empty. Defaulting to 'on'." "init"
    setlogcontrol "on"
fi

lo2_debug_log "lo2 module initialization completed successfully" "init"
