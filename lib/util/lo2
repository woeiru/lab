#!/bin/bash
#
# -----------------------------------------------------------------------------
# Module: Runtime Control Structure Tracking (lo2)
# -----------------------------------------------------------------------------
# Purpose:     Monitor and report the depth of nested control structures (if, for,
#              while, etc.) during script execution.
# File:        lib/util/lo2
#
# Description: This module provides functionality to track the depth of shell
#              control structures at runtime. It uses a DEBUG trap to monitor
#              commands and identify control flow statements, maintaining a stack
#              to calculate the current depth. It also includes debug logging
#              for its own operations.
#
# Dependencies: Relies on 'verify_module' for module integrity.
#               Uses environment variables: LOG_DEBUG_ENABLED, LOG_DEBUG_FILE,
#               LOG_CONTROL_STATE_FILE, HOME, LOG_DIR, TMP_DIR.
#
# Usage:       Sourced by other scripts or modules.
#              'setlogcontrol on/off' enables/disables the tracking.
#              'calculate_final_depth' can be used to get the current depth,
#              potentially combined with a base depth from other modules (e.g., lo1).
#              'lo2_debug_log' provides specific debug messages for this module.
#
# Notes:       The core functionality relies on setting a DEBUG trap.
#              LOG_CONTROL_DEPTH_ENABLED globally controls if this tracking is active.
#              The module attempts to deduplicate control structures to avoid
#              over-counting in certain scenarios.
# -----------------------------------------------------------------------------

verify_module "lo2" || exit 1

# Enhanced debug logging - moved to top
lo2_debug_log() {
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    local timestamp=$(date '+%H:%M:%S')
    local message="$1"
    local source="${2:-unknown}"
    printf "[LO2-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "$LO2_LOG_FILE"
}

# Initialize lo2 log file (simple version, can be expanded)
if [[ ! -f "$LO2_LOG_FILE" ]]; then
    touch "$LO2_LOG_FILE"
fi
: > "$LO2_LOG_FILE" # Clear log on module load/init

lo2_debug_log "Entering lo2 module initialization" "init"
lo2_debug_log "Validating environment variables in lo2" "init"
lo2_debug_log "HOME=$HOME" "init"
lo2_debug_log "LOG_DIR=$LOG_DIR" "init"
lo2_debug_log "TMP_DIR=$TMP_DIR" "init"
lo2_debug_log "Setting up lo2 module directories" "init"

# Global state
declare -g LOG_CONTROL_DEPTH_ENABLED=false

# Runtime control structure tracking
declare -ga CONTROL_DEPTH_STACK=()
declare -g LAST_COMMAND_SIGNATURE="" # Changed from LAST_COMMAND

# Add a hash function to identify unique control structures
# Modified hash_command to take explicit source and lineno
hash_command() {
    local cmd="$1"
    local src_file="$2" # Source file of the command
    local line_num="$3" # Line number of the command
    echo "${src_file}:${line_num}:${cmd}"
}

# Modified tracking function with deduplication
track_control_depth() {
    # ADD THIS LINE FOR DIAGNOSIS
    echo "track_control_depth CALLED: CMD=\"$1\" SRC=\"$2\" LINE=\"$3\"" >> "/home/es/lab/.log/lo2_trap_fire.log"

    local command="$1"
    local source_file="$2" # Directly use the argument from the trap
    local line_number="$3" # Directly use the argument from the trap
    # Ensure source_file and line_number are not empty; default to unknown if necessary

    # Skip if it's the same command, source, and line as last time
    local current_signature="${source_file}:${line_number}:${command}"
    # Conditional return to prevent errors if LAST_COMMAND_SIGNATURE is unbound during initial calls
    if [[ -n "${LAST_COMMAND_SIGNATURE+isset}" && "$current_signature" == "$LAST_COMMAND_SIGNATURE" ]]; then
        return
    fi
    LAST_COMMAND_SIGNATURE="$current_signature"

    local cmd_hash=$(hash_command "$command" "$source_file" "$line_number")
    # Extended debug log to include source and line
    lo2_debug_log "Processing: '${command}' (hash: ${cmd_hash}, src: ${source_file}:${line_number})" "track_depth"

    local control_keyword=""
    # Refined regex for opening control structures
    if [[ "$command" =~ ^if(\s|\[|$) ]];      then control_keyword="if";
    elif [[ "$command" =~ ^for([\(\s]|$) ]];  then control_keyword="for"; # Handles 'for ((' and 'for var'
    elif [[ "$command" =~ ^while(\s|\[|$) ]]; then control_keyword="while";
    elif [[ "$command" =~ ^until(\s|\[|$) ]]; then control_keyword="until";
    elif [[ "$command" =~ ^case(\s|$) ]];   then control_keyword="case";
    elif [[ "$command" =~ ^select(\s|$) ]]; then control_keyword="select";
    # Match '{' if it's a standalone token or followed by space (typical for compound commands)
    # Avoids matching brace expansion like {a,b}
    elif [[ "$command" == "{" || "$command" =~ ^\{\s+.* ]]; then control_keyword="block_open";
    fi

    if [[ -n "$control_keyword" ]]; then
        CONTROL_DEPTH_STACK+=("$cmd_hash")
        lo2_debug_log "Entered '$control_keyword': ${command} (depth: ${#CONTROL_DEPTH_STACK[@]}) (src: $source_file:$line_number)" "track_depth"
        # print_control_stack # Uncomment for detailed stack debugging
        return
    fi

    local closing_keyword=""
    # Closing keywords are typically standalone
    if [[ "$command" == "fi" ]];    then closing_keyword="fi";
    elif [[ "$command" == "done" ]];  then closing_keyword="done";
    elif [[ "$command" == "esac" ]];  then closing_keyword="esac";
    # Match '}' if it's a standalone token
    elif [[ "$command" == "}" ]]; then closing_keyword="block_close";
    fi

    if [[ -n "$closing_keyword" ]]; then
        if [ ${#CONTROL_DEPTH_STACK[@]} -gt 0 ]; then
            local last_structure_hash="${CONTROL_DEPTH_STACK[-1]}"
            local last_command_in_hash="${last_structure_hash##*:}" # Extracts command part from "source:line:command"

            local should_pop=false
            case "$closing_keyword" in
                "fi")
                    [[ "$last_command_in_hash" =~ ^if(\s|\[|$) ]] && should_pop=true ;;
                "done")
                    # 'done' closes for, while, until, select
                    if [[ "$last_command_in_hash" =~ ^for([\(\s]|$) || \
                          "$last_command_in_hash" =~ ^while(\s|\[|$) || \
                          "$last_command_in_hash" =~ ^until(\s|\[|$) || \
                          "$last_command_in_hash" =~ ^select(\s|$) ]]; then
                        should_pop=true
                    fi
                    ;;
                "esac")
                    [[ "$last_command_in_hash" =~ ^case(\s|$) ]] && should_pop=true ;;
                "block_close")
                    # Match '{' as it was matched for opening
                    [[ "$last_command_in_hash" == "{" || "$last_command_in_hash" =~ ^\{\s+.* ]] && should_pop=true ;;
            esac

            if $should_pop; then
                unset 'CONTROL_DEPTH_STACK[-1]'
                lo2_debug_log "Exited control for '$closing_keyword' (new depth: ${#CONTROL_DEPTH_STACK[@]}) (matched open: '$last_command_in_hash')" "track_depth"
            else
                lo2_debug_log "Mismatched exit: '$closing_keyword'. Stack top cmd: '$last_command_in_hash' (hash: '$last_structure_hash')" "track_depth"
            fi
        else
            lo2_debug_log "Attempted to exit '$closing_keyword', but stack empty." "track_depth"
        fi
        # print_control_stack # Uncomment for detailed stack debugging
        return
    fi
}

# Get current runtime control structure depth
get_current_control_depth() {
    lo2_debug_log "Current control depth: ${#CONTROL_DEPTH_STACK[@]}" "get_depth"
    echo ${#CONTROL_DEPTH_STACK[@]}
}

print_control_stack() {
    lo2_debug_log "Control structure stack:" "stack_debug"
    local i=0
    for structure in "${CONTROL_DEPTH_STACK[@]}"; do
        # Extract original command from hash
        local cmd="${structure##*:}"
        lo2_debug_log "  $i: $cmd (hash: $structure)" "stack_debug"
        ((i++))
    done
}

# Calculate control structure depth
calculate_control_depth() {
    local depth=$(get_current_control_depth)
    lo2_debug_log "Calculated control depth: $depth" "calc_depth"
    if ((depth > 0)); then
        print_control_stack
    fi
    echo "$depth"
}

# Override calculate_final_depth to use runtime tracking
calculate_final_depth() {
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local base_depth
        base_depth=$(get_base_depth)
        lo2_debug_log "Base depth: $base_depth" "final_depth"

        local control_depth
        control_depth=$(calculate_control_depth)
        local total_depth=$((base_depth + control_depth))

        lo2_debug_log "Control depth: $control_depth, Total depth: $total_depth" "final_depth"
        echo "$total_depth"
    else
        get_base_depth
    fi
}

# Install the debug trap for control structure tracking
install_depth_tracking() {
    # Save any existing DEBUG trap
    local old_trap=$(trap -p DEBUG)
    # Correctly pass BASH_SOURCE[0] and BASH_LINENO[0] from the trap's context
    local new_trap_command='track_control_depth "$BASH_COMMAND" "${BASH_SOURCE[0]}" "${BASH_LINENO[0]}"'

    # Set our new trap while preserving any existing trap
    if [[ -n "$old_trap" && "$old_trap" != *"track_control_depth"* ]]; then
        local old_command_match
        # More robust extraction of the old command
        if [[ "$old_trap" =~ trap -- \'(.*)\' DEBUG ]]; then
            old_command_match="${BASH_REMATCH[1]}"
            # Ensure old_command_match is not empty and doesn't recursively call track_control_depth
            if [[ -n "$old_command_match" && "$old_command_match" != *"track_control_depth"* ]]; then
                 # Properly escape the old command before combining
                local escaped_old_command=$(printf '%q' "$old_command_match")
                trap "$(printf "%s; eval %s" "$new_trap_command" "$escaped_old_command")" DEBUG
                lo2_debug_log "Installed control structure tracking, preserving: $old_command_match" "init"
            else
                trap "$new_trap_command" DEBUG
                lo2_debug_log "Installed control structure tracking (old trap was problematic or redundant)" "init"
            fi
        else
            trap "$new_trap_command" DEBUG
            lo2_debug_log "Installed control structure tracking (old trap format not recognized)" "init"
        fi
    elif [[ "$old_trap" != *"track_control_depth"* ]]; then # Handles empty or non-relevant old trap
        trap "$new_trap_command" DEBUG
        lo2_debug_log "Installed control structure tracking (no previous relevant trap)" "init"
    else
        lo2_debug_log "Control structure tracking already installed or old trap is only track_control_depth." "init"
    fi
}

# Remove the debug trap
remove_depth_tracking() {
    trap - DEBUG
    lo2_debug_log "Removed control structure tracking" "cleanup"
}

# Control structure tracking toggle
setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            echo "on" > "$LOG_CONTROL_STATE_FILE" # Changed "true" to "on"
            install_depth_tracking
            CONTROL_DEPTH_STACK=()
            lo2_debug_log "Control structure depth tracking enabled" "setlogcontrol"
            printf "%s      └─ Control structure depth tracking enabled%s\n" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            echo "off" > "$LOG_CONTROL_STATE_FILE" # Changed "false" to "off"
            remove_depth_tracking
            CONTROL_DEPTH_STACK=()
            lo2_debug_log "Control structure depth tracking disabled" "setlogcontrol"
            printf "%s      └─ Control structure depth tracking disabled%s\n" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlogcontrol on|off\n"
            return 1
            ;;
    esac
}

cleanup_lo2() {
    lo2_debug_log "Starting cleanup" "cleanup_lo2"
    remove_depth_tracking
    CONTROL_DEPTH_STACK=()
    LAST_COMMAND_SIGNATURE="" # Changed from LAST_COMMAND
    lo2_debug_log "Cleanup complete" "cleanup_lo2"
}

# Debug message function for modules to use
debug_message() {
    local message="$1"
    local component="${2:-${FUNCNAME[1]:-main}}"
    local level="${3:-1}" # Default verbosity level
    
    # Skip if debug logging is disabled
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    
    # Format timestamp and get execution context depth
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local depth=$(get_current_control_depth)
    local indent=$(printf '%*s' "$depth" "" | tr ' ' '·')
    
    # Format the log message
    local formatted_message="[$component] ${indent}$message"
    
    # Log to debug file
    printf "[DEBUG] %s - %s\n" "$timestamp" "$formatted_message" >> "$LOG_DEBUG_FILE"
    
    # Output to stderr if verbosity level allows
    if (( DEBUG_VERBOSITY >= level )); then
        printf "[DEBUG] %s - %s\n" "$timestamp" "$formatted_message" >&2
    fi
    
    return 0
}

# Debug message with timer integration
debug_with_timer() {
    local message="$1"
    local component="${2:-${FUNCNAME[1]:-main}}"
    local level="${3:-1}"
    
    # Check if TME module functions are available
    if type -t get_elapsed_time &>/dev/null; then
        local elapsed=$(get_elapsed_time "$component")
        debug_message "$message (elapsed: ${elapsed}s)" "$component" "$level"
    else
        debug_message "$message (timing unavailable)" "$component" "$level"
    fi
    
    return 0
}

# Export necessary functions and variables
export LOG_CONTROL_DEPTH_ENABLED
export -f setlogcontrol
export -f lo2_debug_log debug_message debug_with_timer
export -f calculate_final_depth
export -f track_control_depth
export -f get_current_control_depth

# Set up cleanup trap
trap cleanup_lo2 EXIT

# Initialize control tracking based on saved state, defaulting to 'on'
# Assumes LOG_CONTROL_STATE_FILE is defined in the environment (e.g., from ric)
if [[ -z "$LOG_CONTROL_STATE_FILE" ]]; then
    lo2_debug_log "LOG_CONTROL_STATE_FILE variable is not set. Cannot manage control tracking state persistence. Control tracking will be 'on' by default for this session." "init"
    setlogcontrol "on" # Attempt to set control on, but state won't be saved
elif [[ -f "$LOG_CONTROL_STATE_FILE" && -s "$LOG_CONTROL_STATE_FILE" ]]; then
    local saved_control_state
    saved_control_state=$(<"$LOG_CONTROL_STATE_FILE")
    lo2_debug_log "Found control state file: $LOG_CONTROL_STATE_FILE with content: $saved_control_state" "init"
    if [[ "$saved_control_state" == "on" ]]; then
        setlogcontrol "on"
    elif [[ "$saved_control_state" == "off" ]]; then
        setlogcontrol "off"
    else
        lo2_debug_log "Invalid content in $LOG_CONTROL_STATE_FILE: '$saved_control_state'. Defaulting to 'on'." "init"
        setlogcontrol "on" # This will also write 'on' to LOG_CONTROL_STATE_FILE
    fi
else
    lo2_debug_log "Control state file '$LOG_CONTROL_STATE_FILE' not found or empty. Defaulting to 'on'." "init"
    setlogcontrol "on" # This will also write 'on' to LOG_CONTROL_STATE_FILE
fi

# Add final debug log
lo2_debug_log "lo2 module initialization completed successfully" "init"
