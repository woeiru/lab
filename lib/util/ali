#!/bin/bash

# Improved readme aliases generation with error handling
generate_readme_aliases() {
    start_nested_timing "gen_readme_aliases"
    log "lvl" "Generating readme aliases"
    local FILEBASE_MD="readme.md"

    # Validate LAB_DIR
    if [[ -z "$LAB_DIR" ]]; then
        log "lvl" "Error: LAB_DIR is not defined"
        error_handler "$LINENO" "${ERROR_CODES[CONFIG_ERROR]}" "false"
        return 1
    fi

    # Check if LAB_DIR exists
    if [[ ! -d "$LAB_DIR" ]]; then
        log "lvl" "Error: LAB_DIR directory does not exist: $LAB_DIR"
        error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
        return 1
    fi

    start_nested_timing "process_readme_files"
    local found_files=0
    while IFS= read -r -d '' file; do
        log "lvl" "Processing readme file: $file"
        dir=$(dirname "$file")
        dir_name=$(basename "$dir")
        parent_dir=$(basename "$(dirname "$dir")")

        if [[ "$parent_dir" != "lab" ]]; then
            alias_name="$parent_dir-$dir_name-md"
        else
            alias_name="$dir_name-md"
        fi

        alias "c-$alias_name=cat $file"
        echo "alias c-$alias_name='cat \"$file\"'" >> "$CFG_ALI_DIR/dyn"
        alias "v-$alias_name=vim $file"
        echo "alias v-$alias_name='vim \"$file\"'" >> "$CFG_ALI_DIR/dyn"
        log "lvl" "Created aliases: c-$alias_name and v-$alias_name for $file"
        ((found_files++))
    done < <(find "$LAB_DIR" -type f -name "$FILEBASE_MD" -print0 2>/dev/null)

    if ((found_files == 0)); then
        log "lvl" "Warning: No readme files found in $LAB_DIR"
        error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
    fi

    end_nested_timing "process_readme_files" "success"
    end_nested_timing "gen_readme_aliases" "success"
}

generate_level_one_vars_and_aliases() {
    start_nested_timing "gen_level_one"
    log "lvl" "Generating top-level directory aliases"

    # Single timer for directory processing
    start_nested_timing "process_directories"
    for dir in "$LAB_DIR"/*; do
        if [[ -d "$dir" ]]; then
            base=$(basename "$dir")
            if [[ ${#base} -eq 3 ]]; then
                log "lvl" "Processing directory: $base"
                var_name="${base^^}_DIR"
                dir_path=$(realpath "$dir")
                if [[ -z "${!var_name:-}" ]]; then
                    declare -g "$var_name=$dir_path"
                fi
                alias "d-$base=cd $dir_path"
                echo "alias d-$base='cd \"$dir_path\"'" >> "$CFG_ALI_DIR/dyn"
                log "lvl" "Created alias: d-$base -> cd $dir_path"
            fi
        fi
    done
    end_nested_timing "process_directories" "success"

    end_nested_timing "gen_level_one" "success"
}

# Improved level two arrays generation with error handling
generate_level_two_arrays() {
    start_nested_timing "gen_level_two"
    log "lvl" "Generating level two arrays"

    local success_count=0
    for folder in "${GENERATION_FOLDERS[@]}"; do
        start_nested_timing "process_folder_${folder}"
        local dir_path="$LAB_DIR/$folder"
        log "lvl" "Processing folder: $folder, path: $dir_path"

        if [[ ! -d "$dir_path" ]]; then
            log "lvl" "Directory not found: $dir_path"
            error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
            end_nested_timing "process_folder_${folder}" "error"
            continue
        fi

        # Sanitize array name to be a valid Bash variable (replace / with _)
        local array_name="${folder//\//_}_files"
        local files=()

        log "lvl" "Searching for files in $dir_path"
        while IFS= read -r -d '' found_file_path; do
            local name_without_ext=$(basename "$found_file_path")
            files+=("$name_without_ext")
            log "lvl" "Added file to $array_name: $name_without_ext"
        done < <(find "$dir_path" -maxdepth 1 -type f \( -name "*" ! -name ".*" \) -print0 2>/dev/null)

        if ((${#files[@]} > 0)); then
            log "lvl" "Creating array $array_name"
            local unique_files=($(printf "%s\n" "${files[@]}" | sort -u))
            eval "declare -ga $array_name=(${unique_files[*]})"
            log "lvl" "Created array $array_name with values: ${!array_name[*]}"
            ((success_count++))
        else
            log "lvl" "No files found in directory: $dir_path"
            error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
        fi

        end_nested_timing "process_folder_${folder}" "success"
    done

    if ((success_count == 0)); then
        error_handler "$LINENO" "${ERROR_CODES[GENERAL_ERROR]}" "false"
    fi

    end_nested_timing "gen_level_two" "success"
}

# Improved alias generation with comprehensive error handling and logging
generate_aliases() {
    local alias_type=$1
    local directory=$2
    shift 2
    local files_to_alias=("$@") # Renamed for clarity

    start_nested_timing "gen_aliases_${alias_type}"
    log "lvl" "Generating ${alias_type} aliases"

    # Input validation
    if [[ -z "$directory" ]]; then
        log "lvl" "Error: Empty directory provided"
        error_handler "$LINENO" "${ERROR_CODES[CONFIG_ERROR]}" "false"
        end_nested_timing "gen_aliases_${alias_type}" "error"
        return 1
    fi

    if [[ ! -d "$directory" ]]; then
        log "lvl" "Error: Directory does not exist: $directory"
        error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
        end_nested_timing "gen_aliases_${alias_type}" "error"
        return 1
    fi

    if ((${#files_to_alias[@]} == 0)); then
        log "lvl" "Warning: No files provided for processing"
        # Consider if this should be an error or just a warning leading to no aliases.
        # Original code treated it as an error for the timing block.
        error_handler "$LINENO" "${ERROR_CODES[CONFIG_ERROR]}" "false"
        end_nested_timing "gen_aliases_${alias_type}" "error"
        return 1
    fi

    log "lvl" "Directory: $directory, Files count: ${#files_to_alias[@]}"
    local folder_name=$(basename "$directory" | tr '[:upper:]' '[:lower:]')
    log "lvl" "Using folder name: $folder_name"

    local success_count=0

    # Get all files in the directory once to avoid calling find in a loop
    local all_files_in_dir=()
    if [[ -d "$directory" ]]; then # Ensure directory exists before find
        while IFS= read -r -d '' f_path; do
            all_files_in_dir+=("$f_path")
        done < <(find "$directory" -maxdepth 1 -type f -print0 2>/dev/null)
    fi

    # Process all aliases under single timer
    for file_base_name in "${files_to_alias[@]}"; do # file_base_name is without extension from generate_level_two_arrays
        log "lvl" "Attempting to create alias for base name: $file_base_name in directory $directory"
        local found_file_path=""

        for path_in_dir in "${all_files_in_dir[@]}"; do
            local current_filename_in_dir=$(basename "$path_in_dir")
            # Check if current_filename_in_dir matches file_base_name or file_base_name.any_extension
            if [[ "$current_filename_in_dir" == "$file_base_name" || "$current_filename_in_dir" == "$file_base_name".* ]]; then
                found_file_path="$path_in_dir"
                break # Found the first match, equivalent to original | head -n 1
            fi
        done

        if [[ -n "$found_file_path" ]]; then
            log "lvl" "Found file: $found_file_path for base name $file_base_name"

            local actual_filename_with_ext=$(basename "$found_file_path")
            local ext=""
            # Check if the actual found file has an extension
            if [[ "$actual_filename_with_ext" =~ \. ]]; then
                ext="${actual_filename_with_ext##*.}"
            fi

            local display_name
            # short_display_name uses the input file_base_name (which has no extension)
            local short_display_name="${folder_name}.${file_base_name}"

            if [[ -n "$ext" ]]; then
                # display_name uses the input file_base_name and the actual extension of the found file
                display_name="${folder_name}.${file_base_name}.${ext}"
            else
                # No extension on found file, display_name is same as short_display_name
                display_name="${short_display_name}"
            fi

            local alias_prefix=""
            case "$alias_type" in
                "bash")
                    # For bash, only create alias if it's a .sh file or has execute permission
                    if [[ "$ext" == "sh" || "$ext" == "bash" ]] || [[ -x "$found_file_path" ]]; then
                        alias_prefix="b."
                    fi
                    ;;
                "cat") alias_prefix="c." ;;
                "vim") alias_prefix="v." ;;
            esac

            if [[ -n "$alias_prefix" ]]; then
                # Create alias with display_name (includes actual extension if present)
                alias "${alias_prefix}${display_name}=${alias_type} ${found_file_path}"
                echo "alias ${alias_prefix}${display_name}='${alias_type} \"${found_file_path}\"'" >> "$CFG_ALI_DIR/dyn"
                log "lvl" "Created alias: ${alias_prefix}${display_name} -> ${alias_type} ${found_file_path}"

                # Create additional short alias (without extension part) if it's bash and there was an extension
                if [[ "$alias_type" == "bash" && -n "$ext" && "$display_name" != "$short_display_name" ]]; then
                    alias "${alias_prefix}${short_display_name}=${alias_type} ${found_file_path}"
                    echo "alias ${alias_prefix}${short_display_name}='${alias_type} \"${found_file_path}\"'" >> "$CFG_ALI_DIR/dyn"
                    log "lvl" "Created additional short alias: ${alias_prefix}${short_display_name} -> ${alias_type} ${found_file_path}"
                fi
                ((success_count++))
            fi
        else
            log "lvl" "No matching file found for base name: $file_base_name in $directory"
            # Original code called error_handler here, but it might be too noisy if some files are expected not to exist.
            # For consistency with original, keeping it:
            error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
        fi
    done

    if ((success_count == 0)); then
        log "lvl" "Warning: No aliases were created for ${alias_type} in ${directory}"
        # Original code returned 1 and set error status for timing.
        # Depending on desired behavior, this could be a warning or an error.
        # If it's an error if NO aliases are made for a given call:
        error_handler "$LINENO" "${ERROR_CODES[GENERAL_ERROR]}" "false" # Or a more specific code
        end_nested_timing "gen_aliases_${alias_type}" "error"
        return 1
    fi

    log "lvl" "Successfully created ${success_count} ${alias_type} aliases for ${directory}"
    end_nested_timing "gen_aliases_${alias_type}" "success"
    return 0
}

# Main entry point function with cleaner timing structure
set_dynamic() {
    start_timer "set_dynamic"
    log "lvl" "Setting up Navigation"

    # Initialize the dyn file
    echo "# Dynamically generated aliases by set_dynamic on $(date)" > "$CFG_ALI_DIR/dyn"
    echo "# Version: 1.0.0" >> "$CFG_ALI_DIR/dyn"
    echo "" >> "$CFG_ALI_DIR/dyn" # Add an empty line for spacing

    # Group all readme operations
    echo "# --- Readme Aliases ---" >> "$CFG_ALI_DIR/dyn"
    start_nested_timing "readme_processing"
    generate_readme_aliases
    end_nested_timing "readme_processing" "success"
    echo "" >> "$CFG_ALI_DIR/dyn"

    # Group all level one operations
    echo "# --- Level One Directory Aliases ---" >> "$CFG_ALI_DIR/dyn"
    start_nested_timing "level_one_processing"
    generate_level_one_vars_and_aliases
    end_nested_timing "level_one_processing" "success"
    echo "" >> "$CFG_ALI_DIR/dyn"

    # Group all level two operations (arrays are generated, not aliases directly written here)
    start_nested_timing "level_two_processing"
    generate_level_two_arrays
    end_nested_timing "level_two_processing" "success"
    # No specific alias group comment here as generate_level_two_arrays populates arrays used by generate_aliases

    # Group all alias generation
    start_nested_timing "alias_processing"
    log "lvl" "Generating all aliases"

    echo "# --- Environment File Aliases (cfg/env) ---" >> "$CFG_ALI_DIR/dyn"
    start_nested_timing "env_aliases"
    generate_aliases "cat" "$CFG_ENV_DIR" "${cfg_env_files[@]}"
    generate_aliases "vim" "$CFG_ENV_DIR" "${cfg_env_files[@]}"
    end_nested_timing "env_aliases" "success"
    echo "" >> "$CFG_ALI_DIR/dyn"

    echo "# --- Function Library Aliases (lib/dep) ---" >> "$CFG_ALI_DIR/dyn"
    start_nested_timing "fun_aliases"
    generate_aliases "cat" "$LIB_DEP_DIR" "${lib_dep_files[@]}"
    generate_aliases "vim" "$LIB_DEP_DIR" "${lib_dep_files[@]}"
    end_nested_timing "fun_aliases" "success"
    echo "" >> "$CFG_ALI_DIR/dyn"

    echo "# --- Set Script Aliases (src/set) ---" >> "$CFG_ALI_DIR/dyn"
    start_nested_timing "gem_aliases"
    generate_aliases "cat" "$SRC_SET_DIR" "${src_set_files[@]}"
    generate_aliases "vim" "$SRC_SET_DIR" "${src_set_files[@]}"
    generate_aliases "bash" "$SRC_SET_DIR" "${src_set_files[@]}"
    end_nested_timing "gem_aliases" "success"
    echo "" >> "$CFG_ALI_DIR/dyn"

    end_nested_timing "alias_processing" "success"

    end_timer "set_dynamic" "success"
}

