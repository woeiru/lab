#!/bin/bash
# # -----------------------------------------------------------------------------
# Module: Verification
#------------------------------------------------------------
# Purpose:     Provide verification capabilities for modules, paths, functions, and dependencies.
# File:        lib/core/ver
#
# Description: This module offers a suite of functions to verify the integrity and
#              existence of various system components, including file paths,
#              variables, modules, and function dependencies. It includes a debug
#              logging helper.
#
# Dependencies: Relies on 'ric' for LOG_DEBUG_FILE, BASE_DIR, DEBUG_VERBOSITY, CONS_LOADED.
#               Uses 'mdc' for MODULE_VARS, MODULE_PATHS (via init_module_requirements).
#               Uses 'rdc' for FUNCTION_DEPENDENCIES.
#
# Usage:       Sourced by scripts and modules that require validation checks.
#              Functions like `verify_path`, `verify_var`, `verify_module`, and
#              `verify_function_dependencies` are called as needed.
#              `init_verification` can be used to set up initial checks.
#
# Notes:       The `debug_log` function provides verbose logging controlled by
#              DEBUG_VERBOSITY. `essential_check` verifies critical system variables
#              and paths. Assumes `init_module_requirements` is available from mdc.
# -----------------------------------------------------------------------------
#
# Debug logging helper - uses existing LOG_DEBUG_FILE from ruc
debug_log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local source="${2:-${FUNCNAME[1]:-main}}"
    local level="${3:-1}" # Default verbosity level if not provided by caller
    
    # Ensure DEBUG_VERBOSITY is available, defaulting to 1 if not set (though init should set it)
    local current_verbosity=${DEBUG_VERBOSITY:-1}

    # Default log file if not set
    local LOG_DEBUG_FILE="${LOG_DEBUG_FILE:-${BASE_DIR}/.log/debug.log}"
    
    # Create the directory if it doesn't exist (for file logging)
    mkdir -p "$(dirname "$LOG_DEBUG_FILE")" 2>/dev/null
    
    # Always log to file
    printf "[DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "${LOG_DEBUG_FILE}"

    # Only output to stderr if verbosity level is sufficient
    if (( current_verbosity >= level )); then
        printf "[VER-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >&2 # Corrected: Added printf to stderr
    fi
}

###########################################
# Path and Variable Verification
###########################################

verify_path() {
    local path="$1"
    local type="$2"
    local create="${3:-false}"
    local verbosity="${4:-2}" # Default verbosity level of 2

    debug_log "Verifying path: $path (type: $type, create: $create)" "verify_path" $verbosity

    [[ -z "$path" ]] && {
        (( DEBUG_VERBOSITY >= 1 )) && echo "Empty path provided" >&2
        return 1
    }

    case "$type" in
        "dir")
            if [[ ! -d "$path" ]]; then
                if [[ "$create" == "true" ]]; then
                    mkdir -p "$path" || {
                        echo "Failed to create directory: $path" >&2
                        return 1
                    }
                    debug_log "Created directory: $path"
                else
                    echo "Directory does not exist: $path" >&2
                    return 1
                fi
            fi
            ;;
        "file")
            if [[ ! -f "$path" ]]; then
                if [[ "$create" == "true" ]]; then
                    mkdir -p "$(dirname "$path")" || {
                        echo "Failed to create parent directory for: $path" >&2
                        return 1
                    }
                    touch "$path" || {
                        echo "Failed to create file: $path" >&2
                        return 1
                    }
                    debug_log "Created file: $path"
                else
                    echo "File does not exist: $path" >&2
                    return 1
                fi
            fi
            ;;
        *)
            echo "Invalid path type: $type" >&2
            return 1
            ;;
    esac

    return 0
}

verify_var() {
    local var_name="$1"
    local var_value="${!var_name}"
    local verbosity="${2:-2}" # Default verbosity level of 2

    debug_log "Verifying variable: $var_name" "verify_var" $verbosity

    if [[ -z "$var_value" ]]; then
        # Only show error at standard verbosity level
        (( DEBUG_VERBOSITY >= 1 )) && echo "Variable '$var_name' is empty or undefined" >&2
        return 1
    fi

    return 0
}

###########################################
# Module Verification
###########################################

essential_check() {
    # Set CONS_LOADED flag to indicate constants are loaded
    CONS_LOADED=1
    
    # Set default values for critical directories if not already set
    LOG_DIR="${LOG_DIR:-${BASE_DIR}/.log}"
    TMP_DIR="${TMP_DIR:-${BASE_DIR}/.tmp}"

    # Verify critical variables
    local failed=0
    for var in BASE_DIR LOG_DIR TMP_DIR; do
        if ! verify_var "$var"; then
            ((failed++))
        fi
    done

    # Ensure essential directories exist
    for dir in "$LOG_DIR" "$TMP_DIR"; do
        if ! verify_path "$dir" "dir" true; then
            ((failed++))
        fi
    done

    ((failed > 0)) && return 1
    return 0
}

verify_module() {
    local module="$1"
    debug_log "Verifying module: $module" "verify_module" 2

    # Initialize requirements if not already done
    if [[ -z "${MODULE_VARS[*]}" ]]; then
        init_module_requirements
    fi

    local failed=0

    # Verify module variables
    for var_key in "${!MODULE_VARS[@]}"; do
        if [[ $var_key == $module.* ]]; then
            local var_name="${var_key#$module.}"
            if ! verify_var "$var_name" 2>/dev/null; then
                ((failed++))
            fi
        fi
    done

    # Verify module paths
    for path_key in "${!MODULE_PATHS[@]}"; do
        if [[ $path_key == $module.* ]]; then
            local path_var="${path_key#$module.}"
            local path_spec="${MODULE_PATHS[$path_key]}"
            local type="${path_spec%%:*}"
            local create="${path_spec##*:}"

            if ! verify_path "${!path_var}" "$type" "$create"; then
                ((failed++))
            fi
        fi
    done

    ((failed > 0)) && return 1
    return 0
}

validate_module() {
    local file="$1"
    local module_name="$(basename "$file")"

    debug_log "Validating module: $module_name"

    # Check file exists and is executable
    [[ ! -f "$file" ]] && { echo "Module file does not exist: $file" >&2; return 1; }
    [[ ! -x "$file" ]] && chmod +x "$file"

    # Validate shebang
    local shebang
    read -r shebang < "$file"
    [[ "$shebang" != "#!/bin/bash" ]] && {
        echo "Invalid or missing shebang in $module_name" >&2
        return 1
    }

    return 0
}

###########################################
# Function and Dependency Verification
###########################################

verify_function_dependencies() {
    local func_name="$1"
    debug_log "Verifying function dependencies: $func_name" "verify_function_dependencies" 2

    # Get required modules for this function
    local modules="${FUNCTION_DEPENDENCIES[$func_name]}"
    [[ -z "$modules" ]] && {
        debug_log "No dependencies found for function: $func_name" "verify_function_dependencies" 1
        return 1
    }

    local failed=0
    IFS=',' read -ra MODULE_ARRAY <<< "$modules"

    for module in "${MODULE_ARRAY[@]}"; do
        if ! verify_module "$module" 2>/dev/null; then
            debug_log "ERROR: Required module '$module' not verified for function '$func_name'" "verify_function_dependencies" 1
            ((failed++))
        fi
    done

    return $((failed > 0 ? 1 : 0))
}

verify_function() {
    local func_name="$1"
    local module_path="$2"
    local verbosity="${3:-2}" # Default verbosity level of 2

    debug_log "Verifying function existence: $func_name in $module_path" "verify_function" $verbosity

    if [[ ! -f "$module_path" ]]; then
        debug_log "ERROR: Module file not found: $module_path" "verify_function" 1
        return 1
    fi

    if ! grep -q "^[[:space:]]*$func_name[[:space:]]*(" "$module_path"; then
        debug_log "ERROR: Function $func_name not found in $module_path" "verify_function" 2
        return 1
    fi

    return 0
}

# Initialize verification system
init_verification() {
    local orig_trace_setting=$(set -o | grep xtrace | cut -f2)
    set -x

    # Ensure log directory exists
    mkdir -p "$(dirname "$LOG_DEBUG_FILE")" 2>/dev/null

    # Redirect output
    exec 1> >(tee -a "$LOG_DEBUG_FILE") 2>&1

    debug_log "Starting verification initialization..."

    if ! essential_check; then
        echo "Fatal: Essential verification failed" >&2
        echo "Check $LOG_DEBUG_FILE for details" >&2
        return 1
    fi

    # Restore original trace setting
    [[ "$orig_trace_setting" == "off" ]] && set +x

    debug_log "Verification initialization completed"
    return 0
}

# Export all verification functions
export -f debug_log
export -f verify_path
export -f verify_var
export -f verify_module
export -f validate_module
export -f essential_check
export -f init_verification
export -f verify_function_dependencies
export -f verify_function
