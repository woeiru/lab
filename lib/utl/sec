#!/bin/bash
#######################################################################
# Security Utilities Library
#######################################################################
# File: /home/es/lab/lib/utl/sec
# Description: Comprehensive security management system providing secure
#              password generation, storage, and credential management
#              for lab environment infrastructure components.
#
# Author: Environment Management System
# Created: 2025-05-28
# Version: 1.0.0
# License: Lab Environment Internal Use
#
# Dependencies:
#   - /dev/urandom (for cryptographically secure random generation)
#   - tr command (for character filtering)
#   - head command (for length limiting)
#   - Standard file system utilities (mkdir, chmod, cat)
#
# Purpose:
#   Eliminates hardcoded passwords and insecure credential management
#   by providing cryptographically secure password generation and
#   storage mechanisms with proper file permissions and access controls.
#
# Key Features:
#   - Cryptographically secure password generation using /dev/urandom
#   - Configurable password length and character complexity
#   - Secure file-based password storage with 600 permissions
#   - Service-specific password management and isolation
#   - Automatic password initialization and loading
#   - Fallback mechanisms for missing or corrupted passwords
#
# Security Model:
#   - Passwords stored in protected directory (700 permissions)
#   - Individual password files have 600 permissions (owner read/write only)
#   - No passwords stored in memory longer than necessary
#   - Secure random source (/dev/urandom) for all generation
#   - Character filtering to avoid shell metacharacter issues
#
# Password Categories:
#   - Container root passwords (ct_*.pwd)
#   - Service user passwords (service_user.pwd)
#   - Database credentials (db_*.pwd)
#   - Application-specific passwords (app_*.pwd)
#
# Usage Example:
#   source /home/es/lab/lib/utl/sec
#   init_password_management "/secure/passwords"
#   password=$(generate_secure_password 20)
#   store_secure_password "DB_PASSWORD" 24
#
# File Structure:
#   /secure/passwords/
#   ├── ct_pbs.pwd          # PBS container root password
#   ├── ct_nfs.pwd          # NFS container root password
#   ├── ct_smb.pwd          # SMB container root password
#   ├── nfs_user.pwd        # NFS service user password
#   ├── smb_user.pwd        # SMB service user password
#   └── db_root.pwd         # Database root password
#
# Functions Provided:
#   - generate_secure_password: Create cryptographically secure passwords
#   - store_secure_password: Store password in variable with validation
#   - generate_service_passwords: Create all service passwords at once
#   - create_password_file: Create password file with proper permissions
#   - load_stored_passwords: Load existing passwords from storage
#   - init_password_management: Initialize complete password system
#
# Security Best Practices:
#   - Minimum 16-character passwords for user accounts
#   - Minimum 20-character passwords for system/root accounts
#   - Include special characters for increased entropy
#   - Avoid problematic characters that cause shell issues
#   - Regular password rotation (manual process)
#   - Secure backup of password directory
#
# Integration Points:
#   - Works with infrastructure utilities (/home/es/lab/lib/utl/inf)
#   - Integrates with configuration files (cfg/env/*)
#   - Compatible with deployment scripts
#   - Supports multiple password storage backends
#
# Error Handling:
#   - Graceful fallback for missing password directories
#   - Automatic password generation when files missing
#   - Validation of password file permissions
#   - Clear error messages for troubleshooting
#
# Performance Considerations:
#   - Password generation uses efficient /dev/urandom access
#   - File operations minimized for batch processing
#   - Memory cleanup for security-sensitive operations
#   - Lazy loading of passwords when needed
#
# Compliance Features:
#   - Audit trail through file timestamps
#   - Proper file permissions for security standards
#   - No cleartext passwords in logs or memory dumps
#   - Separation of concerns for different services
#######################################################################

# Security utility functions for the lab environment
# Provides secure password generation and credential management

# Generate a secure password with specified length
# Usage: generate_secure_password [length] [exclude_special]
# Default length: 16, Default special chars: included
generate_secure_password() {
    local length=${1:-16}
    local exclude_special=${2:-false}
    
    if [[ "$exclude_special" == "true" ]]; then
        # Alphanumeric only
        tr -dc 'A-Za-z0-9' < /dev/urandom | head -c "$length"
    else
        # Include special characters but avoid problematic ones
        tr -dc 'A-Za-z0-9!@#$%^&*()_+-=' < /dev/urandom | head -c "$length"
    fi
    echo
}

# Generate a secure password and store it in a variable
# Usage: store_secure_password variable_name [length] [exclude_special]
store_secure_password() {
    local var_name="$1"
    local length=${2:-16}
    local exclude_special=${3:-false}
    
    if [[ -z "$var_name" ]]; then
        echo "Error: Variable name required" >&2
        return 1
    fi
    
    local password
    password=$(generate_secure_password "$length" "$exclude_special")
    declare -g "$var_name"="$password"
}

# Generate multiple passwords for different services
# Usage: generate_service_passwords
generate_service_passwords() {
    # Container root passwords
    store_secure_password "CT_PBS_PASSWORD" 20
    store_secure_password "CT_NFS_PASSWORD" 20
    store_secure_password "CT_SMB_PASSWORD" 20
    
    # Service user passwords
    store_secure_password "NFS_USER_PASSWORD" 16
    store_secure_password "SMB_USER_PASSWORD" 16
    
    # Database passwords (if needed)
    store_secure_password "DB_ROOT_PASSWORD" 24
    store_secure_password "DB_USER_PASSWORD" 20
    
    echo "Generated secure passwords for all services"
}

# Create a password file with proper permissions
# Usage: create_password_file filename password
create_password_file() {
    local filename="$1"
    local password="$2"
    
    if [[ -z "$filename" || -z "$password" ]]; then
        echo "Error: Filename and password required" >&2
        return 1
    fi
    
    echo "$password" > "$filename"
    chmod 600 "$filename"
    echo "Password file created: $filename"
}

# Load passwords from secure storage
# Usage: load_stored_passwords [password_dir]
load_stored_passwords() {
    local password_dir="${1:-/etc/lab/passwords}"
    
    if [[ -d "$password_dir" ]]; then
        for file in "$password_dir"/*.pwd; do
            if [[ -r "$file" ]]; then
                local var_name
                var_name=$(basename "$file" .pwd | tr '[:lower:]' '[:upper:]')
                declare -g "${var_name}_PASSWORD"="$(cat "$file")"
            fi
        done
        echo "Loaded passwords from $password_dir"
    fi
}

# Initialize secure password management
# Usage: init_password_management [password_dir]
init_password_management() {
    local password_dir="${1:-/tmp/lab_passwords}"
    
    # Create password directory if it doesn't exist
    if [[ ! -d "$password_dir" ]]; then
        mkdir -p "$password_dir"
        chmod 700 "$password_dir"
    fi
    
    # Generate passwords if they don't exist
    if [[ ! -f "$password_dir/ct_root.pwd" ]]; then
        generate_service_passwords
        
        # Store passwords in files
        create_password_file "$password_dir/ct_pbs.pwd" "$CT_PBS_PASSWORD"
        create_password_file "$password_dir/ct_nfs.pwd" "$CT_NFS_PASSWORD"
        create_password_file "$password_dir/ct_smb.pwd" "$CT_SMB_PASSWORD"
        create_password_file "$password_dir/nfs_user.pwd" "$NFS_USER_PASSWORD"
        create_password_file "$password_dir/smb_user.pwd" "$SMB_USER_PASSWORD"
        
        echo "Password management initialized in $password_dir"
    else
        load_stored_passwords "$password_dir"
        echo "Loaded existing passwords from $password_dir"
    fi
}

# Make functions available when sourced
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    # Functions are loaded when sourced, no need to export
    :
fi
