#!/bin/bash
###############################################################################
# Auxiliary Utilities Library - lib/gen/aux
###############################################################################

# Prevent multiple sourcing
[[ -n "${AUX_LOADED:-}" ]] && return 0
readonly AUX_LOADED=1
# Provides function introspection, variable analysis, documentation generation,
# and system monitoring capabilities for the lab environment.
#
# Dependencies: Bash 4.0+, standard UNIX utilities (awk, grep, sed, find, wc)
#
# Main Functions:
#   aux_fun, aux_var - Overview summaries
#   aux_log, aux_dbg - Logging operations (operational & debug)
#   aux_info, aux_warn, aux_err - Convenience logging functions  
#   aux_ffl - File operations
#   aux_use, aux_tec - Help system
#   aux_val, aux_chk - Validation and checks
#   aux_cmd, aux_ask - Command execution and user interaction
#   aux_arr - Array manipulation utilities
#
# Function Categories:
#   Overview:     aux_fun, aux_var
#   Logging:      aux_log, aux_dbg, aux_info, aux_warn, aux_err
#   Utilities:    aux_ffl
#   Help System:  aux_use, aux_tec
#   Validation:   aux_val, aux_chk
#   Execution:    aux_cmd
#   Interaction:  aux_ask
#   Data:         aux_arr
#
# Usage: source lib/gen/aux
###############################################################################

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of selected functions in the script, displaying their usage, shortname, and description
# overview functions
#
aux_fun() {
    ana_laf "$FILEPATH_aux" "$@"
}

# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
#
aux_var() {
    ana_acu -o "$CONFIG_aux" "$DIR_FUN/.."
}

# Displays the usage information, shortname, and description of the calling function, helping users understand how to use it
# function usage information
#
aux_use() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Handle special cases where caller detection fails or script_file is invalid
    if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
        # Try to get the actual calling function from the call stack
        local caller_line_1=$(caller 1)
        if [[ -n "$caller_line_1" ]]; then
            local potential_function=$(echo $caller_line_1 | awk '{print $2}')
            local potential_script=$(echo $caller_line_1 | awk '{print $3}')
            
            # Only use if we have a valid script file
            if [[ -f "$potential_script" && "$potential_script" != "environment" ]]; then
                caller_function="$potential_function"
                script_file="$potential_script"
            fi
        fi
        
        # If still no valid function name or script file, provide general usage
        if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
            echo "Usage: This function displays usage information for the calling function."
            echo "Description: Extracts and displays the comment block above a function definition."
            echo "Shortname: function usage information"
            echo ""
            echo "Function should be called from within another function that has:"
            echo "  # Description comment (3 lines before function)"
            echo "  # Shortname comment (2 lines before function)"
            echo "  # Usage parameters comment (1 line before function)"
            echo "  function_name() {"
            echo "      aux_use"
            echo "  }"
            echo ""
            echo "Note: aux_use works best when called from functions defined in script files,"
            echo "      not from interactive sessions or sourced environments."
            return 0
        fi
    fi

    # Validate that script file exists and is readable
    if [[ ! -f "$script_file" || ! -r "$script_file" ]]; then
        echo "Error: Cannot read script file: $script_file"
        echo "Note: aux_use requires the calling function to be defined in a readable script file."
        return 1
    fi

    # Use more flexible grep patterns to find the function
    local function_start_line
    
    # Try different function declaration patterns
    function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}[[:space:]]*\(\)" "$script_file" | head -1 | cut -d: -f1)
    
    if [[ -z "$function_start_line" ]]; then
        # Try pattern without spaces around parentheses
        function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}\(\)" "$script_file" | head -1 | cut -d: -f1)
    fi
    
    if [[ -z "$function_start_line" ]]; then
        # Try pattern with 'function' keyword
        function_start_line=$(grep -n -E "^[[:space:]]*function[[:space:]]+${caller_function}" "$script_file" | head -1 | cut -d: -f1)
    fi

    if [[ -z "$function_start_line" ]]; then
        echo "Error: Function '$caller_function' not found in $script_file"
        echo "Note: aux_use expects functions to be declared as 'function_name()' or 'function function_name'"
        return 1
    fi

    # Validate function_start_line is a number
    if ! [[ "$function_start_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid line number detected: $function_start_line"
        return 1
    fi

    # Calculate the line numbers for comments (with bounds checking)
    local description_line=$((function_start_line - 3))
    local shortname_line=$((function_start_line - 2))
    local usage_line=$((function_start_line - 1))
    
    # Ensure we don't try to read negative line numbers
    if [[ $description_line -lt 1 ]]; then
        description_line=1
    fi
    if [[ $shortname_line -lt 1 ]]; then
        shortname_line=1
    fi
    if [[ $usage_line -lt 1 ]]; then
        usage_line=1
    fi

    # Extract comments with better error handling
    local description=$(sed -n "${description_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    local shortname=$(sed -n "${shortname_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    local usage=$(sed -n "${usage_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    
    # Remove any remaining leading/trailing whitespace
    description=$(echo "$description" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    shortname=$(echo "$shortname" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    usage=$(echo "$usage" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # Display the information with fallbacks for missing comments

    echo "Description:    ${description:-No description available}"
    echo "Shortname:      ${shortname:-No shortname available}"
    echo "Usage:          $caller_function ${usage:-<parameters not documented>}"
    
    # Additional helpful information
    echo "Location:       $script_file:$function_start_line"

}

# Displays the technical description and documentation of the calling function, reading the detailed information located below the function definition
# function technical description
#
aux_tec() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Handle special cases where caller detection fails or script_file is invalid
    if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
        echo "Error: Unable to detect calling function or script file" >&2
        return 1
    fi

    # Validate that script file exists and is readable
    if [[ ! -f "$script_file" || ! -r "$script_file" ]]; then
        echo "Error: Cannot read script file '$script_file'" >&2
        return 1
    fi

    # Use more flexible grep patterns to find the function
    local function_start_line
    
    # Try different function declaration patterns
    function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}[[:space:]]*\(\)" "$script_file" | head -1 | cut -d: -f1)
    
    if [[ -z "$function_start_line" ]]; then
        function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}\(\)" "$script_file" | head -1 | cut -d: -f1)
    fi
    
    if [[ -z "$function_start_line" ]]; then
        function_start_line=$(grep -n -E "^[[:space:]]*function[[:space:]]+${caller_function}" "$script_file" | head -1 | cut -d: -f1)
    fi

    if [[ -z "$function_start_line" ]]; then
        echo "Error: Function '$caller_function' not found in '$script_file'" >&2
        return 1
    fi

    # Validate function_start_line is a number
    if ! [[ "$function_start_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid line number detected" >&2
        return 1
    fi

    # Find the opening brace line (should be right after function declaration)
    local brace_line=$((function_start_line + 1))
    
    # Start looking for comments after the opening brace
    local current_line=$((brace_line + 1))
    local max_lines=$(wc -l < "$script_file")
    local technical_description=""
    local found_content=false
    
    # Extract technical documentation until first empty line
    while [[ $current_line -le $max_lines ]]; do
        local line_content
        line_content=$(sed -n "${current_line}p" "$script_file" 2>/dev/null)
        
        # Check if line is empty or whitespace only
        if [[ -z "$line_content" || "$line_content" =~ ^[[:space:]]*$ ]]; then
            # If we found content before this empty line, stop here
            if [[ "$found_content" == true ]]; then
                break
            fi
            # Otherwise, skip empty lines at the beginning and continue searching
            ((current_line++))
            continue
        fi
        
        # Check if line is a comment
        if [[ "$line_content" =~ ^[[:space:]]*# ]]; then
            # Found a comment, mark that we found content
            found_content=true
            
            # Extract comment text (remove leading whitespace and # symbol)
            local comment_text="${line_content#"${line_content%%[![:space:]]*}"}"  # Remove leading whitespace
            comment_text="${comment_text#\#}"  # Remove #
            comment_text="${comment_text#[[:space:]]}"  # Remove space after #
            
            # Add to technical description
            if [[ -n "$technical_description" ]]; then
                technical_description="${technical_description}\n  ${comment_text}"
            else
                technical_description="  ${comment_text}"
            fi
        else
            # If we found comments before and now hit a non-comment, non-empty line, stop
            if [[ "$found_content" == true ]]; then
                break
            fi
            # If we haven't found any comments yet and hit a non-comment line, stop searching
            break
        fi
        
        ((current_line++))
    done

    # Display the technical documentation
    echo "Function: $caller_function"
    echo "Location: $script_file:$function_start_line"
    echo ""
    
    if [[ -n "$technical_description" ]]; then
        echo -e "$technical_description"
    else
        echo "  No technical documentation found within 3 lines after function definition."
    fi
}

# Recursively processes files in a directory and its subdirectories using a specified function, allowing for additional arguments to be passed
# function folder loop
# <function> <flag> <path> [max_depth] [current_depth] [extra_args ..]
aux_ffl() {
    local fnc="$1"
    local flag="$2"
    local folder="$3"
    shift 3
    
    # Handle optional parameters
    local max_depth=10
    local current_depth=0
    local extra_args=()
    
    # Check if next argument is a number (max_depth)
    if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
        max_depth="$1"
        shift
        
        # Check if next argument is also a number (current_depth)
        if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
            current_depth="$1"
            shift
        fi
    fi
    
    # Remaining arguments are extra_args
    extra_args=("$@")
    
    # Check recursion depth to prevent infinite loops
    if [[ $current_depth -ge $max_depth ]]; then
        echo "Warning: Maximum recursion depth ($max_depth) reached for folder: $folder"
        return 1
    fi

    if [[ -d "$folder" ]]; then
        for file in "$folder"/{*,.[!.]*,..?*}; do
            # Skip if file doesn't exist (failed glob)
            [[ -e "$file" ]] || continue
            
            if [[ -f "$file" ]]; then
                line_count=$(wc -l < "$file" 2>/dev/null || echo "0")
                
                # Get the file extension
                file_extension="${file##*.}"
                
                if [[ "$file_extension" == "conf" ]]; then
                    # Count variables in .conf files
                    variable_count=$(grep -cE '^[a-zA-Z0-9_]+=' "$file" 2>/dev/null || echo "0")
                    count_type="Variables"
                    count_value=$variable_count
                else
                    # Count functions in other files
                    function_count=$(grep -cE '^[a-zA-Z0-9_-]+\(\)[[:space:]]*\{' "$file" 2>/dev/null || echo "0")
                    count_type="Functions"
                    count_value=$function_count
                fi
                
                # Get the real path of the file
                real_path=$(realpath "$file" 2>/dev/null || echo "$file")
                # Extract the filename (prefix) from the path
                filename=$(basename "$real_path")
                # Extract the prefix (part before the first dot)
                prefix="${filename%%.*}"
                # Get the directory path with the trailing slash
                dir_path=$(dirname "$real_path")/
                
                echo -e "$dir_path\e[32m$prefix\e[0m${filename#$prefix} - Contains \e[31m$line_count\e[0m Lines and \e[33m$count_value\e[0m $count_type"
                
                # Call the function with error handling
                if ! "$fnc" "$flag" "$file" "${extra_args[@]}" 2>/dev/null; then
                    echo "Warning: Function '$fnc' failed for file: $file" >&2
                fi
            elif [[ -d "$file" && "$file" != "$folder"/. && "$file" != "$folder"/.. ]]; then
                # Recursive call with incremented depth
                aux_ffl "$fnc" "$flag" "$file" "$max_depth" "$((current_depth + 1))" "${extra_args[@]}"
            fi
        done
    else
        echo "Invalid folder: $folder" >&2
        return 1
    fi
}

# Array manipulation and processing utilities
# array operations
# <operation> <array_name> [parameters...]
aux_arr() {
    local operation="$1"
    local array_name="$2"
    shift 2
    local parameters=("$@")
    
    case "$operation" in
        "length")
            local -n arr_ref="$array_name"
            echo "${#arr_ref[@]}"
            ;;
        "contains")
            local search_value="${parameters[0]}"
            local -n arr_ref="$array_name"
            for element in "${arr_ref[@]}"; do
                [[ "$element" == "$search_value" ]] && return 0
            done
            return 1
            ;;
        "add")
            local new_value="${parameters[0]}"
            local -n arr_ref="$array_name"
            arr_ref+=("$new_value")
            ;;
        "remove")
            local remove_value="${parameters[0]}"
            local -n arr_ref="$array_name"
            local new_array=()
            for element in "${arr_ref[@]}"; do
                [[ "$element" != "$remove_value" ]] && new_array+=("$element")
            done
            arr_ref=("${new_array[@]}")
            ;;
        "join")
            local delimiter="${parameters[0]:-,}"
            local -n arr_ref="$array_name"
            local result=""
            for i in "${!arr_ref[@]}"; do
                if [[ $i -eq 0 ]]; then
                    result="${arr_ref[i]}"
                else
                    result="${result}${delimiter}${arr_ref[i]}"
                fi
            done
            echo "$result"
            ;;
        "sort")
            local -n arr_ref="$array_name"
            readarray -t arr_ref < <(printf '%s\n' "${arr_ref[@]}" | sort)
            ;;
        "unique")
            local -n arr_ref="$array_name"
            readarray -t arr_ref < <(printf '%s\n' "${arr_ref[@]}" | sort -u)
            ;;
        "print")
            local -n arr_ref="$array_name"
            printf '%s\n' "${arr_ref[@]}"
            ;;
        *)
            echo "Error: Unknown array operation: $operation" >&2
            return 1
            ;;
    esac
}

# Validates input values against specified criteria without environmental dependencies
# value validation
# <value> <validation_type> [criteria]
aux_val() {
    local value="$1"
    local validation_type="$2"
    local criteria="$3"
    
    case "$validation_type" in
        "empty")
            [[ -z "$value" ]] && return 0 || return 1
            ;;
        "not_empty")
            [[ -n "$value" ]] && return 0 || return 1
            ;;
        "numeric")
            [[ "$value" =~ ^[0-9]+$ ]] && return 0 || return 1
            ;;
        "alpha")
            [[ "$value" =~ ^[a-zA-Z]+$ ]] && return 0 || return 1
            ;;
        "alphanum")
            [[ "$value" =~ ^[a-zA-Z0-9]+$ ]] && return 0 || return 1
            ;;
        "file_exists")
            [[ -f "$value" ]] && return 0 || return 1
            ;;
        "dir_exists")
            [[ -d "$value" ]] && return 0 || return 1
            ;;
        "min_length")
            [[ ${#value} -ge ${criteria:-1} ]] && return 0 || return 1
            ;;
        "max_length")
            [[ ${#value} -le ${criteria:-100} ]] && return 0 || return 1
            ;;
        "regex")
            [[ "$value" =~ $criteria ]] && return 0 || return 1
            ;;
        *)
            echo "Error: Unknown validation type: $validation_type" >&2
            return 2
            ;;
    esac
}

# Performs checks and validations with clear pass/fail results
# check validation
# <check_type> <target> [parameters]
aux_chk() {
    local check_type="$1"
    local target="$2"
    shift 2
    local parameters=("$@")
    
    case "$check_type" in
        "command")
            command -v "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "function")
            declare -f "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "variable")
            [[ -n "${!target}" ]] && return 0 || return 1
            ;;
        "permission")
            local perm="${parameters[0]:-r}"
            case "$perm" in
                "r") [[ -r "$target" ]] && return 0 || return 1 ;;
                "w") [[ -w "$target" ]] && return 0 || return 1 ;;
                "x") [[ -x "$target" ]] && return 0 || return 1 ;;
                *) return 2 ;;
            esac
            ;;
        "process")
            pgrep -f "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "network")
            ping -c 1 "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "port")
            local port="${parameters[0]:-80}"
            if command -v nc >/dev/null 2>&1; then
                nc -z "$target" "$port" >/dev/null 2>&1 && return 0 || return 1
            elif command -v timeout >/dev/null 2>&1; then
                timeout 3 bash -c "echo >/dev/tcp/$target/$port" >/dev/null 2>&1 && return 0 || return 1
            else
                return 2
            fi
            ;;
        "dir_exists")
            [[ -d "$target" ]] && return 0 || return 1
            ;;
        "file_exists")
            [[ -f "$target" ]] && return 0 || return 1
            ;;
        *)
            echo "Error: Unknown check type: $check_type" >&2
            return 2
            ;;
    esac
}

# Executes commands with error handling and result capture
# command execution
# <command> [args...]
aux_cmd() {
    local command="$1"
    shift
    local args=("$@")
    
    # Validate command exists
    if ! command -v "$command" >/dev/null 2>&1; then
        echo "Error: Command '$command' not found" >&2
        return 127
    fi
    
    # Execute command with error handling
    local output
    local exit_code
    
    if output=$("$command" "${args[@]}" 2>&1); then
        exit_code=$?
        if [[ -n "$output" ]]; then
            echo "$output"
        fi
        return $exit_code
    else
        exit_code=$?
        echo "Error: Command '$command ${args[*]}' failed with exit code $exit_code" >&2
        if [[ -n "$output" ]]; then
            echo "Output: $output" >&2
        fi
        return $exit_code
    fi
}

# Prompts user for input with validation and default values
# ask user input
# <prompt> [default_value] [validation_type]
aux_ask() {
    local prompt="$1"
    local default_value="$2" 
    local validation_type="$3"
    local user_input
    
    # Display prompt with default value if provided
    if [[ -n "$default_value" ]]; then
        echo -n "$prompt [$default_value]: "
    else
        echo -n "$prompt: "
    fi
    
    # Read user input
    read -r user_input
    
    # Use default if no input provided
    if [[ -z "$user_input" && -n "$default_value" ]]; then
        user_input="$default_value"
    fi
    
    # Validate input if validation type specified
    if [[ -n "$validation_type" ]]; then
        if ! aux_val "$user_input" "$validation_type"; then
            echo "Error: Invalid input. Please try again." >&2
            aux_ask "$prompt" "$default_value" "$validation_type"
            return $?
        fi
    fi
    
    echo "$user_input"
}

# Get color for log level
# <log_level>
aux_get_log_color() {
    local log_level="$1"
    case "${log_level,,}" in  # Convert to lowercase for comparison
        "business")     echo -n "$AUX_LOG_BUSINESS" ;;
        "security")     echo -n "$AUX_LOG_SECURITY" ;;
        "audit")        echo -n "$AUX_LOG_AUDIT" ;;
        "performance")  echo -n "$AUX_LOG_PERFORMANCE" ;;
        "info")         echo -n "$AUX_LOG_INFO" ;;
        "warn")         echo -n "$AUX_LOG_WARN" ;;
        "error")        echo -n "$AUX_LOG_ERROR" ;;
        *)              echo -n "$AUX_LOG_INFO" ;;  # Default to info color
    esac
}

# General purpose logging function for operational messages with explicit log levels and cluster support
# operational log
# <log_level> <message> [context_data]
aux_log() {
    # USE CASES:
    #   - Service start/stop messages
    #   - Authentication events  
    #   - Configuration changes
    #   - Error conditions
    #   - Performance metrics
    #   - User actions
    #   - Production monitoring
    #   - Important operational events that should always be logged
    # 
    # CHARACTERISTICS:
    #   - Requires explicit log level (INFO, WARN, ERROR, etc.)
    #   - No automatic function context (you specify what you're logging)
    #   - Always logs if main logging system is available
    #   - Suitable for production environments
    #   - Goes to operational logs (aux_operational.log)
    #   - Supports structured output formats for cluster aggregation
    #
    # EXAMPLES:
    #   aux_log "INFO" "User authentication successful for user: $username"
    #   aux_log "ERROR" "Database connection failed"
    #   aux_log "WARN" "Configuration file missing, using defaults"
    #   aux_log "AUDIT" "User $user performed action $action" "user_id=$user,action=$action"
    
    local log_level="$1"
    local message="$2"
    local context_data="${3:-}"
    
    # Validate parameters
    if [[ -z "$log_level" || -z "$message" ]]; then
        echo "Error: aux_log requires both log_level and message parameters" >&2
        return 1
    fi
    
    # Generate structured metadata
    local timestamp
    printf -v timestamp '%(%Y-%m-%dT%H:%M:%S)T' -1
    local timestamp_epoch=$(date +%s)
    
    # Cluster and service context
    local cluster_metadata
    cluster_metadata=$(aux_get_cluster_metadata)
    
    # Choose output format based on AUX_LOG_FORMAT
    case "${AUX_LOG_FORMAT:-human}" in
        "json")
            local json_log
            json_log=$(aux_format_json_log "$timestamp" "${log_level,,}" "$message" "" "$cluster_metadata" "$context_data" "operational")
            echo "$json_log"
            
            # File output
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                echo "$json_log" >> "${LOG_DIR}/aux_operational.jsonl"
            fi
            ;;
        "csv")
            local csv_log
            csv_log=$(aux_format_csv_log "$timestamp" "${log_level,,}" "$message" "" "$cluster_metadata" "$context_data")
            echo "$csv_log"
            
            # File output with header if new file
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                if [[ ! -f "${LOG_DIR}/aux_operational.csv" ]]; then
                    echo "timestamp,level,message,function,node_id,cluster_id,service,context" >> "${LOG_DIR}/aux_operational.csv"
                fi
                echo "$csv_log" >> "${LOG_DIR}/aux_operational.csv"
            fi
            ;;
        "kv"|"keyvalue")
            local kv_log="timestamp=$timestamp level=${log_level,,} message=\"$message\" type=operational"
            [[ -n "$cluster_metadata" ]] && kv_log="$kv_log $cluster_metadata"
            [[ -n "$context_data" ]] && kv_log="$kv_log $context_data"
            echo "$kv_log"
            
            # File output
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                echo "$kv_log" >> "${LOG_DIR}/aux_operational.log"
            fi
            ;;
        "human"|*)
            # Enhanced human-readable format with colors (independent of main logging system)
            local log_color
            log_color=$(aux_get_log_color "$log_level")
            local formatted_message="[$timestamp] ${log_color}[${log_level,,}]${AUX_LOG_NC} $message"
            [[ -n "$context_data" ]] && formatted_message="$formatted_message [$context_data]"
            echo "$formatted_message"
            
            # Also log to file if LOG_DIR is available (without colors for file)
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                local file_message="[$timestamp] [${log_level,,}] $message"
                [[ -n "$context_data" ]] && file_message="$file_message [$context_data]"
                echo "$file_message" >> "${LOG_DIR}/aux_operational.log"
            fi
            ;;
    esac
}

# Development/debug logging with automatic function context and timestamp
# debug log
# <message> [level]
aux_dbg() {
    # USE CASES:
    #   - Development debugging and troubleshooting
    #   - Function entry/exit tracing
    #   - Variable value inspection
    #   - Control flow verification
    #   - Performance investigation
    #   - Error condition analysis
    #   - Development-time diagnostics
    #   - Temporary debugging during code development
    # 
    # CHARACTERISTICS:
    #   - Automatically captures calling function name from call stack
    #   - Auto-generates timestamp for each message
    #   - Integrates with existing lo1 logging system and verbosity controls
    #   - Output controlled by MASTER_TERMINAL_VERBOSITY and logging state
    #   - Optional log level parameter (defaults to DEBUG)
    #   - Sends to stderr for terminal output, log files for persistence
    #   - Suitable for development/debugging environments
    #   - Goes to debug logs (aux_debug.log) when available
    #
    # EXAMPLES:
    #   aux_dbg "Starting configuration validation"
    #   aux_dbg "Found $count items in array" "INFO"
    #   aux_dbg "Variable value: user=$username, status=$status"
    #   aux_dbg "Entering error handling branch" "WARN"
    
    local message="$1"
    local level="${2:-DEBUG}"
    
    # Validate message parameter
    if [[ -z "$message" ]]; then
        echo "Error: aux_dbg requires a message parameter" >&2
        return 1
    fi
    
    # Get the calling function name from the call stack
    local caller_function="${FUNCNAME[1]:-main}"
    local timestamp
    printf -v timestamp '%(%Y-%m-%d %H:%M:%S)T' -1
    
    # Check if we should output debug messages
    # Independent auxiliary logging system (no dependency on main logging)
    local should_output=false
    
    # Use environment variables for auxiliary debug output control
    if [[ "${AUX_DEBUG_ENABLED:-1}" == "1" && "${MASTER_TERMINAL_VERBOSITY:-off}" == "on" ]]; then
        should_output=true
    fi
    
    # Capture additional context for structured logging
    local script_file="${BASH_SOURCE[1]:-unknown}"
    local line_number="${BASH_LINENO[0]:-0}"
    local cluster_metadata
    cluster_metadata=$(aux_get_cluster_metadata)
    
    # Choose output format based on AUX_LOG_FORMAT
    case "${AUX_LOG_FORMAT:-human}" in
        "json")
            local json_log
            json_log=$(aux_format_json_log "$timestamp" "${level,,}" "$message" "$caller_function" "$cluster_metadata" "" "debug")
            
            # Output to appropriate channels
            if [[ "$should_output" == "true" ]]; then
                echo "$json_log" >&2
            fi
            
            # File logging (independent of main logging system)
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                echo "$json_log" >> "${LOG_DIR}/aux_debug.jsonl"
            fi
            ;;
        "csv")
            local csv_log
            csv_log=$(aux_format_csv_log "$timestamp" "${level,,}" "$message" "$caller_function" "$cluster_metadata" "")
            
            # Output to appropriate channels
            if [[ "$should_output" == "true" ]]; then
                echo "$csv_log" >&2
            fi
            
            # File logging with header
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                if [[ ! -f "${LOG_DIR}/aux_debug.csv" ]]; then
                    echo "timestamp,level,message,function,node_id,cluster_id,service,context" >> "${LOG_DIR}/aux_debug.csv"
                fi
                echo "$csv_log" >> "${LOG_DIR}/aux_debug.csv"
            fi
            ;;
        "kv"|"keyvalue")
            local kv_log="timestamp=$timestamp level=${level,,} function=$caller_function message=\"$message\" type=debug"
            [[ -n "$cluster_metadata" ]] && kv_log="$kv_log $cluster_metadata"
            
            # Output to appropriate channels
            if [[ "$should_output" == "true" ]]; then
                echo "$kv_log" >&2
            fi
            
            # File logging (independent of main logging system)
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                echo "$kv_log" >> "${LOG_DIR}/aux_debug.log"
            fi
            ;;
        "human"|*)
            # Format the debug message with function context and colors
            local log_color
            log_color=$(aux_get_log_color "$level")
            local formatted_message="${log_color}[${level,,}]${AUX_LOG_NC} $timestamp - [$caller_function] $message"
            
            # Output to appropriate channels (with colors)
            if [[ "$should_output" == "true" ]]; then
                echo "$formatted_message" >&2
            fi
            
            # Always log to file (independent of main logging system, without colors)
            if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
                local file_message="[${level,,}] $timestamp - [$caller_function] $message"
                echo "$file_message" >> "${LOG_DIR}/aux_debug.log"
            fi
            ;;
    esac
}

# Cluster metadata collection for distributed logging
# cluster metadata
#
aux_get_cluster_metadata() {
    # Collect cluster and service context information
    local metadata=""
    
    # Node identification
    local node_id="${NODE_ID:-${HOSTNAME:-$(hostname 2>/dev/null || echo 'unknown')}}"
    local cluster_id="${CLUSTER_ID:-${CLUSTER_NAME:-$(echo ${node_id} | cut -d'-' -f1-2 2>/dev/null || echo 'default')}}"
    
    # Service context
    local service_name="${SERVICE_NAME:-${0##*/}}"
    local pod_name="${POD_NAME:-${HOSTNAME:-unknown}}"
    local namespace="${NAMESPACE:-default}"
    
    # Build metadata string
    metadata="node_id=$node_id cluster_id=$cluster_id service=$service_name"
    [[ -n "${pod_name}" && "${pod_name}" != "unknown" ]] && metadata="$metadata pod=$pod_name"
    [[ -n "${namespace}" && "${namespace}" != "default" ]] && metadata="$metadata namespace=$namespace"
    [[ -n "${APP_VERSION:-}" ]] && metadata="$metadata version=$APP_VERSION"
    
    echo "$metadata"
}

# JSON log formatter for structured logging
# json log formatter
# <timestamp> <level> <message> <function> <cluster_metadata> <context_data> <log_type>
aux_format_json_log() {
    local timestamp="$1"
    local level="$2" 
    local message="$3"
    local function_name="$4"
    local cluster_metadata="$5"
    local context_data="$6"
    local log_type="${7:-debug}"
    
    # Escape JSON strings
    message=$(printf '%s' "$message" | sed 's/"/\\"/g')
    function_name=$(printf '%s' "$function_name" | sed 's/"/\\"/g')
    
    # Build base JSON
    local json="{\"timestamp\":\"$timestamp\",\"level\":\"$level\",\"message\":\"$message\",\"type\":\"$log_type\""
    
    # Add function if provided
    [[ -n "$function_name" ]] && json="${json},\"function\":\"$function_name\""
    
    # Add cluster metadata
    if [[ -n "$cluster_metadata" ]]; then
        # Parse key=value pairs from cluster_metadata
        local node_id=$(echo "$cluster_metadata" | grep -o 'node_id=[^[:space:]]*' | cut -d'=' -f2)
        local cluster_id=$(echo "$cluster_metadata" | grep -o 'cluster_id=[^[:space:]]*' | cut -d'=' -f2)
        local service=$(echo "$cluster_metadata" | grep -o 'service=[^[:space:]]*' | cut -d'=' -f2)
        
        [[ -n "$node_id" ]] && json="${json},\"node_id\":\"$node_id\""
        [[ -n "$cluster_id" ]] && json="${json},\"cluster_id\":\"$cluster_id\""
        [[ -n "$service" ]] && json="${json},\"service\":\"$service\""
    fi
    
    # Add context data if provided
    if [[ -n "$context_data" ]]; then
        # Simple approach: add context as a string field
        context_data=$(printf '%s' "$context_data" | sed 's/"/\\"/g')
        json="${json},\"context\":\"$context_data\""
    fi
    
    # Add process information
    json="${json},\"pid\":$$"
    [[ -n "${TRACE_ID:-}" ]] && json="${json},\"trace_id\":\"$TRACE_ID\""
    [[ -n "${REQUEST_ID:-}" ]] && json="${json},\"request_id\":\"$REQUEST_ID\""
    
    json="${json}}"
    echo "$json"
}

# CSV log formatter for structured logging
# csv log formatter  
# <timestamp> <level> <message> <function> <cluster_metadata> <context_data>
aux_format_csv_log() {
    local timestamp="$1"
    local level="$2"
    local message="$3" 
    local function_name="$4"
    local cluster_metadata="$5"
    local context_data="$6"
    
    # Escape CSV values (quote and escape internal quotes)
    message=$(printf '%s' "$message" | sed 's/"/""/g')
    function_name=$(printf '%s' "$function_name" | sed 's/"/""/g')
    context_data=$(printf '%s' "$context_data" | sed 's/"/""/g')
    
    # Extract cluster info
    local node_id=$(echo "$cluster_metadata" | grep -o 'node_id=[^[:space:]]*' | cut -d'=' -f2)
    local cluster_id=$(echo "$cluster_metadata" | grep -o 'cluster_id=[^[:space:]]*' | cut -d'=' -f2)
    local service=$(echo "$cluster_metadata" | grep -o 'service=[^[:space:]]*' | cut -d'=' -f2)
    
    # Build CSV line: timestamp,level,message,function,node_id,cluster_id,service,context
    printf '"%s","%s","%s","%s","%s","%s","%s","%s"' \
           "$timestamp" "$level" "$message" "$function_name" \
           "${node_id:-}" "${cluster_id:-}" "${service:-}" "$context_data"
}

# Tracing utilities for correlation across distributed systems
# start trace
# [trace_name]
aux_start_trace() {
    local trace_name="${1:-trace}"
    export TRACE_ID="${trace_name}_$(date +%s)_$$_$(shuf -i 1000-9999 -n 1 2>/dev/null || echo $RANDOM)"
    export REQUEST_ID="req_$(date +%s%N 2>/dev/null || date +%s)_$$"
    aux_dbg "Started trace: $TRACE_ID" "TRACE"
}

# end trace
#
aux_end_trace() {
    if [[ -n "${TRACE_ID:-}" ]]; then
        aux_dbg "Ended trace: $TRACE_ID" "TRACE"
        unset TRACE_ID REQUEST_ID
    fi
}

# Metrics integration for performance monitoring
# log metric
# <metric_name> <metric_value> [metric_type]
aux_metric() {
    local metric_name="$1"
    local metric_value="$2"
    local metric_type="${3:-counter}"
    
    # Log as structured data
    aux_dbg "Metric: $metric_name=$metric_value (type:$metric_type)" "METRIC"
    
    # Also send to metrics system if available
    if [[ -n "${METRICS_ENDPOINT:-}" ]] && command -v curl >/dev/null 2>&1; then
        curl -X POST "${METRICS_ENDPOINT}/metrics" \
             -H "Content-Type: application/json" \
             -d "{\"name\":\"$metric_name\",\"value\":$metric_value,\"type\":\"$metric_type\",\"service\":\"${SERVICE_NAME:-unknown}\",\"timestamp\":$(date +%s)}" \
             >/dev/null 2>&1 &
    fi
}

# Color definitions for log levels (nice color palette)
readonly AUX_LOG_NC=$(printf '\033[0m')         # No Color / Reset
readonly AUX_LOG_BUSINESS=$(printf '\033[38;5;99m')      # Purple - business logic
readonly AUX_LOG_SECURITY=$(printf '\033[38;5;196m')     # Bright Red - security alerts
readonly AUX_LOG_AUDIT=$(printf '\033[38;5;208m')        # Orange - audit trails  
readonly AUX_LOG_PERFORMANCE=$(printf '\033[38;5;45m')   # Bright Cyan - performance
readonly AUX_LOG_INFO=$(printf '\033[38;5;39m')          # Blue - info messages
readonly AUX_LOG_WARN=$(printf '\033[38;5;220m')         # Yellow - warnings
readonly AUX_LOG_ERROR=$(printf '\033[38;5;160m')        # Dark Red - errors

# Specialized logging functions for different operational contexts
# business logic log
# <message> [context_data]
aux_business() {
    aux_log "business" "$1" "${2:-}"
}

# security event log
# <message> [context_data]  
aux_security() {
    aux_log "security" "$1" "${2:-}"
}

# audit trail log
# <message> [context_data]
aux_audit() {
    aux_log "audit" "$1" "${2:-}"
}

# performance event log
# <message> [context_data]
aux_perf() {
    aux_log "performance" "$1" "${2:-}"
}

# Convenience logging functions using aux_log for operational logging
# info level log
# <message> [context_data]
aux_info() {
    aux_log "info" "$1" "${2:-}"
}

# warning level log
# <message> [context_data]
aux_warn() {
    aux_log "warn" "$1" "${2:-}"
}

# error level log
# <message> [context_data]
aux_err() {
    aux_log "error" "$1" "${2:-}"
}