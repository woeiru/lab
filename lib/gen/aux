#!/bin/bash
###############################################################################
# Auxiliary Utilities Library - lib/gen/aux
###############################################################################
# Provides function introspection, variable analysis, documentation generation,
# and system monitoring capabilities for the lab environment.
#
# Dependencies: Bash 4.0+, standard UNIX utilities (awk, grep, sed, find, wc)
#
# Main Functions:
#   aux_fun, aux_var - Overview summaries
#   aux_log, aux_ffl - Utility operations  
#   aux_use, aux_tec - Help system
#
# Usage: source lib/gen/aux
###############################################################################

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of selected functions in the script, displaying their usage, shortname, and description
# overview functions
#
aux_fun() {
    ana_laf "$FILEPATH_aux" "$@"
}

# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
#
aux_var() {
    ana_acu -o "$CONFIG_aux" "$DIR_FUN/.."
}

# Logging function. Prints a timestamped log message with a log level
# log
# <log_level> <message>
aux_log() {
    local log_level="$1"
    local message="$2"
    
    # Enhanced version with integration to main logging system
    if type -t log &>/dev/null; then
        # If main logging system is available, use it for consistency
        case "$log_level" in
            ERROR|WARN|WARNING)
                log "lvl" "[$log_level] $message"
                ;;
            *)
                log "lvl" "[$log_level] $message"
                ;;
        esac
    else
        # Fallback to simple echo if main logging not available
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$log_level] $message"
    fi
}

# Displays the usage information, shortname, and description of the calling function, helping users understand how to use it
# function usage information
#
aux_use() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Handle special cases where caller detection fails or script_file is invalid
    if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
        # Try to get the actual calling function from the call stack
        local caller_line_1=$(caller 1)
        if [[ -n "$caller_line_1" ]]; then
            local potential_function=$(echo $caller_line_1 | awk '{print $2}')
            local potential_script=$(echo $caller_line_1 | awk '{print $3}')
            
            # Only use if we have a valid script file
            if [[ -f "$potential_script" && "$potential_script" != "environment" ]]; then
                caller_function="$potential_function"
                script_file="$potential_script"
            fi
        fi
        
        # If still no valid function name or script file, provide general usage
        if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
            echo "Usage: This function displays usage information for the calling function."
            echo "Description: Extracts and displays the comment block above a function definition."
            echo "Shortname: function usage information"
            echo ""
            echo "Function should be called from within another function that has:"
            echo "  # Description comment (3 lines before function)"
            echo "  # Shortname comment (2 lines before function)"
            echo "  # Usage parameters comment (1 line before function)"
            echo "  function_name() {"
            echo "      aux_use"
            echo "  }"
            echo ""
            echo "Note: aux_use works best when called from functions defined in script files,"
            echo "      not from interactive sessions or sourced environments."
            return 0
        fi
    fi

    # Validate that script file exists and is readable
    if [[ ! -f "$script_file" || ! -r "$script_file" ]]; then
        echo "Error: Cannot read script file: $script_file"
        echo "Note: aux_use requires the calling function to be defined in a readable script file."
        return 1
    fi

    # Use more flexible grep patterns to find the function
    local function_start_line
    
    # Try different function declaration patterns
    function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}[[:space:]]*\(\)" "$script_file" | head -1 | cut -d: -f1)
    
    if [[ -z "$function_start_line" ]]; then
        # Try pattern without spaces around parentheses
        function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}\(\)" "$script_file" | head -1 | cut -d: -f1)
    fi
    
    if [[ -z "$function_start_line" ]]; then
        # Try pattern with 'function' keyword
        function_start_line=$(grep -n -E "^[[:space:]]*function[[:space:]]+${caller_function}" "$script_file" | head -1 | cut -d: -f1)
    fi

    if [[ -z "$function_start_line" ]]; then
        echo "Error: Function '$caller_function' not found in $script_file"
        echo "Note: aux_use expects functions to be declared as 'function_name()' or 'function function_name'"
        return 1
    fi

    # Validate function_start_line is a number
    if ! [[ "$function_start_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid line number detected: $function_start_line"
        return 1
    fi

    # Calculate the line numbers for comments (with bounds checking)
    local description_line=$((function_start_line - 3))
    local shortname_line=$((function_start_line - 2))
    local usage_line=$((function_start_line - 1))
    
    # Ensure we don't try to read negative line numbers
    if [[ $description_line -lt 1 ]]; then
        description_line=1
    fi
    if [[ $shortname_line -lt 1 ]]; then
        shortname_line=1
    fi
    if [[ $usage_line -lt 1 ]]; then
        usage_line=1
    fi

    # Extract comments with better error handling
    local description=$(sed -n "${description_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    local shortname=$(sed -n "${shortname_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    local usage=$(sed -n "${usage_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    
    # Remove any remaining leading/trailing whitespace
    description=$(echo "$description" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    shortname=$(echo "$shortname" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    usage=$(echo "$usage" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # Display the information with fallbacks for missing comments

    echo "Description:    ${description:-No description available}"
    echo "Shortname:      ${shortname:-No shortname available}"
    echo "Usage:          $caller_function ${usage:-<parameters not documented>}"
    
    # Additional helpful information
    echo "Location:       $script_file:$function_start_line"

}

# Displays the technical description and documentation of the calling function, reading the detailed information located below the function definition
# function technical description
#
aux_tec() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Handle special cases where caller detection fails or script_file is invalid
    if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
        echo "Error: Unable to detect calling function or script file" >&2
        return 1
    fi

    # Validate that script file exists and is readable
    if [[ ! -f "$script_file" || ! -r "$script_file" ]]; then
        echo "Error: Cannot read script file '$script_file'" >&2
        return 1
    fi

    # Use more flexible grep patterns to find the function
    local function_start_line
    
    # Try different function declaration patterns
    function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}[[:space:]]*\(\)" "$script_file" | head -1 | cut -d: -f1)
    
    if [[ -z "$function_start_line" ]]; then
        function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}\(\)" "$script_file" | head -1 | cut -d: -f1)
    fi
    
    if [[ -z "$function_start_line" ]]; then
        function_start_line=$(grep -n -E "^[[:space:]]*function[[:space:]]+${caller_function}" "$script_file" | head -1 | cut -d: -f1)
    fi

    if [[ -z "$function_start_line" ]]; then
        echo "Error: Function '$caller_function' not found in '$script_file'" >&2
        return 1
    fi

    # Validate function_start_line is a number
    if ! [[ "$function_start_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid line number detected" >&2
        return 1
    fi

    # Find the opening brace line (should be right after function declaration)
    local brace_line=$((function_start_line + 1))
    
    # Start looking for comments after the opening brace
    local current_line=$((brace_line + 1))
    local max_lines=$(wc -l < "$script_file")
    local technical_description=""
    local found_content=false
    
    # Extract technical documentation until first empty line
    while [[ $current_line -le $max_lines ]]; do
        local line_content
        line_content=$(sed -n "${current_line}p" "$script_file" 2>/dev/null)
        
        # Check if line is empty or whitespace only
        if [[ -z "$line_content" || "$line_content" =~ ^[[:space:]]*$ ]]; then
            # If we found content before this empty line, stop here
            if [[ "$found_content" == true ]]; then
                break
            fi
            # Otherwise, skip empty lines at the beginning and continue searching
            ((current_line++))
            continue
        fi
        
        # Check if line is a comment
        if [[ "$line_content" =~ ^[[:space:]]*# ]]; then
            # Found a comment, mark that we found content
            found_content=true
            
            # Extract comment text (remove leading whitespace and # symbol)
            local comment_text="${line_content#"${line_content%%[![:space:]]*}"}"  # Remove leading whitespace
            comment_text="${comment_text#\#}"  # Remove #
            comment_text="${comment_text#[[:space:]]}"  # Remove space after #
            
            # Add to technical description
            if [[ -n "$technical_description" ]]; then
                technical_description="${technical_description}\n  ${comment_text}"
            else
                technical_description="  ${comment_text}"
            fi
        else
            # If we found comments before and now hit a non-comment, non-empty line, stop
            if [[ "$found_content" == true ]]; then
                break
            fi
            # If we haven't found any comments yet and hit a non-comment line, stop searching
            break
        fi
        
        ((current_line++))
    done

    # Display the technical documentation
    echo "Function: $caller_function"
    echo "Location: $script_file:$function_start_line"
    echo ""
    
    if [[ -n "$technical_description" ]]; then
        echo -e "$technical_description"
    else
        echo "  No technical documentation found within 3 lines after function definition."
    fi
}

# Recursively processes files in a directory and its subdirectories using a specified function, allowing for additional arguments to be passed
# function folder loop
# <function> <flag> <path> [max_depth] [current_depth] [extra_args ..]
aux_ffl() {
    local fnc="$1"
    local flag="$2"
    local folder="$3"
    shift 3
    
    # Handle optional parameters
    local max_depth=10
    local current_depth=0
    local extra_args=()
    
    # Check if next argument is a number (max_depth)
    if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
        max_depth="$1"
        shift
        
        # Check if next argument is also a number (current_depth)
        if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
            current_depth="$1"
            shift
        fi
    fi
    
    # Remaining arguments are extra_args
    extra_args=("$@")
    
    # Check recursion depth to prevent infinite loops
    if [[ $current_depth -ge $max_depth ]]; then
        echo "Warning: Maximum recursion depth ($max_depth) reached for folder: $folder"
        return 1
    fi

    if [[ -d "$folder" ]]; then
        for file in "$folder"/{*,.[!.]*,..?*}; do
            # Skip if file doesn't exist (failed glob)
            [[ -e "$file" ]] || continue
            
            if [[ -f "$file" ]]; then
                line_count=$(wc -l < "$file" 2>/dev/null || echo "0")
                
                # Get the file extension
                file_extension="${file##*.}"
                
                if [[ "$file_extension" == "conf" ]]; then
                    # Count variables in .conf files
                    variable_count=$(grep -cE '^[a-zA-Z0-9_]+=' "$file" 2>/dev/null || echo "0")
                    count_type="Variables"
                    count_value=$variable_count
                else
                    # Count functions in other files
                    function_count=$(grep -cE '^[a-zA-Z0-9_-]+\(\)[[:space:]]*\{' "$file" 2>/dev/null || echo "0")
                    count_type="Functions"
                    count_value=$function_count
                fi
                
                # Get the real path of the file
                real_path=$(realpath "$file" 2>/dev/null || echo "$file")
                # Extract the filename (prefix) from the path
                filename=$(basename "$real_path")
                # Extract the prefix (part before the first dot)
                prefix="${filename%%.*}"
                # Get the directory path with the trailing slash
                dir_path=$(dirname "$real_path")/
                
                echo -e "$dir_path\e[32m$prefix\e[0m${filename#$prefix} - Contains \e[31m$line_count\e[0m Lines and \e[33m$count_value\e[0m $count_type"
                
                # Call the function with error handling
                if ! "$fnc" "$flag" "$file" "${extra_args[@]}" 2>/dev/null; then
                    echo "Warning: Function '$fnc' failed for file: $file" >&2
                fi
            elif [[ -d "$file" && "$file" != "$folder"/. && "$file" != "$folder"/.. ]]; then
                # Recursive call with incremented depth
                aux_ffl "$fnc" "$flag" "$file" "$max_depth" "$((current_depth + 1))" "${extra_args[@]}"
            fi
        done
    else
        echo "Invalid folder: $folder" >&2
        return 1
    fi
}