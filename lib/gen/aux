#!/bin/bash
###############################################################################
# Auxiliary Utilities Library - lib/gen/aux
###############################################################################
# Provides function introspection, variable analysis, documentation generation,
# and system monitoring capabilities for the lab environment.
#
# Dependencies: Bash 4.0+, standard UNIX utilities (awk, grep, sed, find, wc)
#
# Main Functions:
#   aux_fun, aux_var - Overview summaries
#   aux_log, aux_dbg - Logging operations (operational & debug)
#   aux_info, aux_warn, aux_err - Convenience logging functions  
#   aux_ffl - File operations
#   aux_use, aux_tec - Help system
#   aux_val, aux_chk - Validation and checks
#   aux_cmd, aux_ask - Command execution and user interaction
#   aux_arr - Array manipulation utilities
#
# Function Categories:
#   Overview:     aux_fun, aux_var
#   Logging:      aux_log, aux_dbg, aux_info, aux_warn, aux_err
#   Utilities:    aux_ffl
#   Help System:  aux_use, aux_tec
#   Validation:   aux_val, aux_chk
#   Execution:    aux_cmd
#   Interaction:  aux_ask
#   Data:         aux_arr
#
# Usage: source lib/gen/aux
###############################################################################

# Define directory and file variables
DIR_FUN="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
FILE_FUN=$(basename "$BASH_SOURCE")
BASE_FUN="${FILE_FUN%.*}"
FILEPATH_FUN="${DIR_FUN}/${FILE_FUN}"
CONFIG_FUN="${SITE_CONFIG_FILE}"

# Dynamically create variables based on the base name
eval "FILEPATH_${BASE_FUN}=\$FILEPATH_FUN"
eval "FILE_${BASE_FUN}=\$FILE_FUN"
eval "BASE_${BASE_FUN}=\$BASE_FUN"
eval "CONFIG_${BASE_FUN}=\$CONFIG_FUN"

# Shows a summary of selected functions in the script, displaying their usage, shortname, and description
# overview functions
#
aux_fun() {
    ana_laf "$FILEPATH_aux" "$@"
}

# Displays an overview of specific variables defined in the configuration file, showing their names, values, and usage across different files
# overview variables
#
aux_var() {
    ana_acu -o "$CONFIG_aux" "$DIR_FUN/.."
}

# Displays the usage information, shortname, and description of the calling function, helping users understand how to use it
# function usage information
#
aux_use() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Handle special cases where caller detection fails or script_file is invalid
    if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
        # Try to get the actual calling function from the call stack
        local caller_line_1=$(caller 1)
        if [[ -n "$caller_line_1" ]]; then
            local potential_function=$(echo $caller_line_1 | awk '{print $2}')
            local potential_script=$(echo $caller_line_1 | awk '{print $3}')
            
            # Only use if we have a valid script file
            if [[ -f "$potential_script" && "$potential_script" != "environment" ]]; then
                caller_function="$potential_function"
                script_file="$potential_script"
            fi
        fi
        
        # If still no valid function name or script file, provide general usage
        if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
            echo "Usage: This function displays usage information for the calling function."
            echo "Description: Extracts and displays the comment block above a function definition."
            echo "Shortname: function usage information"
            echo ""
            echo "Function should be called from within another function that has:"
            echo "  # Description comment (3 lines before function)"
            echo "  # Shortname comment (2 lines before function)"
            echo "  # Usage parameters comment (1 line before function)"
            echo "  function_name() {"
            echo "      aux_use"
            echo "  }"
            echo ""
            echo "Note: aux_use works best when called from functions defined in script files,"
            echo "      not from interactive sessions or sourced environments."
            return 0
        fi
    fi

    # Validate that script file exists and is readable
    if [[ ! -f "$script_file" || ! -r "$script_file" ]]; then
        echo "Error: Cannot read script file: $script_file"
        echo "Note: aux_use requires the calling function to be defined in a readable script file."
        return 1
    fi

    # Use more flexible grep patterns to find the function
    local function_start_line
    
    # Try different function declaration patterns
    function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}[[:space:]]*\(\)" "$script_file" | head -1 | cut -d: -f1)
    
    if [[ -z "$function_start_line" ]]; then
        # Try pattern without spaces around parentheses
        function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}\(\)" "$script_file" | head -1 | cut -d: -f1)
    fi
    
    if [[ -z "$function_start_line" ]]; then
        # Try pattern with 'function' keyword
        function_start_line=$(grep -n -E "^[[:space:]]*function[[:space:]]+${caller_function}" "$script_file" | head -1 | cut -d: -f1)
    fi

    if [[ -z "$function_start_line" ]]; then
        echo "Error: Function '$caller_function' not found in $script_file"
        echo "Note: aux_use expects functions to be declared as 'function_name()' or 'function function_name'"
        return 1
    fi

    # Validate function_start_line is a number
    if ! [[ "$function_start_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid line number detected: $function_start_line"
        return 1
    fi

    # Calculate the line numbers for comments (with bounds checking)
    local description_line=$((function_start_line - 3))
    local shortname_line=$((function_start_line - 2))
    local usage_line=$((function_start_line - 1))
    
    # Ensure we don't try to read negative line numbers
    if [[ $description_line -lt 1 ]]; then
        description_line=1
    fi
    if [[ $shortname_line -lt 1 ]]; then
        shortname_line=1
    fi
    if [[ $usage_line -lt 1 ]]; then
        usage_line=1
    fi

    # Extract comments with better error handling
    local description=$(sed -n "${description_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    local shortname=$(sed -n "${shortname_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    local usage=$(sed -n "${usage_line}s/^# //p" "$script_file" 2>/dev/null || echo "")
    
    # Remove any remaining leading/trailing whitespace
    description=$(echo "$description" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    shortname=$(echo "$shortname" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    usage=$(echo "$usage" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # Display the information with fallbacks for missing comments

    echo "Description:    ${description:-No description available}"
    echo "Shortname:      ${shortname:-No shortname available}"
    echo "Usage:          $caller_function ${usage:-<parameters not documented>}"
    
    # Additional helpful information
    echo "Location:       $script_file:$function_start_line"

}

# Displays the technical description and documentation of the calling function, reading the detailed information located below the function definition
# function technical description
#
aux_tec() {
    local caller_line=$(caller 0)
    local caller_function=$(echo $caller_line | awk '{print $2}')
    local script_file="${BASH_SOURCE[1]}"

    # Handle special cases where caller detection fails or script_file is invalid
    if [[ -z "$caller_function" || "$caller_function" == "main" ]] || [[ ! -f "$script_file" || "$script_file" == "environment" ]]; then
        echo "Error: Unable to detect calling function or script file" >&2
        return 1
    fi

    # Validate that script file exists and is readable
    if [[ ! -f "$script_file" || ! -r "$script_file" ]]; then
        echo "Error: Cannot read script file '$script_file'" >&2
        return 1
    fi

    # Use more flexible grep patterns to find the function
    local function_start_line
    
    # Try different function declaration patterns
    function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}[[:space:]]*\(\)" "$script_file" | head -1 | cut -d: -f1)
    
    if [[ -z "$function_start_line" ]]; then
        function_start_line=$(grep -n -E "^[[:space:]]*${caller_function}\(\)" "$script_file" | head -1 | cut -d: -f1)
    fi
    
    if [[ -z "$function_start_line" ]]; then
        function_start_line=$(grep -n -E "^[[:space:]]*function[[:space:]]+${caller_function}" "$script_file" | head -1 | cut -d: -f1)
    fi

    if [[ -z "$function_start_line" ]]; then
        echo "Error: Function '$caller_function' not found in '$script_file'" >&2
        return 1
    fi

    # Validate function_start_line is a number
    if ! [[ "$function_start_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid line number detected" >&2
        return 1
    fi

    # Find the opening brace line (should be right after function declaration)
    local brace_line=$((function_start_line + 1))
    
    # Start looking for comments after the opening brace
    local current_line=$((brace_line + 1))
    local max_lines=$(wc -l < "$script_file")
    local technical_description=""
    local found_content=false
    
    # Extract technical documentation until first empty line
    while [[ $current_line -le $max_lines ]]; do
        local line_content
        line_content=$(sed -n "${current_line}p" "$script_file" 2>/dev/null)
        
        # Check if line is empty or whitespace only
        if [[ -z "$line_content" || "$line_content" =~ ^[[:space:]]*$ ]]; then
            # If we found content before this empty line, stop here
            if [[ "$found_content" == true ]]; then
                break
            fi
            # Otherwise, skip empty lines at the beginning and continue searching
            ((current_line++))
            continue
        fi
        
        # Check if line is a comment
        if [[ "$line_content" =~ ^[[:space:]]*# ]]; then
            # Found a comment, mark that we found content
            found_content=true
            
            # Extract comment text (remove leading whitespace and # symbol)
            local comment_text="${line_content#"${line_content%%[![:space:]]*}"}"  # Remove leading whitespace
            comment_text="${comment_text#\#}"  # Remove #
            comment_text="${comment_text#[[:space:]]}"  # Remove space after #
            
            # Add to technical description
            if [[ -n "$technical_description" ]]; then
                technical_description="${technical_description}\n  ${comment_text}"
            else
                technical_description="  ${comment_text}"
            fi
        else
            # If we found comments before and now hit a non-comment, non-empty line, stop
            if [[ "$found_content" == true ]]; then
                break
            fi
            # If we haven't found any comments yet and hit a non-comment line, stop searching
            break
        fi
        
        ((current_line++))
    done

    # Display the technical documentation
    echo "Function: $caller_function"
    echo "Location: $script_file:$function_start_line"
    echo ""
    
    if [[ -n "$technical_description" ]]; then
        echo -e "$technical_description"
    else
        echo "  No technical documentation found within 3 lines after function definition."
    fi
}

# Recursively processes files in a directory and its subdirectories using a specified function, allowing for additional arguments to be passed
# function folder loop
# <function> <flag> <path> [max_depth] [current_depth] [extra_args ..]
aux_ffl() {
    local fnc="$1"
    local flag="$2"
    local folder="$3"
    shift 3
    
    # Handle optional parameters
    local max_depth=10
    local current_depth=0
    local extra_args=()
    
    # Check if next argument is a number (max_depth)
    if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
        max_depth="$1"
        shift
        
        # Check if next argument is also a number (current_depth)
        if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
            current_depth="$1"
            shift
        fi
    fi
    
    # Remaining arguments are extra_args
    extra_args=("$@")
    
    # Check recursion depth to prevent infinite loops
    if [[ $current_depth -ge $max_depth ]]; then
        echo "Warning: Maximum recursion depth ($max_depth) reached for folder: $folder"
        return 1
    fi

    if [[ -d "$folder" ]]; then
        for file in "$folder"/{*,.[!.]*,..?*}; do
            # Skip if file doesn't exist (failed glob)
            [[ -e "$file" ]] || continue
            
            if [[ -f "$file" ]]; then
                line_count=$(wc -l < "$file" 2>/dev/null || echo "0")
                
                # Get the file extension
                file_extension="${file##*.}"
                
                if [[ "$file_extension" == "conf" ]]; then
                    # Count variables in .conf files
                    variable_count=$(grep -cE '^[a-zA-Z0-9_]+=' "$file" 2>/dev/null || echo "0")
                    count_type="Variables"
                    count_value=$variable_count
                else
                    # Count functions in other files
                    function_count=$(grep -cE '^[a-zA-Z0-9_-]+\(\)[[:space:]]*\{' "$file" 2>/dev/null || echo "0")
                    count_type="Functions"
                    count_value=$function_count
                fi
                
                # Get the real path of the file
                real_path=$(realpath "$file" 2>/dev/null || echo "$file")
                # Extract the filename (prefix) from the path
                filename=$(basename "$real_path")
                # Extract the prefix (part before the first dot)
                prefix="${filename%%.*}"
                # Get the directory path with the trailing slash
                dir_path=$(dirname "$real_path")/
                
                echo -e "$dir_path\e[32m$prefix\e[0m${filename#$prefix} - Contains \e[31m$line_count\e[0m Lines and \e[33m$count_value\e[0m $count_type"
                
                # Call the function with error handling
                if ! "$fnc" "$flag" "$file" "${extra_args[@]}" 2>/dev/null; then
                    echo "Warning: Function '$fnc' failed for file: $file" >&2
                fi
            elif [[ -d "$file" && "$file" != "$folder"/. && "$file" != "$folder"/.. ]]; then
                # Recursive call with incremented depth
                aux_ffl "$fnc" "$flag" "$file" "$max_depth" "$((current_depth + 1))" "${extra_args[@]}"
            fi
        done
    else
        echo "Invalid folder: $folder" >&2
        return 1
    fi
}

# Validates input values against specified criteria without environmental dependencies
# value validation
# <value> <validation_type> [criteria]
aux_val() {
    local value="$1"
    local validation_type="$2"
    local criteria="$3"
    
    case "$validation_type" in
        "empty")
            [[ -z "$value" ]] && return 0 || return 1
            ;;
        "not_empty")
            [[ -n "$value" ]] && return 0 || return 1
            ;;
        "numeric")
            [[ "$value" =~ ^[0-9]+$ ]] && return 0 || return 1
            ;;
        "alpha")
            [[ "$value" =~ ^[a-zA-Z]+$ ]] && return 0 || return 1
            ;;
        "alphanum")
            [[ "$value" =~ ^[a-zA-Z0-9]+$ ]] && return 0 || return 1
            ;;
        "file_exists")
            [[ -f "$value" ]] && return 0 || return 1
            ;;
        "dir_exists")
            [[ -d "$value" ]] && return 0 || return 1
            ;;
        "min_length")
            [[ ${#value} -ge ${criteria:-1} ]] && return 0 || return 1
            ;;
        "max_length")
            [[ ${#value} -le ${criteria:-100} ]] && return 0 || return 1
            ;;
        "regex")
            [[ "$value" =~ $criteria ]] && return 0 || return 1
            ;;
        *)
            echo "Error: Unknown validation type: $validation_type" >&2
            return 2
            ;;
    esac
}

# Performs checks and validations with clear pass/fail results
# check validation
# <check_type> <target> [parameters]
aux_chk() {
    local check_type="$1"
    local target="$2"
    shift 2
    local parameters=("$@")
    
    case "$check_type" in
        "command")
            command -v "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "function")
            declare -f "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "variable")
            [[ -n "${!target}" ]] && return 0 || return 1
            ;;
        "permission")
            local perm="${parameters[0]:-r}"
            case "$perm" in
                "r") [[ -r "$target" ]] && return 0 || return 1 ;;
                "w") [[ -w "$target" ]] && return 0 || return 1 ;;
                "x") [[ -x "$target" ]] && return 0 || return 1 ;;
                *) return 2 ;;
            esac
            ;;
        "process")
            pgrep -f "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "network")
            ping -c 1 "$target" >/dev/null 2>&1 && return 0 || return 1
            ;;
        "port")
            local port="${parameters[0]:-80}"
            if command -v nc >/dev/null 2>&1; then
                nc -z "$target" "$port" >/dev/null 2>&1 && return 0 || return 1
            elif command -v timeout >/dev/null 2>&1; then
                timeout 3 bash -c "echo >/dev/tcp/$target/$port" >/dev/null 2>&1 && return 0 || return 1
            else
                return 2
            fi
            ;;
        *)
            echo "Error: Unknown check type: $check_type" >&2
            return 2
            ;;
    esac
}

# Executes commands with error handling and result capture
# command execution
# <command> [args...]
aux_cmd() {
    local command="$1"
    shift
    local args=("$@")
    
    # Validate command exists
    if ! command -v "$command" >/dev/null 2>&1; then
        echo "Error: Command '$command' not found" >&2
        return 127
    fi
    
    # Execute command with error handling
    local output
    local exit_code
    
    if output=$("$command" "${args[@]}" 2>&1); then
        exit_code=$?
        if [[ -n "$output" ]]; then
            echo "$output"
        fi
        return $exit_code
    else
        exit_code=$?
        echo "Error: Command '$command ${args[*]}' failed with exit code $exit_code" >&2
        if [[ -n "$output" ]]; then
            echo "Output: $output" >&2
        fi
        return $exit_code
    fi
}

# Prompts user for input with validation and default values
# ask user input
# <prompt> [default_value] [validation_type]
aux_ask() {
    local prompt="$1"
    local default_value="$2" 
    local validation_type="$3"
    local user_input
    
    # Display prompt with default value if provided
    if [[ -n "$default_value" ]]; then
        echo -n "$prompt [$default_value]: "
    else
        echo -n "$prompt: "
    fi
    
    # Read user input
    read -r user_input
    
    # Use default if no input provided
    if [[ -z "$user_input" && -n "$default_value" ]]; then
        user_input="$default_value"
    fi
    
    # Validate input if validation type specified
    if [[ -n "$validation_type" ]]; then
        if ! aux_val "$user_input" "$validation_type"; then
            echo "Error: Invalid input. Please try again." >&2
            aux_ask "$prompt" "$default_value" "$validation_type"
            return $?
        fi
    fi
    
    echo "$user_input"
}

# Array manipulation and processing utilities
# array operations
# <operation> <array_name> [parameters...]
aux_arr() {
    local operation="$1"
    local array_name="$2"
    shift 2
    local parameters=("$@")
    
    case "$operation" in
        "length")
            local -n arr_ref="$array_name"
            echo "${#arr_ref[@]}"
            ;;
        "contains")
            local search_value="${parameters[0]}"
            local -n arr_ref="$array_name"
            for element in "${arr_ref[@]}"; do
                [[ "$element" == "$search_value" ]] && return 0
            done
            return 1
            ;;
        "add")
            local new_value="${parameters[0]}"
            local -n arr_ref="$array_name"
            arr_ref+=("$new_value")
            ;;
        "remove")
            local remove_value="${parameters[0]}"
            local -n arr_ref="$array_name"
            local new_array=()
            for element in "${arr_ref[@]}"; do
                [[ "$element" != "$remove_value" ]] && new_array+=("$element")
            done
            arr_ref=("${new_array[@]}")
            ;;
        "join")
            local delimiter="${parameters[0]:-,}"
            local -n arr_ref="$array_name"
            local result=""
            for i in "${!arr_ref[@]}"; do
                if [[ $i -eq 0 ]]; then
                    result="${arr_ref[i]}"
                else
                    result="${result}${delimiter}${arr_ref[i]}"
                fi
            done
            echo "$result"
            ;;
        "sort")
            local -n arr_ref="$array_name"
            readarray -t arr_ref < <(printf '%s\n' "${arr_ref[@]}" | sort)
            ;;
        "unique")
            local -n arr_ref="$array_name"
            readarray -t arr_ref < <(printf '%s\n' "${arr_ref[@]}" | sort -u)
            ;;
        "print")
            local -n arr_ref="$array_name"
            printf '%s\n' "${arr_ref[@]}"
            ;;
        *)
            echo "Error: Unknown array operation: $operation" >&2
            return 1
            ;;
    esac
}

# General purpose logging function for operational messages with explicit log levels
# operational log
# <log_level> <message>
aux_log() {
    # USE CASES:
    #   - Service start/stop messages
    #   - Authentication events  
    #   - Configuration changes
    #   - Error conditions
    #   - Performance metrics
    #   - User actions
    #   - Production monitoring
    #   - Important operational events that should always be logged
    # 
    # CHARACTERISTICS:
    #   - Requires explicit log level (INFO, WARN, ERROR, etc.)
    #   - No automatic function context (you specify what you're logging)
    #   - Always logs if main logging system is available
    #   - Suitable for production environments
    #   - Goes to operational logs (aux_operational.log)
    #
    # EXAMPLES:
    #   aux_log "INFO" "User authentication successful for user: $username"
    #   aux_log "ERROR" "Database connection failed"
    #   aux_log "WARN" "Configuration file missing, using defaults"
    
    local log_level="$1"
    local message="$2"
    
    # Validate parameters
    if [[ -z "$log_level" || -z "$message" ]]; then
        echo "Error: aux_log requires both log_level and message parameters" >&2
        return 1
    fi
    
    # Enhanced version with integration to main logging system
    if type -t log &>/dev/null; then
        # If main logging system is available, use it for consistency
        log "[$log_level] $message"
    else
        # Fallback to simple echo if main logging not available
        local timestamp
        printf -v timestamp '%(%Y-%m-%d %H:%M:%S)T' -1
        echo "[$timestamp] [$log_level] $message"
        
        # Also log to file if LOG_DIR is available
        if [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
            echo "[$timestamp] [$log_level] $message" >> "${LOG_DIR}/aux_operational.log"
        fi
    fi
}

# Development/debug logging with automatic function context and timestamp
# debug log
# <message> [level]
aux_dbg() {
    # USE CASES:
    #   - Development debugging and troubleshooting
    #   - Function entry/exit tracing
    #   - Variable value inspection
    #   - Control flow verification
    #   - Performance investigation
    #   - Error condition analysis
    #   - Development-time diagnostics
    #   - Temporary debugging during code development
    # 
    # CHARACTERISTICS:
    #   - Automatically captures calling function name from call stack
    #   - Auto-generates timestamp for each message
    #   - Integrates with existing lo1 logging system and verbosity controls
    #   - Output controlled by MASTER_TERMINAL_VERBOSITY and logging state
    #   - Optional log level parameter (defaults to DEBUG)
    #   - Sends to stderr for terminal output, log files for persistence
    #   - Suitable for development/debugging environments
    #   - Goes to debug logs (aux_debug.log) when available
    #
    # EXAMPLES:
    #   aux_dbg "Starting configuration validation"
    #   aux_dbg "Found $count items in array" "INFO"
    #   aux_dbg "Variable value: user=$username, status=$status"
    #   aux_dbg "Entering error handling branch" "WARN"
    
    local message="$1"
    local level="${2:-DEBUG}"
    
    # Validate message parameter
    if [[ -z "$message" ]]; then
        echo "Error: aux_dbg requires a message parameter" >&2
        return 1
    fi
    
    # Get the calling function name from the call stack
    local caller_function="${FUNCNAME[1]:-main}"
    local timestamp
    printf -v timestamp '%(%Y-%m-%d %H:%M:%S)T' -1
    
    # Check if we should output debug messages
    # Respect the existing logging infrastructure
    local should_output=false
    
    # Check if we have the main logging system available
    if type -t log &>/dev/null && type -t lo1_get_cached_log_state &>/dev/null; then
        # Use the existing lo1 logging system
        local log_state
        log_state=$(lo1_get_cached_log_state)
        if [[ "$log_state" == "on" && "${MASTER_TERMINAL_VERBOSITY:-off}" == "on" ]]; then
            should_output=true
        fi
    else
        # Fallback check - use environment variable or assume debug is wanted
        if [[ "${AUX_DEBUG_ENABLED:-1}" == "1" && "${MASTER_TERMINAL_VERBOSITY:-off}" == "on" ]]; then
            should_output=true
        fi
    fi
    
    # Format the debug message with function context
    local formatted_message="[$level] $timestamp - [$caller_function] $message"
    
    # Output to appropriate channels
    if [[ "$should_output" == "true" ]]; then
        # Send to stderr for debug output
        echo "$formatted_message" >&2
    fi
    
    # Always log to file if we have logging system available
    if type -t log &>/dev/null; then
        # Use the main logging system for file output
        log "[$level] [$caller_function] $message"
    elif [[ -n "${LOG_DIR:-}" && -w "${LOG_DIR:-}" ]]; then
        # Fallback file logging
        echo "$formatted_message" >> "${LOG_DIR}/aux_debug.log"
    fi
}

# Enhanced logging functions with different levels
# info log
# <message>
aux_info() {
    aux_dbg "$1" "INFO"
}

# warning log  
# <message>
aux_warn() {
    aux_dbg "$1" "WARN"
}

# error log
# <message>
aux_err() {
    aux_dbg "$1" "ERROR"
}