#!/bin/bash
set -o pipefail

# First declare all globals
declare -g TRAP_INITIALIZED
declare -gA CLEANUP_FUNCTIONS
declare -g TRAP_INITIALIZED=false
declare -g VERIFICATION_MODE="RC"  # Can be "RC" or "FALLBACK"

ini_log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="${2:-$1}"  # Accept both log "lvl" "msg" and log "msg" formats
    printf "[FALLBACK] %s - %s\n" "$timestamp" "$message" >&2
}
export -f fallback_log

# Create initial log function that uses fallback until real logging is ready
log() {
    ini_log "$@"
}
export -f log

essential_verify_var() {
    local var_name="$1"
    local var_value="${!var_name}"
    local prefix="[${VERIFICATION_MODE}]"

    if [[ -z "$var_value" ]]; then
        printf "%s Variable '%s' is empty\n" "$prefix" "$var_name" >&2
        return 1
    fi
    return 0
}

essential_verify_path() {
    local var_name="$1"

    if [[ -z "$var_value" ]]; then
        printf "%s Variable '%s' is empty\n" "$prefix" "$var_name" >&2
        return 1
    fi

    debug_log "Variable $var_name verified: $var_value"
    return 0
}

essential_verify_path() {
    local var_name="$1"
    local path="$2"
    local type="$3"
    local create="${4:-false}"

    debug_log "essential_verify_path: var=$var_name path=$path type=$type create=$create"

    # Basic validation
    [[ -z "$var_name" || -z "$path" || -z "$type" ]] && {
        debug_log "ERROR: Missing required parameters in essential_verify_path"
        return 1
    }

    # Type validation
    case "$type" in
        "dir"|"file") : ;;
        *) 
            debug_log "ERROR: Invalid path type: $type"
            return 1
            ;;
    esac

    # Path verification and creation
    if [[ "$type" == "dir" ]]; then
        if [[ ! -d "$path" ]]; then
            if [[ "$create" == "true" ]]; then
                debug_log "Creating directory: $path"
                mkdir -p "$path" || {
                    debug_log "ERROR: Failed to create directory: $path"
                    return 1
                }
                debug_log "Created directory: $path"
            else
                debug_log "ERROR: Directory does not exist: $path"
                return 1
            fi
        fi
    elif [[ "$type" == "file" ]]; then
        if [[ ! -f "$path" ]]; then
            if [[ "$create" == "true" ]]; then
                debug_log "Creating parent directory for file: $path"
                mkdir -p "$(dirname "$path")" || {
                    debug_log "ERROR: Failed to create parent directory for: $path"
                    return 1
                }
                debug_log "Creating file: $path"
                touch "$path" || {
                    debug_log "ERROR: Failed to create file: $path"
                    return 1
                }
                debug_log "Created file: $path"
            else
                debug_log "ERROR: File does not exist: $path"
                return 1
            fi
        fi
    fi

    debug_log "Path verification successful: $path"
    return 0
}

essential_verify_vars() {
    local failed=0
    for var in "$@"; do
        essential_verify_var "$var" || ((failed++))
    done
    # Return 0 if no failures, 1 if any failed
    return $((failed > 0))
}

essential_check() {
    # Load constants if needed
    if [[ -z "$CONS_LOADED" ]]; then
        local cons_file="${HOME}/lab/dic/cons"
        if [[ ! -f "$cons_file" ]]; then
            printf "[%s] Constants file not found: %s\n" "$VERIFICATION_MODE" "$cons_file" >&2
            return 1
        fi
        source "$cons_file" || {
            printf "[%s] Failed to source constants\n" "$VERIFICATION_MODE" >&2
            return 1
        }
    fi

    # Verify critical variables
    local essential_vars=(LAB_DIR BAS_DIR LOG_DIR TMP_DIR)
    if ! essential_verify_vars "${essential_vars[@]}"; then
        printf "[%s] Critical variable verification failed\n" "$VERIFICATION_MODE" >&2
        return 1
    fi

    # Create essential directories if they don't exist
    for dir in "$LOG_DIR" "$TMP_DIR"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir" || {
                printf "[%s] Failed to create directory: %s\n" "$VERIFICATION_MODE" "$dir" >&2
                return 1
            }
        fi
    done

    return 0
}

# Function to switch verification mode
set_verification_mode() {
    VERIFICATION_MODE="$1"
}

# Initialize verification system
init_verification() {
    # First save original trace settings and enable tracing
    local orig_trace_setting=$(set -o | grep xtrace | cut -f2)
    set -x

    # Create log directory if it doesn't exist
    mkdir -p "$(dirname /tmp/rc_init.log)" 2>/dev/null

    # Redirect all output to both console and a log file
    exec 1> >(tee /tmp/rc_init.log) 2>&1

    echo "Starting initialization verification..."

    # For RC startup
    set_verification_mode "RC"
    if ! essential_check; then
        echo "Fatal: Essential verification failed during RC initialization" >&2
        echo "Check /tmp/rc_init.log for details"
        # Don't exit, just return failure
        return 1
    fi

    # Verify critical directories exist after essential_check
    local missing=0
    for dir in "$LAB_DIR" "$BAS_DIR" "$LOG_DIR" "$TMP_DIR"; do
        if [[ ! -d "$dir" ]]; then
            echo "Creating directory: $dir"
            mkdir -p "$dir" || {
                echo "Failed to create directory: $dir" >&2
                ((missing++))
            }
        fi
    done

    if ((missing > 0)); then
        echo "Some directories could not be created" >&2
        return 1
    fi

    # Restore original trace setting
    if [[ "$orig_trace_setting" == "off" ]]; then
        set +x
    fi

    echo "Initialization verification completed successfully"
    return 0
}

# Fallback initialization
init_fallback_verification() {
    # For fallback mode
    set_verification_mode "FALLBACK"
    if ! essential_check; then
        echo "Fatal: Essential verification failed in fallback mode" >&2
        # Don't exit immediately, try to create directories first
        local missing=0
        for dir in "$LOG_DIR" "$TMP_DIR"; do
            if [[ ! -d "$dir" ]]; then
                echo "Attempting to create directory: $dir"
                mkdir -p "$dir" || ((missing++))
            fi
        done
        if ((missing > 0)); then
            return 1
        fi
    fi
    return 0
}

verify_module() {
    local module_name="$1"
    debug_log "Verifying module: $module_name"

    # Use essential verification functions
    if ! essential_check; then
        debug_log "ERROR: Environment verification failed for module: $module_name"
        return 1
    fi

    # Check module-specific required variables
    if [[ -n "${MODULE_REQUIRED_VARS[$module_name]}" ]]; then
        debug_log "Checking required vars for $module_name: ${MODULE_REQUIRED_VARS[$module_name]}"
        local required_vars=()
        # Split the string into array properly
        # Split the string into array while preserving spaces
        read -ra var_array <<< "$var_string"
        
        for var in "${var_array[@]}"; do
            debug_log "Checking required var: $var"
            if ! essential_verify_var "$var"; then
                debug_log "ERROR: Missing required variable $var for $module_name"
                return 1
            fi
        done
    fi

    # Check module-specific required paths
    if [[ -n "${MODULE_REQUIRED_PATHS[$module_name]}" ]]; then
        if ! parse_path_spec "${MODULE_REQUIRED_PATHS[$module_name]}"; then
            debug_log "ERROR: Path verification failed for module $module_name"
            return 1
        fi
    fi

    debug_log "Module $module_name verification completed successfully"
    return 0
}

list_module_deps() {
    local module="$1"

    echo "Dependencies for module: $module"
    echo "Required variables:"
    if [[ -n "${MODULE_REQUIRED_VARS[$module]}" ]]; then
        echo "  ${MODULE_REQUIRED_VARS[$module]}"
    else
        echo "  None"
    fi

    echo "Required paths:"
    if [[ -n "${MODULE_REQUIRED_PATHS[$module]}" ]]; then
        local IFS=';'
        local paths=(${MODULE_REQUIRED_PATHS[$module]})
        for path_spec in "${paths[@]}"; do
            IFS=':' read -r path_var path_type create_flag <<< "$path_spec"
            echo "  $path_var ($path_type, create: $create_flag)"
        done
    else
        echo "  None"
    fi
}

# Debug logging helper
debug_log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local debug_file="$LOG_DEBUG_FILE"
    
    mkdir -p "$(dirname "$debug_file")"
    printf "[DEBUG] %s - %s\n" "$timestamp" "$message" | tee -a "$debug_file" >&2
}

# Add this validation function before init_base
validate_module() {
    local file="$1"
    local module_name="$(basename "$file")"

    debug_log "Validating module: $module_name at $file"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        debug_log "ERROR: Module file does not exist: $file"
        return 1
    fi

    # Check if file is executable
    if [[ ! -x "$file" ]]; then
        debug_log "Adding execute permission to $module_name"
        chmod +x "$file" || {
            debug_log "ERROR: Failed to make $module_name executable"
            return 1
        }
    fi

    # Validate shebang
    local shebang
    read -r shebang < "$file"
    if [[ "$shebang" != "#!/bin/bash" ]]; then
        debug_log "ERROR: Invalid or missing shebang in $module_name"
        return 1
    fi

    debug_log "Module $module_name validation successful"
    return 0
}

parse_path_spec() {
    local spec="$1"
    [[ -z "$spec" ]] && return 1

    local success=0
    local IFS=';'
    read -ra specs <<< "$spec"

    for single_spec in "${specs[@]}"; do
        [[ -z "$single_spec" ]] && continue
        
        local var_name type create_flag
        IFS=':' read -r var_name type create_flag <<< "$single_spec"

        # Validate all parts are present
        [[ -z "$var_name" || -z "$type" || -z "$create_flag" ]] && {
            debug_log "ERROR: Invalid path specification: $single_spec"
            continue
        }

        # Clean up variables and remove any trailing/leading whitespace
        var_name="${var_name%%:*}"
        type="${type%%:*}"
        create_flag="${create_flag%%:*}"
        
        # Get actual path value and verify it's not empty
        local path_value="${!var_name}"
        [[ -z "$path_value" ]] && {
            debug_log "ERROR: Empty path value for $var_name"
            continue
        }

        debug_log "Processing spec: var=$var_name, path=$path_value, type=$type, create=$create_flag"

        if essential_verify_path "$var_name" "$path_value" "$type" "$create_flag"; then
            ((success++))
        else
            debug_log "ERROR: Path verification failed for $var_name"
            return 1
        fi
    done

    return $((success > 0 ? 0 : 1))
}

# Directory verification helper
verify_base_dir() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        debug_log "Warning: Directory $dir does not exist"
        if ! mkdir -p "$dir" 2>/dev/null; then
            debug_log "ERROR: Failed to create directory $dir"
            return 1
        fi
        debug_log "Created directory $dir"
    fi
    if [[ ! -w "$dir" ]]; then
        debug_log "ERROR: Directory $dir is not writable"
        return 1
    fi
    return 0
}

# Modified init_base function without var module dependency
init_base() {
    debug_log "Starting init_base"
    debug_log "BAS_DIR=$BAS_DIR"
    debug_log "Current directory: $(pwd)"
    debug_log "Script directory: $CON_DIR"

    # Debug variables
    echo "DEBUG VARS:"
    echo "LOG_STATE_FILE=$LOG_STATE_FILE"
    echo "LOG_DEBUG_FILE=$LOG_DEBUG_FILE"
    echo "LOG_DIR=$LOG_DIR"
    echo "TMP_DIR=$TMP_DIR"
    echo "Current module paths:"

    # Show lo1's path specs correctly
    if [[ -n "${MODULE_REQUIRED_PATHS[lo1]}" ]]; then
        echo "lo1 path specs:"
        local IFS=';'
        local paths=(${MODULE_REQUIRED_PATHS[lo1]})
        for path_spec in "${paths[@]}"; do
            echo "Path spec: $path_spec"
            local path_var path_type create_flag
            IFS=':' read -r path_var path_type create_flag <<< "$path_spec"
            echo "  Var: $path_var = ${!path_var}"
            echo "  Type: $path_type"
            echo "  Create: $create_flag"
        done
    fi

    # Rest of init_base function...
    if ! verify_base_dir "$BAS_DIR"; then
        debug_log "Warning: BAS_DIR verification failed but continuing"
        return 1
    fi

    local module_loaded=0

    # Updated module loading order array - removed var module
    local modules=(
        "$BAS_DIR/err"
        "$BAS_DIR/lo1"
        "$BAS_DIR/lo2"
        "$BAS_DIR/tme"
    )

    # Track loaded modules for dependencies

    local module_loaded=0

    # Updated module loading order array - removed var module
    local modules=(
        "$BAS_DIR/err"
        "$BAS_DIR/lo1"
        "$BAS_DIR/lo2"
        "$BAS_DIR/tme"
    )

    # Track loaded modules for dependencies
    declare -A loaded_modules

    # Try to source each module
    for module in "${modules[@]}"; do
        local module_name="$(basename "$module")"
        debug_log "Processing module: $module_name"

        # First verify the module itself
        if ! verify_module "$module_name"; then
            debug_log "ERROR: Module verification failed for $module_name"
            continue
        fi

        # Then validate and source the module file
        if ! validate_module "$module"; then
            debug_log "ERROR: Module file validation failed for $module_name"
            continue
        fi

        # Source with error capture
        if ! source "$module" 2> >(debug_log "Source error for $module_name: $(cat)"); then
            debug_log "ERROR: Failed to source module $module_name"
            continue
        fi

        debug_log "Successfully loaded module: $module_name"
        loaded_modules[$module_name]=1
        ((module_loaded++))
    done

    debug_log "Environment after module loading:"
    env | grep -i "lab\|dir\|path" | while read -r line; do
        debug_log "  $line"
    end

    debug_log "init_base completed with $module_loaded modules loaded"
    return $((module_loaded > 0 ? 0 : 1))
}

# init base modules tmp and log dirs
init_dirs() {
    debug_log "Starting directory initialization"
    
    # 1. First ensure base directories exist
    if ! essential_verify_path "LOG_DIR" "$LOG_DIR" "dir" "true" || \
       ! essential_verify_path "TMP_DIR" "$TMP_DIR" "dir" "true"; then
        debug_log "ERROR: Failed to create base directories"
        echo "Fatal: Unable to create base directories" >&2
        return 1
    fi

    # 2. Set correct permissions
    chmod 700 "$LOG_DIR" "$TMP_DIR" 2>/dev/null || {
        debug_log "WARNING: Unable to set directory permissions"
    }

    # 3. Process module-specific paths
    for module in "${!MODULE_REQUIRED_PATHS[@]}"; do
        local path_spec="${MODULE_REQUIRED_PATHS[$module]}"
        debug_log "Processing module $module paths: $path_spec"
        
        if ! parse_path_spec "$path_spec"; then
            debug_log "ERROR: Failed to process paths for module $module"
            echo "Fatal: Module path initialization failed for $module" >&2
            return 1
        fi
    done

    debug_log "Directory initialization completed successfully"
    debug_log "LOG_DIR=$LOG_DIR"
    debug_log "TMP_DIR=$TMP_DIR"
    
    return 0
}

# Central trap registration system
register_cleanup() {
    local module="$1"
    local function="$2"

    [[ -z "$module" || -z "$function" ]] && {
        echo "Error: Invalid cleanup registration arguments" >&2
        return 1
    }
    if [[ -n "$function" && $(type -t "$function") == "function" ]]; then
        CLEANUP_FUNCTIONS[$module]="$function"
        type log >/dev/null 2>&1 && log "lvl" "Registered cleanup for module: $module" || echo "Registered cleanup for module: $module"
    else
        type log >/dev/null 2>&1 && log "lvl" "Failed to register cleanup for module: $module" || echo "Failed to register cleanup for module: $module"
        return 1
    fi
}

# Main cleanup orchestrator
main_cleanup() {
    log "lvl" "Starting main cleanup sequence"

    # First cleanup logging system
    if [[ -n "${CLEANUP_FUNCTIONS[lo]}" ]]; then
        ${CLEANUP_FUNCTIONS[lo]}
    fi

    # Then cleanup timing system
    if [[ -n "${CLEANUP_FUNCTIONS[tme]}" ]]; then
        ${CLEANUP_FUNCTIONS[tme]}
    fi

    # Finally cleanup error handling
    if [[ -n "${CLEANUP_FUNCTIONS[err]}" ]]; then
        ${CLEANUP_FUNCTIONS[err]}
    fi

    log "lvl" "Main cleanup sequence completed"
}

# Central error handler
main_error_handler() {
    local line_number="$1"
    local error_code="$2"

    # Call error handler from err module if available
    if type error_handler &>/dev/null; then
        error_handler "$line_number" "$error_code"
    fi
}

# Initialize trap system
init_traps() {
    if [[ "$TRAP_INITIALIZED" != "true" ]]; then
        # Remove any existing traps
        trap - EXIT
        trap - ERR

        # Set up main traps
        trap main_cleanup EXIT
        trap 'main_error_handler $LINENO $?' ERR

        TRAP_INITIALIZED=true
    fi
}

source_rc() {
    debug_log "Starting source_rc"
    local rc_modules=("rc1" "rc2" "rc3" "rc4")
    local success_count=0

    for module in "${rc_modules[@]}"; do
        debug_log "Attempting to source $module"
        if [[ -r "$CON_DIR/$module" ]]; then
            debug_log "Module $module is readable"
            debug_log "Module permissions: $(ls -l "$CON_DIR/$module")"
            if [[ ! -x "$CON_DIR/$module" ]]; then
                debug_log "Adding execute permission to $module"
                chmod +x "$CON_DIR/$module" || {
                    debug_log "ERROR: Failed to add execute permission to $module"
                    continue
                }
            fi
            if source "$CON_DIR/$module" 2> >(debug_log "Source error: $(cat)"); then
                debug_log "Successfully sourced $module"
                ((success_count++))
            else
                debug_log "ERROR: Failed to source $module"
            fi
        else
            debug_log "ERROR: Cannot read $module at $CON_DIR/$module"
        fi
    done

    debug_log "source_rc completed with $success_count successful modules"
    [[ $success_count -gt 0 ]] || return 1
    return 0
}

debug_rc_init() {
    echo "Checking critical paths..."
    echo "HOME=$HOME"
    echo "LAB_DIR=$LAB_DIR"
    echo "BAS_DIR=$BAS_DIR"
    echo "LOG_DIR=$LOG_DIR"
    echo "TMP_DIR=$TMP_DIR"

    echo -e "\nChecking directory existence:"
    for dir in "$HOME" "$LAB_DIR" "$BAS_DIR" "$LOG_DIR" "$TMP_DIR"; do
        printf "%-30s: %s\n" "$dir" "$([ -d "$dir" ] && echo "exists" || echo "missing")"
    done

    echo -e "\nChecking file permissions:"
    for dir in "$HOME" "$LAB_DIR" "$BAS_DIR" "$LOG_DIR" "$TMP_DIR"; do
        if [ -e "$dir" ]; then
            ls -ld "$dir"
        fi
    done
}

# Modified main_rc to remove module function dependencies
main_rc() {
    # Save original error exit setting
    local orig_errexit_setting=$(set -o | grep errexit | cut -f2)
    set +e  # Disable exit on error temporarily

    echo "Starting main_rc initialization..." | tee -a /tmp/rc_init.log
        echo "Warning: Trap initialization failed" >&2 | tee -a /tmp/rc_init.log
        echo "init_traps returned: $?" >> /tmp/rc_init.log
    }

    echo "      └─ main_rc : init_base" | tee -a /tmp/rc_init.log
    init_base
    local init_base_status=$?
    echo "init_base returned: $init_base_status" >> /tmp/rc_init.log


    echo "      └─ main_rc : init_traps" | tee -a /tmp/rc_init.log
    init_traps || {
        echo "Warning: Trap initialization failed" >&2 | tee -a /tmp/rc_init.log
        echo "init_traps returned: $?" >> /tmp/rc_init.log
    }

    echo "      └─ main_rc : init_base" | tee -a /tmp/rc_init.log
    init_base
    local init_base_status=$?
    echo "init_base returned: $init_base_status" >> /tmp/rc_init.log

    # Track status of each major operation
    local rc_status=0

    # Simple echo for logging
    echo "main_rc : source_rc" | tee -a /tmp/rc_init.log

    # Source RC files with status tracking
    if ! source_rc; then
        echo "Warning: Failed to source RC files" >&2 | tee -a /tmp/rc_init.log
        rc_status=1
    fi

    # Restore original errexit setting
    if [[ "$orig_errexit_setting" == "on" ]]; then
        set -e
    fi

    echo "main_rc completing with status: $rc_status" >> /tmp/rc_init.log
    return $rc_status
}

echo " ─── initializing"
# Disable exit on error for the initialization
set +e

# Add debug trapping for main_rc status
main_rc
MAIN_RC_STATUS=$?
echo "main_rc returned with status: $MAIN_RC_STATUS" >> /tmp/rc_init.log

if [ $MAIN_RC_STATUS -ne 0 ]; then
    echo "RC initialization failed with status $MAIN_RC_STATUS. Check /tmp/rc_init.log for details" >&2
    # Create essential directories as last resort
    for dir in "$LOG_DIR" "$TMP_DIR"; do
        mkdir -p "$dir" 2>/dev/null
    done

    # Set up minimal environment to keep shell usable
    echo "Setting up minimal environment..." >&2
    export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$HOME/bin"

    # Set a basic prompt to indicate we're in minimal mode
    PS1="(minimal)[\u@\h \W]\$ "

    # Continue with shell despite initialization failure
    return 0
debug_env() {
fi

# Restore exit on error if it was enabled
if [[ "$(set -o | grep errexit | cut -f2)" == "on" ]]; then
    set -e
fi

export VERIFICATION_MODE
export -f essential_verify_var essential_verify_path essential_verify_vars
export -f essential_check set_verification_mode
export -f init_verification init_fallback_verification

    set -e
fi

export VERIFICATION_MODE
export -f essential_verify_var essential_verify_path essential_verify_vars
export -f essential_check set_verification_mode
export -f init_verification init_fallback_verification

    local prefix="DEBUG ENV:"
    echo "$prefix Current directory: $(pwd)"
    echo "$prefix Script directory: $CON_DIR"
    echo "$prefix Important variables:"
    echo "  LAB_DIR=$LAB_DIR"
    echo "  BAS_DIR=$BAS_DIR"
    echo "  CON_DIR=$CON_DIR" 
    echo "  LOG_DIR=$LOG_DIR"
    echo "  TMP_DIR=$TMP_DIR"
    echo "  ERROR_LOG=$ERROR_LOG"
    echo "  LOG_STATE_FILE=$LOG_STATE_FILE"
    echo "  LOG_DEBUG_FILE=$LOG_DEBUG_FILE"
}
