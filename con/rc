#!/bin/bash
set -o pipefail

# First declare all globals
declare -g TRAP_INITIALIZED
declare -gA CLEANUP_FUNCTIONS
declare -g TRAP_INITIALIZED=false
declare -g VERIFICATION_MODE="RC"  # Can be "RC" or "FALLBACK"

essential_verify_var() {
    local var_name="$1"
    local var_value="${!var_name}"
    local prefix="[${VERIFICATION_MODE}]"

    if [[ -z "$var_value" ]]; then
        printf "%s Variable '%s' is empty\n" "$prefix" "$var_name" >&2
        return 1
    fi
    return 0
}

essential_verify_path() {
    local path_var="$1"
    local path_type="$2"
    local create="${3:-false}"
    local path_value="${!path_var}"
    local prefix="[${VERIFICATION_MODE}]"

    if ! essential_verify_var "$path_var"; then
        return 1
    fi

    if [[ "$create" == "true" ]]; then
        case "$path_type" in
            dir) mkdir -p "$path_value" 2>/dev/null ;;
            file)
                mkdir -p "$(dirname "$path_value")" 2>/dev/null
                touch "$path_value" 2>/dev/null
                ;;
        esac
    fi

    if [[ ! -e "$path_value" ]]; then
        printf "%s Path '%s' does not exist\n" "$prefix" "$path_value" >&2
        return 1
    fi
    return 0
}

essential_verify_vars() {
    local failed=0
    for var in "$@"; do
        essential_verify_var "$var" || ((failed++))
    done
    # Return 0 if no failures, 1 if any failed
    return $((failed > 0))
}

essential_check() {
    # Load constants if needed
    if [[ -z "$CONS_LOADED" ]]; then
        local cons_file="${HOME}/lab/dic/cons"
        if [[ ! -f "$cons_file" ]]; then
            printf "[%s] Constants file not found: %s\n" "$VERIFICATION_MODE" "$cons_file" >&2
            return 1
        fi
        source "$cons_file" || {
            printf "[%s] Failed to source constants\n" "$VERIFICATION_MODE" >&2
            return 1
        }
    fi

    # Verify critical variables
    local essential_vars=(LAB_DIR BAS_DIR LOG_DIR TMP_DIR)
    if ! essential_verify_vars "${essential_vars[@]}"; then
        printf "[%s] Critical variable verification failed\n" "$VERIFICATION_MODE" >&2
        return 1
    fi

    # Create essential directories if they don't exist
    for dir in "$LOG_DIR" "$TMP_DIR"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir" || {
                printf "[%s] Failed to create directory: %s\n" "$VERIFICATION_MODE" "$dir" >&2
                return 1
            }
        fi
    done

    return 0
}

# Function to switch verification mode
set_verification_mode() {
    VERIFICATION_MODE="$1"
}

# Initialize verification system
init_verification() {
    # First save original trace settings and enable tracing
    local orig_trace_setting=$(set -o | grep xtrace | cut -f2)
    set -x

    # Create log directory if it doesn't exist
    mkdir -p "$(dirname /tmp/rc_init.log)" 2>/dev/null

    # Redirect all output to both console and a log file
    exec 1> >(tee /tmp/rc_init.log) 2>&1

    echo "Starting initialization verification..."

    # For RC startup
    set_verification_mode "RC"
    if ! essential_check; then
        echo "Fatal: Essential verification failed during RC initialization" >&2
        echo "Check /tmp/rc_init.log for details"
        # Don't exit, just return failure
        return 1
    fi

    # Verify critical directories exist after essential_check
    local missing=0
    for dir in "$LAB_DIR" "$BAS_DIR" "$LOG_DIR" "$TMP_DIR"; do
        if [[ ! -d "$dir" ]]; then
            echo "Creating directory: $dir"
            mkdir -p "$dir" || {
                echo "Failed to create directory: $dir" >&2
                ((missing++))
            }
        fi
    done

    if ((missing > 0)); then
        echo "Some directories could not be created" >&2
        return 1
    fi

    # Restore original trace setting
    if [[ "$orig_trace_setting" == "off" ]]; then
        set +x
    fi

    echo "Initialization verification completed successfully"
    return 0
}

# Fallback initialization
init_fallback_verification() {
    # For fallback mode
    set_verification_mode "FALLBACK"
    if ! essential_check; then
        echo "Fatal: Essential verification failed in fallback mode" >&2
        # Don't exit immediately, try to create directories first
        local missing=0
        for dir in "$LOG_DIR" "$TMP_DIR"; do
            if [[ ! -d "$dir" ]]; then
                echo "Attempting to create directory: $dir"
                mkdir -p "$dir" || ((missing++))
            fi
        done
        if ((missing > 0)); then
            return 1
        fi
    fi
    return 0
}

verify_module() {
    local module_name="$1"

    # Check if essential verification is available
    if ! type essential_verify_vars >/dev/null 2>&1; then
        echo "Fatal: Essential verification not available" >&2
        return 1
    fi

    # Verify basic environment
    if ! essential_check; then
        echo "Fatal: Environment verification failed" >&2
        return 1
    fi

    # Check module-specific required variables
    if [[ -n "${MODULE_REQUIRED_VARS[$module_name]}" ]]; then
        if ! essential_verify_vars ${MODULE_REQUIRED_VARS[$module_name]}; then
            echo "Fatal: Missing required variables for $module_name" >&2
            return 1
        fi
    fi

    # Check module-specific required paths
    if [[ -n "${MODULE_REQUIRED_PATHS[$module_name]}" ]]; then
        local IFS=';'
        local paths=(${MODULE_REQUIRED_PATHS[$module_name]})
        for path_spec in "${paths[@]}"; do
            IFS=':' read -r path_var path_type create_flag <<< "$path_spec"
            if ! essential_verify_path "$path_var" "$path_type" "$create_flag"; then
                echo "Fatal: Required path $path_var not accessible for $module_name" >&2
                return 1
            fi
        done
    fi

    return 0
}

list_module_deps() {
    local module="$1"

    echo "Dependencies for module: $module"
    echo "Required variables:"
    if [[ -n "${MODULE_REQUIRED_VARS[$module]}" ]]; then
        echo "  ${MODULE_REQUIRED_VARS[$module]}"
    else
        echo "  None"
    fi

    echo "Required paths:"
    if [[ -n "${MODULE_REQUIRED_PATHS[$module]}" ]]; then
        local IFS=';'
        local paths=(${MODULE_REQUIRED_PATHS[$module]})
        for path_spec in "${paths[@]}"; do
            IFS=':' read -r path_var path_type create_flag <<< "$path_spec"
            echo "  $path_var ($path_type, create: $create_flag)"
        done
    else
        echo "  None"
    fi
}

# Debug logging helper
debug_log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local debug_file="$LOG_DEBUG_FILE"
    
    mkdir -p "$(dirname "$debug_file")"
    printf "[DEBUG] %s - %s\n" "$timestamp" "$message" | tee -a "$debug_file" >&2
}

# Add this validation function before init_base
validate_module() {
    local file="$1"
    local module_name="$(basename "$file")"
    
    # Check if file exists and is regular file
    [[ -f "$file" ]] || {
        debug_log "ERROR: $module_name is not a regular file"
        return 1
    }

    # Check if file is executable
    [[ -x "$file" ]] || {
        debug_log "Adding execute permission to $module_name"
        chmod +x "$file" || {
            debug_log "ERROR: Failed to make $module_name executable"
            return 1
        }
    }

    # Validate shebang
    local shebang
    read -r shebang < "$file"
    [[ "$shebang" == "#!/bin/bash" ]] || {
        debug_log "ERROR: Invalid or missing shebang in $module_name"
        return 1
    }

    return 0
}

# init base modules
# Improved init_base function
init_base() {
    debug_log "Starting init_base"
    debug_log "BAS_DIR=$BAS_DIR"
    debug_log "Current directory: $(pwd)"
    debug_log "Script directory: $CON_DIR"

    # Check BAS_DIR using essential verification
    if ! essential_verify_path "BAS_DIR" "dir" false; then
        debug_log "ERROR: BAS_DIR verification failed"
        return 1
    fi

    debug_log "BAS_DIR contents:"
    ls -la "$BAS_DIR" 2>&1 | while read -r line; do
        debug_log "  $line"
    done

    # First initialize directories using essential verification
    debug_log "Initializing directories"
    init_dirs || {
        debug_log "ERROR: Directory initialization failed"
        echo "         └─ Fatal: Directory initialization failed" >&2
        return 1
    }

    local module_loaded=0
    local fallback_active=false
    local var_module_loaded=false

    # Module loading order array
    local modules=(
        "var"   # Will try to load but not critical anymore
        "err"
        "lo1"
        "lo2"
        "tme"
    )

    # Track loaded modules for dependencies
    declare -A loaded_modules

    # Try to source each module
    for module in "${modules[@]}"; do
        local file="$BAS_DIR/$module"
        debug_log "Attempting to load module: $module"

        # Validate module before loading
        if ! validate_module "$file"; then
            debug_log "ERROR: Module validation failed for $module"
            continue
        fi

        # Source the module and capture errors
        local error_file
        error_file=$(mktemp)

        if ! source "$file" 2>"$error_file"; then
            local error_output
            error_output=$(<"$error_file")
            rm -f "$error_file"
            debug_log "ERROR: Failed to load module $module with error: $error_output"
            echo "        └─ Warning: Failed to load $module" >&2

            # Handle fallbacks based on module
            case "$module" in
                "lo1")
                    debug_log "Activating fallback for logging"
                    fallback_lo
                    echo "         └─ Activated fallback logging system"
                    ;;
                "err")
                    debug_log "Activating fallback for err"
                    fallback_err
                    echo "         └─ Activated fallback error handling"
                    ;;
                "tme")
                    debug_log "Activating fallback for tme"
                    fallback_tme
                    echo "         └─ Activated fallback timing system"
                    ;;
                "var")
                    debug_log "Var module failed, using essential verification"
                    # We're already using essential verification, so no additional fallback needed
                    ;;
            esac

            fallback_active=true
            continue
        fi
        rm -f "$error_file"

        # Mark module as loaded
        loaded_modules[$module]=1
        ((module_loaded++))
        [[ "$module" == "var" ]] && var_module_loaded=true

        # Verify module functions are available
        debug_log "Verifying module functions for: $module"
        for func in $(grep -o '^[a-zA-Z0-9_]\+()' "$file" 2>/dev/null | tr -d '()'); do
            if type "$func" >/dev/null 2>&1; then
                debug_log "  Function verified: $func"
            else
                debug_log "  ERROR: Function not available after sourcing: $func"
            fi
        done
    done

    debug_log "Environment after module loading:"
    env | grep -i "lab\|dir\|path" | while read -r line; do
        debug_log "  $line"
    done

    # Initialize timer system if available using essential verification
    if type init_timer >/dev/null 2>&1 && essential_verify_path "LOG_DIR" "dir" true; then
        debug_log "Initializing timer system"
        init_timer "$LOG_DIR" || {
            debug_log "ERROR: Timer initialization failed"
            echo "         └─ Warning: Timer initialization failed, using fallback" >&2
            fallback_tme
            fallback_active=true
        }
    else
        debug_log "Timer initialization function not available"
    fi

    # Final status check
    if $fallback_active; then
        debug_log "Running in fallback mode"
        echo "        └─ Notice: Running in partial fallback mode with minimal functionality"
        return 0
    fi

    debug_log "init_base completed with $module_loaded modules loaded"
    return $((module_loaded > 0 ? 0 : 1))
}

# init base modules tmp and log dirs
init_dirs() {
    local debug_log="${AUX_DIR:-/tmp}/init_dirs.log"
    mkdir -p "$(dirname "$debug_log")" 2>/dev/null
    
    # Create base directories with proper permissions
    mkdir -p "$LOG_DIR" "$TMP_DIR" || {
        echo "Fatal: Unable to create base directories" >&2
        return 1
    }

    # Ensure proper permissions (only for current user)
    chmod 700 "$LOG_DIR" "$TMP_DIR" || {
        echo "Warning: Unable to set directory permissions" >&2
    }

    # Debug logging for initial state
    {
        printf '%s\n' "=== Directory Initialization Debug Log ==="
        printf 'Timestamp: %s\n' "$(date)"
        printf 'Initial TMP_DIR value: %s\n' "${TMP_DIR:-unset}"
        printf 'Initial LOG_DIR value: %s\n' "${LOG_DIR:-unset}"
        printf 'Caller: %s\n' "${FUNCNAME[1]:-main}"
        echo "Call stack:"
        local i=0
        # Redirect stderr to prevent error messages
        while caller $i 2>/dev/null; do
            ((i++))
        done
        echo "Current environment variables affecting paths:"
        env | grep -i "dir\|path" || echo "No relevant environment variables found"
        echo "=== End Initial State ==="
        echo
    } > "$debug_log" 2>/dev/null  # Redirect all potential errors to prevent them

    # Debug logging post-definition
    {
        printf '%s\n' "=== Post-Definition State ==="
        printf 'LOG_DIR set to: %s\n' "${LOG_DIR}"
        printf 'TMP_DIR set to: %s\n' "${TMP_DIR}"
        printf '%s\n\n' "=== End Post-Definition State ==="
    } >> "$debug_log"


    # Verify critical directories exist
    local -a critical_dirs=(
        "${LOG_DIR}"
        "${TMP_DIR}"
    )

    {
        printf '%s\n' "=== Critical Directory Verification ==="
        local missing_critical=0
        local dir
        for dir in "${critical_dirs[@]}"; do
            if [[ ! -d "$dir" ]]; then
                printf 'MISSING CRITICAL DIRECTORY: %s\n' "$dir"
                echo "Parent directory status:"
                ls -ld "$(dirname "$dir")" 2>&1 || echo "Cannot access parent directory"
                printf 'Critical: Required directory missing: %s\n' "$dir" >&2
                missing_critical=1
            else
                printf 'Verified critical directory exists: %s\n' "$dir"
                echo "Directory permissions:"
                ls -ld "$dir"
            fi
        done

        printf '%s\n' "=== Final State ==="
        printf 'Final LOG_DIR: %s\n' "${LOG_DIR}"
        printf 'Final TMP_DIR: %s\n' "${TMP_DIR}"
        printf 'Missing critical directories: %d\n' "$missing_critical"
        printf '%s\n\n' "=== End Directory Initialization ==="

        # Exit if critical directories are missing
        if (( missing_critical )); then
            echo "Fatal: Missing critical directories. Cannot continue." >&2
            return 1
        fi
    } > "$debug_log" 2>/dev/null

    return 0
}

# Central trap registration system
register_cleanup() {
    local module="$1"
    local function="$2"

    [[ -z "$module" || -z "$function" ]] && {
        echo "Error: Invalid cleanup registration arguments" >&2
        return 1
    }
    if [[ -n "$function" && $(type -t "$function") == "function" ]]; then
        CLEANUP_FUNCTIONS[$module]="$function"
        type log >/dev/null 2>&1 && log "lvl" "Registered cleanup for module: $module" || echo "Registered cleanup for module: $module"
    else
        type log >/dev/null 2>&1 && log "lvl" "Failed to register cleanup for module: $module" || echo "Failed to register cleanup for module: $module"
        return 1
    fi
}

# Main cleanup orchestrator
main_cleanup() {
    log "lvl" "Starting main cleanup sequence"

    # First cleanup logging system
    if [[ -n "${CLEANUP_FUNCTIONS[lo]}" ]]; then
        ${CLEANUP_FUNCTIONS[lo]}
    fi

    # Then cleanup timing system
    if [[ -n "${CLEANUP_FUNCTIONS[tme]}" ]]; then
        ${CLEANUP_FUNCTIONS[tme]}
    fi

    # Finally cleanup error handling
    if [[ -n "${CLEANUP_FUNCTIONS[err]}" ]]; then
        ${CLEANUP_FUNCTIONS[err]}
    fi

    log "lvl" "Main cleanup sequence completed"
}

# Central error handler
main_error_handler() {
    local line_number="$1"
    local error_code="$2"

    # Call error handler from err module if available
    if type error_handler &>/dev/null; then
        error_handler "$line_number" "$error_code"
    fi
}

# Initialize trap system
init_traps() {
    if [[ "$TRAP_INITIALIZED" != "true" ]]; then
        # Remove any existing traps
        trap - EXIT
        trap - ERR

        # Set up main traps
        trap main_cleanup EXIT
        trap 'main_error_handler $LINENO $?' ERR

        TRAP_INITIALIZED=true
    fi
}

fallback_lo() {
    # Minimal logging functionality
    log() {
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[FALLBACK-LOG] $timestamp - $2"
    }

    setlog() {
        echo "[FALLBACK-LOG] Logging control not available in fallback mode"
    }

    init_logger() {
        echo "[FALLBACK-LOG] Using minimal fallback logger"
    }

    cleanup_logger() {
        :  # No-op in fallback mode
    }

    # Export fallback functions
    export -f log setlog init_logger cleanup_logger
}

fallback_err() {
    # Minimal error handling
    error_handler() {
        echo "[FALLBACK-ERROR] Error on line $1: $2"
    }

    clean_exit() {
        exit "${1:-0}"
    }

    setup_error_handling() {
        trap 'error_handler $LINENO $?' ERR
    }

    # Export fallback functions
    export -f error_handler clean_exit setup_error_handling
}

fallback_tme() {
    # Minimal timing functionality
    init_timer() {
        echo "[FALLBACK-TIMER] Timer initialization skipped in fallback mode"
    }

    start_timer() {
        :  # No-op in fallback mode
    }

    end_timer() {
        :  # No-op in fallback mode
    }

    print_timing_report() {
        echo "[FALLBACK-TIMER] Timing report not available in fallback mode"
    }

    # Export fallback functions
    export -f init_timer start_timer end_timer print_timing_report
}

source_rc() {
    debug_log "Starting source_rc"
    local rc_modules=("rc1" "rc2" "rc3" "rc4")
    local success_count=0

    for module in "${rc_modules[@]}"; do
        debug_log "Attempting to source $module"
        if [[ -r "$CON_DIR/$module" ]]; then
            debug_log "Module $module is readable"
            debug_log "Module permissions: $(ls -l "$CON_DIR/$module")"
            if source "$CON_DIR/$module" 2> >(debug_log "Source error: $(cat)"); then
                debug_log "Successfully sourced $module"
                ((success_count++))
            else
                debug_log "ERROR: Failed to source $module"
            fi
        else
            debug_log "ERROR: Cannot read $module at $CON_DIR/$module"
        fi
    done

    debug_log "source_rc completed with $success_count successful modules"
    [[ $success_count -gt 0 ]] || return 1
    return 0
}

debug_rc_init() {
    echo "Checking critical paths..."
    echo "HOME=$HOME"
    echo "LAB_DIR=$LAB_DIR"
    echo "BAS_DIR=$BAS_DIR"
    echo "LOG_DIR=$LOG_DIR"
    echo "TMP_DIR=$TMP_DIR"

    echo -e "\nChecking directory existence:"
    for dir in "$HOME" "$LAB_DIR" "$BAS_DIR" "$LOG_DIR" "$TMP_DIR"; do
        printf "%-30s: %s\n" "$dir" "$([ -d "$dir" ] && echo "exists" || echo "missing")"
    done

    echo -e "\nChecking file permissions:"
    for dir in "$HOME" "$LAB_DIR" "$BAS_DIR" "$LOG_DIR" "$TMP_DIR"; do
        if [ -e "$dir" ]; then
            ls -ld "$dir"
        fi
    done
}

main_rc() {
    # Save original error exit setting
    local orig_errexit_setting=$(set -o | grep errexit | cut -f2)
    set +e  # Disable exit on error temporarily

    echo "Starting main_rc initialization..."

    # Try initialization
    if ! init_verification; then
        echo "Warning: Initialization verification failed, attempting fallback mode..." >&2
        init_fallback_verification || {
            echo "Fatal: Both main and fallback initialization failed" >&2
            echo "Check /tmp/rc_init.log for details" >&2
            # Don't exit, just return failure
            return 1
        }
    fi

    echo "      └─ main_rc : init_traps"
    init_traps || echo "Warning: Trap initialization failed"

    echo "      └─ main_rc : init_base"
    if ! init_base; then
        echo "Warning: Environment initialization using fallbacks" >&2
    fi

    # Use log function if available, otherwise echo
    type log >/dev/null 2>&1 && {
        log "lvl" "main_rc : register_cleanup"
        log "lvl" "main_rc : setup_error_handling"
        log "lvl" "main_rc : source_rc"
        log "lvl" "main_rc : setup_components"
    } || {
        echo "main_rc : register_cleanup"
        echo "main_rc : setup_error_handling"
        echo "main_rc : source_rc"
        echo "main_rc : setup_components"
    }

    # Register cleanups if functions exist
    type cleanup_logger >/dev/null 2>&1 && register_cleanup "lo" "cleanup_logger"
    type cleanup_timer >/dev/null 2>&1 && register_cleanup "tme" "cleanup_timer"
    type clean_exit >/dev/null 2>&1 && register_cleanup "err" "clean_exit"

    # Setup error handling if available
    type setup_error_handling >/dev/null 2>&1 && setup_error_handling

    # Source RC files
    if ! source_rc; then
        echo "Warning: Failed to source RC files" >&2
    fi

    # Setup components
    if ! setup_components; then
        echo "Warning: Component setup failed" >&2
    fi

    # Restore original errexit setting
    if [[ "$orig_errexit_setting" == "on" ]]; then
        set -e
    fi

    return 0
}

echo " ─── initializing"
debug_rc_init

# Disable exit on error for the initialization
set +e

if ! main_rc; then
    echo "RC initialization failed. Check /tmp/rc_init.log for details" >&2
    # Create essential directories as last resort
    for dir in "$LOG_DIR" "$TMP_DIR"; do
        mkdir -p "$dir" 2>/dev/null
    done
fi

# Restore exit on error if it was enabled
if [[ "$(set -o | grep errexit | cut -f2)" == "on" ]]; then
    set -e
fi


export VERIFICATION_MODE
export -f essential_verify_var essential_verify_path essential_verify_vars
export -f essential_check set_verification_mode
export -f init_verification init_fallback_verification
