#!/bin/bash
set -o pipefail

# Global declarations should be at the very top
declare -gA CLEANUP_FUNCTIONS    # Associative array to store cleanup functions by module
declare -g TRAP_INITIALIZED=false    # Global flag to track trap initialization state

# Rest of your variables
DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" >/dev/null 2>&1 && pwd)"
PARENT_DIR="/root/lab"
export LAB_DIR="$PARENT_DIR"
readonly BAS_DIR="$PARENT_DIR/bas"

# Move all initialization into a proper init function
initialize_environment() {
    # First initialize directories
    initialize_directories || {
        echo "Fatal: Directory initialization failed" >&2
        return 1
    }

    # Source all files in BAS_DIR
    for file in "$BAS_DIR"/*; do
        source "$file" || {
            echo "Fatal: Failed to source $(basename "$file")" >&2
            return 1
        }
    done

    # Initialize timer system with proper log directory
    init_timer "$RC_LOG_DIR" || {
        echo "Fatal: Failed to initialize timer" >&2
        return 1
    }

    return 0
}

initialize_directories() {
    local debug_log="/tmp/directory_init_debug.log"

    # Debug logging for initial state
    {
        printf '%s\n' "=== Directory Initialization Debug Log ==="
        printf 'Timestamp: %s\n' "$(date)"
        printf 'Initial TMP_DIR value: %s\n' "${TMP_DIR:-unset}"
        printf 'Initial LOG_DIR value: %s\n' "${LOG_DIR:-unset}"
        printf 'Caller: %s\n' "${FUNCNAME[1]:-main}"
        echo "Call stack:"
        local i=0
        # Redirect stderr to prevent error messages
        while caller $i 2>/dev/null; do
            ((i++))
        done
        echo "Current environment variables affecting paths:"
        env | grep -i "dir\|path" || echo "No relevant environment variables found"
        echo "=== End Initial State ==="
        echo
    } > "$debug_log" 2>/dev/null  # Redirect all potential errors to prevent them

    # Force set base directories - override any existing values
    LOG_DIR="/var/log/lab"
    TMP_DIR="/tmp/lab"
    export LOG_DIR TMP_DIR

    # Debug logging post-definition
    {
        printf '%s\n' "=== Post-Definition State ==="
        printf 'LOG_DIR set to: %s\n' "${LOG_DIR}"
        printf 'TMP_DIR set to: %s\n' "${TMP_DIR}"
        printf '%s\n\n' "=== End Post-Definition State ==="
    } >> "$debug_log"

    # LOG & TMP dir structures
    local base_dirs=("${LOG_DIR}" "${TMP_DIR}")
    local sub_dirs=("err" "lo" "tme" "rc")
    local required_dirs=()

    for base in "${base_dirs[@]}"; do
        required_dirs+=("$base")
        for sub in "${sub_dirs[@]}"; do
            required_dirs+=("$base/$sub")
        done
    done

    # Create all directories in one pass
    local -a failed_dirs=()
    local dir
    for dir in "${required_dirs[@]}"; do
        if ! mkdir -p "$dir" 2>/dev/null; then
            failed_dirs+=("$dir")
            printf 'Warning: Failed to create directory: %s\n' "$dir" >&2
            {
                printf 'FAILED to create directory: %s\n' "$dir"
                echo "Current permissions:"
                ls -ld "$(dirname "$dir")" 2>&1 || echo "Cannot access parent directory"
            } >> "$debug_log"
        else
            {
                printf 'Successfully created/verified directory: %s\n' "$dir"
                echo "Directory permissions:"
                ls -ld "$dir"
            } >> "$debug_log"
        fi
    done

    # Handle failures and set fallbacks
    if (( ${#failed_dirs[@]} > 0 )); then
        {
            printf '%s\n' "=== Directory Creation Failures ==="
            printf '%s\n' "${failed_dirs[@]}"
            echo "Warning: Some directories could not be created" >&2

            # Critical fallback: If main LOG_DIR fails, use TMP_DIR
            if [[ ! -d "$LOG_DIR" ]]; then
                printf 'LOG_DIR (%s) not accessible, falling back to TMP_DIR\n' "$LOG_DIR"
                LOG_DIR="$TMP_DIR"
                echo "Falling back to TMP_DIR for logging: $TMP_DIR" >&2

                # Attempt to create subdirectories in fallback location
                local subdir
                for subdir in err lo tme rc; do
                    if ! mkdir -p "${LOG_DIR}/${subdir}" 2>/dev/null; then
                        printf 'Warning: Failed to create fallback directory: %s/%s\n' "$LOG_DIR" "$subdir" >&2
                    fi
                done
            fi
        } >> "$debug_log"
    fi

    # Verify critical directories exist
    local -a critical_dirs=(
        "${LOG_DIR}"
        "${TMP_DIR}"
        "${LOG_DIR}/err"
        "${TMP_DIR}/err"
    )

    {
        printf '%s\n' "=== Critical Directory Verification ==="
        local missing_critical=0
        local dir
        for dir in "${critical_dirs[@]}"; do
            if [[ ! -d "$dir" ]]; then
                printf 'MISSING CRITICAL DIRECTORY: %s\n' "$dir"
                echo "Parent directory status:"
                ls -ld "$(dirname "$dir")" 2>&1 || echo "Cannot access parent directory"
                printf 'Critical: Required directory missing: %s\n' "$dir" >&2
                missing_critical=1
            else
                printf 'Verified critical directory exists: %s\n' "$dir"
                echo "Directory permissions:"
                ls -ld "$dir"
            fi
        done

        printf '%s\n' "=== Final State ==="
        printf 'Final LOG_DIR: %s\n' "${LOG_DIR}"
        printf 'Final TMP_DIR: %s\n' "${TMP_DIR}"
        printf 'Missing critical directories: %d\n' "$missing_critical"
        printf '%s\n\n' "=== End Directory Initialization ==="

        # Exit if critical directories are missing
        if (( missing_critical )); then
            echo "Fatal: Missing critical directories. Cannot continue." >&2
            return 1
        fi
    } >> "$debug_log"

    return 0
}

# Helper function to safely source files with improved error handling and logging
source_helper() {
    local file="$1"
    local description="${2:-$(basename "$file")}"

    start_timer "source_$description"

    if [[ ! -f "$file" ]]; then
        log "lvl" " Warning: File $description ($file) not found." | tee -a "$ERROR_LOG" >&2
        error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]}" "false"
        end_timer "source_$description"
        return 1
    fi

    if [[ ! -r "$file" ]]; then
        log "lvl" " Warning: File $description ($file) is not readable." | tee -a "$ERROR_LOG" >&2
        error_handler "$LINENO" "${ERROR_CODES[PERMISSION_DENIED]}" "false"
        end_timer "source_$description"
        return 1
    fi

    # Source the file and capture any errors
    local temp_error="/tmp/source_error.$$"
    if source "$file" 2>"$temp_error"; then
        log "lvl" "Successfully sourced: $description" | tee -a "$ERROR_LOG"
        end_timer "source_$description" "success"
        rm -f "$temp_error"
        return 0
    else
        local error=$(cat "$temp_error")
        log "lvl" " Error sourcing $description: $error" | tee -a "$ERROR_LOG" >&2
        rm -f "$temp_error"
        error_handler "$LINENO" "${ERROR_CODES[SOURCE_ERROR]}" "false"
        end_timer "source_$description" "error"
        return 1
    fi
}

# Function to source all files in a directory with consistent sorting and error handling
source_directory() {
    local dir="$1"
    local pattern="${2:-*}"
    local description="$3"
    local return_value=0

    start_timer "dir_$description"
    log "lvl" "Sourcing $description: $dir" | tee -a "$ERROR_LOG"

    if [[ ! -d "$dir" ]]; then
        log "lvl" " Warning: Directory $dir not found. Skipping." | tee -a "$ERROR_LOG" >&2
        end_timer "dir_$description"
        return 1
    fi

    # Get all matching files in the directory
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <(find "$dir" -maxdepth 1 -type f -name "$pattern" -print0 | sort -z)

    if [[ ${#files[@]} -eq 0 ]]; then
        log "lvl" " Warning: No matching files found in $dir" | tee -a "$ERROR_LOG" >&2
        end_timer "dir_$description"
        return 1
    fi

    # Source each file
    local success_count=0
    for file in "${files[@]}"; do
        if source_helper "$file" "$(basename "$file")"; then
            ((success_count++))
        fi
    done

    if ((success_count == 0)); then
        log "lvl" " Warning: No files were successfully sourced from $dir" | tee -a "$ERROR_LOG" >&2
        return_value=1
    else
        log "lvl" "Successfully sourced $success_count files from $dir" | tee -a "$ERROR_LOG"
        return_value=0
    fi

    end_timer "dir_$description"
    return $return_value
}

# Source the RC modules
source_rc() {
    log "lvl" "Sourcing primary RC modules"
    local rc_modules=("rc1" "rc2" "rc3")
    local success_count=0

    for module in "${rc_modules[@]}"; do
        if source_helper "$DIR/$module" "RC module $module"; then
            ((success_count++))
        fi
    done

    if ((success_count == 0)); then
        log "lvl" "Warning: No RC modules were successfully sourced"
        return 1
    fi

    return 0
}

# Source the environment files
source_env() {
    source_directory "$PARENT_DIR/env" "*" "environment configuration files"
    return $?
}

# Source the function files
source_fun() {
    source_directory "$PARENT_DIR/fun" "*" "function files"
    return $?
}

# Execute RC-specific setup functions
execution_rc() {
    log "lvl" "Starting ${FUNCNAME[0]}"
    start_timer "execution_rc"

    local setup_functions=("set_static" "set_dynamic" "set_aliaswrap")
    local success_count=0

    for func in "${setup_functions[@]}"; do
        start_nested_timing "setup_${func}"

        if ! type "$func" &>/dev/null; then
            log "lvl" "Warning: Function $func not found" | tee -a "$ERROR_LOG" >&2
            end_nested_timing "setup_${func}" "error_not_found"
            continue
        fi

        log "lvl" "Executing $func"
        if $func; then
            ((success_count++))
            end_nested_timing "setup_${func}" "success"
        else
            log "lvl" "Warning: $func failed" | tee -a "$ERROR_LOG" >&2
            end_nested_timing "setup_${func}" "error_execution"
        fi
    done

    local status=$((success_count > 0 ? "success" : "error"))
    end_timer "execution_rc" "$status"

    return $((success_count > 0 ? 0 : 1))
}

# Component execution with status tracking
execute_component() {
    local func="$1"
    local component="$2"
    local required="${3:-1}"  # Default to required
    local success_var="${component}_SUCCESS"
    local return_value=0

    start_timer "$component"
    echo | tee -a "$ERROR_LOG"
    log "lvl" " Executing component: $component" | tee -a "$ERROR_LOG"

    if ! type "$func" &>/dev/null; then
        log "lvl" " Error: Function $func not found" | tee -a "$ERROR_LOG" >&2
        error_handler "$LINENO" "${ERROR_CODES[FUNCTION_NOT_FOUND]}" "$([[ $required -eq 0 ]] && echo true || echo false)"
        return_value=1
    elif $func; then
        export "$success_var=1"
        log "lvl" " Component $component completed successfully" | tee -a "$ERROR_LOG"
        return_value=0
    else
        unset "$success_var"
        local msg="Component $component failed"
        if ((required)); then
            log "lvl" " Error: $msg" | tee -a "$ERROR_LOG" >&2
            error_handler "$LINENO" "${ERROR_CODES[EXECUTION_FAILED]}" "false"
            return_value=1
        else
            log "lvl" " Warning: $msg (optional component)" | tee -a "$ERROR_LOG" >&2
            error_handler "$LINENO" "${ERROR_CODES[EXECUTION_FAILED]}" "true"
            return_value=0
        fi
    fi

    end_timer "$component"
    return $return_value
}

# Central trap registration system
register_cleanup() {
    local module="$1"
    local function="$2"

    if [[ -n "$function" && $(type -t "$function") == "function" ]]; then
        CLEANUP_FUNCTIONS[$module]="$function"
        log "lvl" "Registered cleanup for module: $module"
    else
        log "lvl" "Failed to register cleanup for module: $module - invalid function"
        return 1
    fi
}

# Main cleanup orchestrator
main_cleanup() {
    log "lvl" "Starting main cleanup sequence"

    # First cleanup logging system
    if [[ -n "${CLEANUP_FUNCTIONS[lo]}" ]]; then
        ${CLEANUP_FUNCTIONS[lo]}
    fi

    # Then cleanup timing system
    if [[ -n "${CLEANUP_FUNCTIONS[tme]}" ]]; then
        ${CLEANUP_FUNCTIONS[tme]}
    fi

    # Finally cleanup error handling
    if [[ -n "${CLEANUP_FUNCTIONS[err]}" ]]; then
        ${CLEANUP_FUNCTIONS[err]}
    fi

    log "lvl" "Main cleanup sequence completed"
}

# Central error handler
main_error_handler() {
    local line_number="$1"
    local error_code="$2"

    # Call error handler from err module if available
    if type error_handler &>/dev/null; then
        error_handler "$line_number" "$error_code"
    fi
}

# Initialize trap system
initialize_traps() {
    if [[ "$TRAP_INITIALIZED" != "true" ]]; then
        # Remove any existing traps
        trap - EXIT
        trap - ERR

        # Set up main traps
        trap main_cleanup EXIT
        trap 'main_error_handler $LINENO $?' ERR

        TRAP_INITIALIZED=true
    fi
}

# Then in main_rc():
main_rc() {
    echo "    └─ Main RC : initializating"

    echo "    └─ Main RC : initialize_traps"
    initialize_traps

    echo "    └─ Main RC : initialize_environment"
    initialize_environment || {
        echo "Fatal: Environment initialization failed" >&2
        return 1
    }

    log "lvl" " Main RC : register_cleanup"
    register_cleanup "lo" "cleanup_logger"
    register_cleanup "tme" "cleanup_timer"
    register_cleanup "err" "clean_exit"

    log "lvl" " Main RC : setup_error_handling"
    setup_error_handling

    log "lvl" " Main RC : setting local components" | tee -a "$ERROR_LOG"
    local components=(
        "source_rc:RC:1"             # Required
        "source_env:ENV:0"           # Optional
        "source_fun:FUN:0"           # Optional
        "execution_rc:EXEC:1"        # Required
    )
    local failed_required=0

    for component in "${components[@]}"; do
        IFS=':' read -r func name required <<< "$component"

        if ! execute_component "$func" "$name" "$required"; then
            if ((required)); then
                failed_required=1
                log "lvl" " Required component $name failed" | tee -a "$ERROR_LOG" >&2
                echo
                break
            fi
        fi
    done

    if ((failed_required)); then
        unset RC_SOURCED
        log "lvl" " RC initialization failed: required component(s) failed" | tee -a "$ERROR_LOG" >&2
        echo
        print_timing_report
        print_error_report
        return 1
    else
        export RC_SOURCED=1
        echo
        log "lvl" " RC initialization completed successfully" | tee -a "$ERROR_LOG"
        print_timing_report
        print_error_report
        echo
        return 0
    fi
    tree > tree
}

# Execute the main function
main_rc
