#!/bin/bash

# ==== Directory Configuration ====
declare -gA DIR_PERMISSIONS=(
    ["${LAB_DIR}"]="755"
    ["${LAB_DIR}/env"]="750"
    ["${LAB_DIR}/fun"]="755"
    ["${LAB_DIR}/gen"]="755"
)

declare -gA DIR_FALLBACKS=(
    ["${LAB_DIR}"]="/tmp/lab"
    ["${LAB_DIR}/env"]="/tmp/lab/env"
    ["${LAB_DIR}/fun"]="/tmp/lab/fun"
    ["${LAB_DIR}/gen"]="/tmp/lab/gen"
)

# ==== Core RC1 Service ====
init_rc1() {
    debug_log "Initializing RC1 services"
    start_timer "rc1_init"

    local success=true

    # Initialize in specific order
    initialize_directories || success=false
    initialize_registry || success=false

    end_timer "rc1_init" "$([[ $success == true ]] && echo success || echo failed)"
    $success || return 1
    return 0
}

# ==== Directory Management ====
initialize_directories() {
    debug_log "Initializing directory structure"
    start_timer "dir_init"

    local failed_dirs=()
    local fallback_activated=false

    # Process each directory with its permissions
    for dir in "${!DIR_PERMISSIONS[@]}"; do
        local perm="${DIR_PERMISSIONS[$dir]}"

        if ! create_directory "$dir" "$perm"; then
            debug_log "Failed to create/verify directory: $dir"
            if ! handle_directory_fallback "$dir" "$perm"; then
                failed_dirs+=("$dir")
            else
                fallback_activated=true
            fi
        fi
    done

    # Export paths (potentially fallback paths)
    export_directory_paths

    # Handle failures
    if ((${#failed_dirs[@]} > 0)); then
        debug_log "Failed directories: ${failed_dirs[*]}"
        error_handler "$LINENO" "${ERROR_CODES[FILE_NOT_FOUND]:-1}" "false"
        end_timer "dir_init" "failed"
        return 1
    fi

    # Warn if using fallbacks
    if [[ "$fallback_activated" == true ]]; then
        echo "Warning: Using fallback directories. Check permissions." >&2
    fi

    end_timer "dir_init" "success"
    return 0
}

create_directory() {
    local dir="$1"
    local perm="$2"

    debug_log "Creating directory: $dir with permissions: $perm"

    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir" 2>/dev/null || return 1
    fi

    chmod "$perm" "$dir" 2>/dev/null || return 1

    # Verify directory is writable by current user
    if [[ ! -w "$dir" ]]; then
        debug_log "Directory not writable: $dir"
        return 1
    fi

    return 0
}

handle_directory_fallback() {
    local dir="$1"
    local perm="$2"
    local fallback="${DIR_FALLBACKS[$dir]}"

    if [[ -z "$fallback" ]]; then
        debug_log "No fallback defined for: $dir"
        return 1
    fi

    debug_log "Attempting fallback for $dir to $fallback"

    if create_directory "$fallback" "$perm"; then
        # Update global fallback tracking
        FALLBACK_PATHS["$dir"]="$fallback"
        export_directory_paths
        return 0
    fi

    return 1
}

export_directory_paths() {
    # Export main directory variables with fallback handling
    ENV_DIR="${FALLBACK_PATHS["$LAB_DIR/env"]:-$LAB_DIR/env}"
    FUN_DIR="${FALLBACK_PATHS["$LAB_DIR/fun"]:-$LAB_DIR/fun}"
    GEN_DIR="${FALLBACK_PATHS["$LAB_DIR/gen"]:-$LAB_DIR/gen}"

    export ENV_DIR FUN_DIR GEN_DIR

    debug_log "Exported paths:"
    debug_log "  ENV_DIR=$ENV_DIR"
    debug_log "  FUN_DIR=$FUN_DIR"
    debug_log "  GEN_DIR=$GEN_DIR"
}

# ==== Registry Management ====
initialize_registry() {
    debug_log "Initializing function registry"
    start_timer "registry_init"

    # Set up cleanup registry if not already initialized
    declare -gA CLEANUP_FUNCTIONS 2>/dev/null || true

    # Initialize basic signal handling
    setup_signal_handlers

    end_timer "registry_init" "success"
    return 0
}

setup_signal_handlers() {
    debug_log "Setting up signal handlers"

    # Don't duplicate handlers if already set
    if [[ "${SIGNAL_HANDLERS_INITIALIZED:-false}" != "true" ]]; then
        trap 'handle_exit' EXIT
        trap 'handle_error $? $LINENO' ERR
        SIGNAL_HANDLERS_INITIALIZED=true
    fi
}

handle_exit() {
    debug_log "Handling exit"
    cleanup_rc1
}

handle_error() {
    local err_code=$1
    local line_no=$2

    debug_log "Error on line $line_no: code $err_code"
    error_handler "$line_no" "$err_code" "false"
}

# ==== Cleanup ====
cleanup_rc1() {
    debug_log "Starting RC1 cleanup"

    # Clean up temporary resources if any
    for dir in "${!FALLBACK_PATHS[@]}"; do
        local fallback="${FALLBACK_PATHS[$dir]}"
        if [[ "$fallback" == /tmp/* && -d "$fallback" ]]; then
            debug_log "Cleaning up fallback directory: $fallback"
            rm -rf "$fallback" 2>/dev/null
        fi
    done
}

# ==== Helper Functions ====
get_rc1_status() {
    local dir_status="OK"
    local registry_status="OK"

    # Check directory status
    for dir in "${!DIR_PERMISSIONS[@]}"; do
        [[ ! -d "$dir" ]] && dir_status="FAIL"
    done

    # Check registry status
    [[ "${SIGNAL_HANDLERS_INITIALIZED:-false}" != "true" ]] && registry_status="FAIL"

    echo "RC1 Status:"
    echo "  Directories: $dir_status"
    echo "  Registry: $registry_status"
}

# ==== Export Functions ====
export -f get_rc1_status
