#!/bin/bash
#######################################################################
# Lab Environment Documentation README Generator
#######################################################################
# File: doc-hub
# Description: Automatically generates comprehensive documentation index 
#              using aux-lad for autonomous documentation discovery and 
#              updates the Documentation Structure section in doc/README.md
#
# Usage: ./doc-hub [--update|--analyze|--dry-run]
#   --update    Update the Documentation Structure section in doc/README.md
#   --analyze   Show documentation analysis without updating files
#   --dry-run   Preview changes without modifying doc/README.md
#   (default)   Update doc/README.md with current documentation index
#######################################################################

set -euo pipefail

# Initialize lab environment
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Set LAB_DIR if not already set
if [[ -z "${LAB_DIR:-}" ]]; then
    readonly LAB_DIR="$(dirname "$SCRIPT_DIR")"
fi

# Source required utilities
source "$LAB_DIR/lib/gen/aux"

# Configuration
readonly DOC_DIR="$LAB_DIR/doc"
readonly OUTPUT_FILE="$LAB_DIR/doc/README.md"

# Color definitions
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Enhanced logging functions
log() { 
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $*"
}

success() { 
    echo -e "${GREEN}✅${NC} $*"
}

warning() { 
    echo -e "${YELLOW}⚠️${NC} $*"
}

error() { 
    echo -e "${RED}❌${NC} $*"
}

# Function to count total documents using aux-lad JSON output
count_total_documents() {
    # Generate JSON output and count documents
    aux-lad -j "$DOC_DIR" >/dev/null 2>&1
    
    local json_file="$LAB_DIR/.tmp/doc/doc.json"
    if [[ -f "$json_file" ]]; then
        grep '"total_documents":' "$json_file" | awk -F: '{print $2}' | tr -d ' ,'
    else
        echo "0"
    fi
}

# Function to generate documentation table using JSON output from aux-lad
generate_documentation_table() {
    local category="$1"
    local icon="$2"
    local description="$3"
    local filter_pattern="$4"
    
    echo "#### $icon $category"
    echo "**Purpose**: $description"
    echo ""
    
    # Generate JSON output for the documentation directory
    aux-lad -j "$DOC_DIR" >/dev/null 2>&1
    
    local json_file="$LAB_DIR/.tmp/doc/doc.json"
    if [[ ! -f "$json_file" ]]; then
        echo "*No documentation found*"
        return
    fi
    
    # Parse JSON and filter by document type
    local temp_output="/tmp/doc_output_$$"
    
    # Extract documents from JSON and process each document
    # Use jq if available, otherwise use grep/sed approach
    if command -v jq >/dev/null 2>&1; then
        # Use jq for proper JSON parsing
        jq -c '.documents[]' "$json_file" 2>/dev/null | while IFS= read -r doc_json; do
            local doc_type=$(echo "$doc_json" | jq -r '.type')
            
            # Check if this document matches our filter
            if [[ "$doc_type" == "$filter_pattern" ]]; then
                local doc_path=$(echo "$doc_json" | jq -r '.path')
                local doc_title=$(echo "$doc_json" | jq -r '.title')
                local doc_description=$(echo "$doc_json" | jq -r '.description')
                local doc_lines=$(echo "$doc_json" | jq -r '.lines')
                local doc_words=$(echo "$doc_json" | jq -r '.words')
                
                # Remove 'doc/' prefix from path since we're generating for doc/README.md
                doc_path="${doc_path#doc/}"
                
                echo "- **[$doc_title]($doc_path)** - *($doc_lines lines, $doc_words words)* - $doc_description"
            fi
        done > "$temp_output"
    else
        # Fallback to grep/sed approach
        # Extract each document object from the JSON array
        sed -n '/\"documents\": \[/,/\]/p' "$json_file" | grep -o '{[^}]*}' | while IFS= read -r doc_line; do
            if [[ "$doc_line" =~ \"type\":\"([^\"]+)\" ]]; then
                local doc_type="${BASH_REMATCH[1]}"
                
                # Check if this document matches our filter
                if [[ "$doc_type" == "$filter_pattern" ]]; then
                    # Extract other fields from the same JSON object
                    local doc_path=$(echo "$doc_line" | sed -n 's/.*"path":"\([^"]*\)".*/\1/p')
                    local doc_title=$(echo "$doc_line" | sed -n 's/.*"title":"\([^"]*\)".*/\1/p')
                    local doc_description=$(echo "$doc_line" | sed -n 's/.*"description":"\([^"]*\)".*/\1/p')
                    local doc_lines=$(echo "$doc_line" | sed -n 's/.*"lines":\([0-9]*\).*/\1/p')
                    local doc_words=$(echo "$doc_line" | sed -n 's/.*"words":\([0-9]*\).*/\1/p')
                    
                    # Remove 'doc/' prefix from path since we're generating for doc/README.md
                    doc_path="${doc_path#doc/}"
                    
                    echo "- **[$doc_title]($doc_path)** - *($doc_lines lines, $doc_words words)* - $doc_description"
                fi
            fi
        done > "$temp_output"
    fi
    
    # Check if any documents were found and display results
    if [[ -s "$temp_output" ]]; then
        cat "$temp_output"
    else
        echo "*No documents found in this category*"
    fi
    
    # Clean up temp file
    rm -f "$temp_output"
    
    echo ""
}

# Function to map category types to actual directory names
map_category_to_directory() {
    local category="$1"
    case "$category" in
        "Admin") echo "adm" ;;
        "Developer") echo "dev" ;;
        "CLI") echo "cli" ;;
        "Core") echo "core" ;;
        "IaC") echo "iac" ;;
        *) echo "${category,,}" ;;  # Default to lowercase
    esac
}

# Function to extract category metadata from README files
extract_category_metadata_from_readme() {
    local category="$1"
    local dir_name=$(map_category_to_directory "$category")
    local readme_path="$DOC_DIR/$dir_name/README.md"
    
    if [[ -f "$readme_path" ]]; then
        # Extract the first line with # (title) and the description
        local title_line=$(grep -m1 '^# ' "$readme_path" 2>/dev/null)
        local description_line=$(sed -n '3p' "$readme_path" 2>/dev/null)  # Usually line 3 has the description
        
        if [[ -n "$title_line" ]]; then
            # Extract emoji and clean title from the README
            # More robust emoji extraction that handles complex Unicode emojis
            local title_content=$(echo "$title_line" | sed 's/^# *//')
            local icon=""
            local clean_title=""
            
            # Extract emoji(s) from the beginning of the title
            if [[ "$title_content" =~ ^([^a-zA-Z]*)[[:space:]]*(.*) ]]; then
                icon="${BASH_REMATCH[1]}"
                clean_title="${BASH_REMATCH[2]}"
            else
                # Fallback if regex doesn't match
                icon="📄"
                clean_title="$title_content"
            fi
            
            # Clean up any extra whitespace
            icon=$(echo "$icon" | sed 's/[[:space:]]*$//')
            clean_title=$(echo "$clean_title" | sed 's/^[[:space:]]*//')
            
            # Use description from README if available, otherwise use a generic one
            local description="$description_line"
            if [[ -z "$description" || "$description" =~ ^[[:space:]]*$ ]]; then
                description="Documentation category: $category"
            fi
            
            echo "${icon}|${description}|${clean_title}"
        else
            # Fallback if README parsing fails
            echo "📄|Documentation category: $category|$category Documentation"
        fi
    else
        # Fallback if README doesn't exist
        echo "📄|Documentation category: $category|$category Documentation"
    fi
}

# Function to generate all documentation categories dynamically
generate_all_documentation_categories() {
    # Generate JSON output for the documentation directory
    aux-lad -j "$DOC_DIR" >/dev/null 2>&1
    
    local json_file="$LAB_DIR/.tmp/doc/doc.json"
    if [[ ! -f "$json_file" ]]; then
        echo "*No documentation found*"
        return
    fi
    
    # Extract unique categories from JSON, excluding Hub and Index types
    local categories
    if command -v jq >/dev/null 2>&1; then
        # Use jq for proper JSON parsing
        categories=$(jq -r '.documents[].type' "$json_file" 2>/dev/null | grep -v -E '^(Hub|Index)$' | sort -u)
    else
        # Fallback to grep/sed approach
        categories=$(grep -o '"type":"[^"]*"' "$json_file" | cut -d'"' -f4 | grep -v -E '^(Hub|Index)$' | sort -u)
    fi
    
    # Generate documentation table for each category
    while IFS= read -r category; do
        if [[ -n "$category" ]]; then
            local metadata=$(extract_category_metadata_from_readme "$category")
            local icon="${metadata%%|*}"
            local temp="${metadata#*|}"
            local description="${temp%%|*}"
            local display_name="${temp#*|}"
            
            # Clean up description if it's empty or just whitespace
            if [[ -z "$description" || "$description" =~ ^[[:space:]]*$ ]]; then
                description="Documentation for $category"
            fi
            
            generate_documentation_table "$display_name" "$icon" "$description" "$category"
        fi
    done <<< "$categories"
}

# Generate the comprehensive documentation index
generate_documentation_index() {
    local total_docs=$(count_total_documents)
    
    cat << EOF
## 📊 Documentation Index

*Auto-updated documentation index with real-time metadata*

> **Last Updated**: $(date '+%Y-%m-%d %H:%M:%S')  
> **Generated By**: \`utl/doc-hub\` using \`aux-lad\`  
> **Total Documents**: $total_docs documents

This index provides a comprehensive overview of all documentation in the system:

EOF

    # Generate sections for each documentation category dynamically
    generate_all_documentation_categories
    
    cat << 'EOF'

### **🔧 Documentation Tools**
- **[`utl/doc-hub`](../utl/doc-hub)** - Updates this documentation index automatically using `aux-lad`
- **[`lib/gen/aux` (aux-lad)](../lib/gen/aux)** - Documentation listing and analysis function
- **[`utl/doc-func`](../utl/doc-func)** - Function metadata table generator using `aux-laf`
- **[`utl/doc-stats`](../utl/doc-stats)** - Generate real-time codebase statistics and update README metrics

```bash
# Update documentation index in doc/README.md
./utl/doc-hub

# List all documentation with metadata
aux-lad doc

# Generate documentation metadata as JSON
aux-lad -j doc

# Update function metadata table
./utl/doc-func
```

EOF
}

# Function to update the README.md file
update_readme_file() {
    local temp_file=$(mktemp)
    local in_doc_section=false
    local found_first_section=false
    local doc_section_found=false
    
    log "Updating documentation index section in doc/README.md..."
    
    # Read the original file and replace the documentation section
    while IFS= read -r line; do
        if [[ "$line" == "## 📊 Documentation Index" ]]; then
            # Found existing documentation index section - mark it and insert new one
            doc_section_found=true
            in_doc_section=true
            echo "" >> "$temp_file"
            generate_documentation_index >> "$temp_file"
            continue
        elif [[ "$in_doc_section" == true && "$line" =~ ^##[[:space:]] ]]; then
            # Found the next section after doc index, stop skipping
            in_doc_section=false
            echo "$line" >> "$temp_file"
        elif [[ "$in_doc_section" == false ]]; then
            # Not in doc section, write the line
            echo "$line" >> "$temp_file"
            
            # Check if this is the first ## section we encounter (and no doc section exists yet)
            if [[ "$line" =~ ^##[[:space:]] && "$found_first_section" == false && "$doc_section_found" == false ]]; then
                found_first_section=true
                # Insert documentation index after the first section
                echo "" >> "$temp_file"
                generate_documentation_index >> "$temp_file"
            fi
        fi
        # If in_doc_section is true, we skip the line (don't write it)
    done < "$OUTPUT_FILE"
    
    # If we never found an existing doc section and never found a first section,
    # append the documentation index at the end
    if [[ "$doc_section_found" == false && "$found_first_section" == false ]]; then
        echo "" >> "$temp_file"
        generate_documentation_index >> "$temp_file"
    fi
    
    # Replace the original file
    mv "$temp_file" "$OUTPUT_FILE"
    success "Documentation index updated successfully in doc/README.md"
}

# Function to analyze documentation without updating files
analyze_documentation() {
    log "Analyzing documentation structure..."
    
    local total_docs=$(count_total_documents)
    
    cat << EOF
📚 Documentation Analysis Report
===============================

📊 Overview:
- Total Documents: $total_docs
- Documentation Directory: $DOC_DIR
- Analysis Method: Autonomous using aux-lad

🏗️ Structure Analysis:
EOF
    
    # Show the documentation structure that would be generated
    echo ""
    echo "Documentation categories found:"
    aux-lad "$DOC_DIR" | grep -E "^\| (Developer|Admin|IaC|CLI|Core|Hub|Index)" | awk -F'|' '{print "- " $2 ": " $3}' | sort | uniq -c
    
    echo ""
    echo "📋 Sample of documentation that would be indexed:"
    aux-lad -t "$DOC_DIR"
}

# Function to preview changes without updating
preview_changes() {
    log "Generating preview of documentation index changes..."
    
    cat << 'EOF'
📋 Preview of Documentation Index Changes
=========================================

The following content would replace the "Documentation Index" section in doc/README.md:

---
EOF

    generate_documentation_index

    cat << 'EOF'
---

🔍 Changes Summary:
- Automatically discovered documentation using aux-lad
- Generated categorized documentation listings
- Included real-time metadata (lines, words, modification dates)
- Organized by documentation type and purpose

To apply these changes, run: ./utl/doc-hub --update
EOF
}

# Main execution function
main() {
    local action="${1:-update}"
    
    # Ensure documentation directory exists
    if [[ ! -d "$DOC_DIR" ]]; then
        error "Documentation directory not found: $DOC_DIR"
        exit 1
    fi
    
    # Ensure README.md exists
    if [[ ! -f "$OUTPUT_FILE" ]]; then
        error "doc/README.md not found: $OUTPUT_FILE"
        exit 1
    fi
    
    case "$action" in
        --update|update)
            update_readme_file
            ;;
        --analyze|analyze)
            analyze_documentation
            ;;
        --dry-run|dry-run|preview)
            preview_changes
            ;;
        *)
            error "Invalid action: $action"
            echo "Usage: $0 [--update|--analyze|--dry-run]"
            exit 1
            ;;
    esac
}

# Execute if run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
