#!/bin/bash
#######################################################################
# Lab Environment Variable Usage Documentation Generator
#######################################################################
# File: doc-var
# Description: Automatic variable usage documentation generator that populates 
#              the variable usage table in doc/dev/variables.md using 
#              aux_ffl and aux_acu to extract variable information from cfg/env, lib/ops, and src/set directories
#
# Usage: ./doc-var
#   (default)   Updates the variable usage table in doc/dev/variables.md
#######################################################################

set -e

# Initialize lab environment
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Set LAB_DIR if not already set
if [[ -z "${LAB_DIR:-}" ]]; then
    readonly LAB_DIR="$(dirname "$SCRIPT_DIR")"
fi

# Source required utilities
source "$LAB_DIR/lib/gen/aux"

# Define target directories
CFG_ENV_DIR="$LAB_DIR/cfg/env"
LIB_OPS_DIR="$LAB_DIR/lib/ops"
SRC_SET_DIR="$LAB_DIR/src/set"

# Output file
DOC_FILE="$LAB_DIR/doc/dev/variables.md"

# Function to count total variables from configuration
count_total_variables() {
    # Always use fallback method to avoid aux_acu hanging issue
    local total=0
    for file in "$CFG_ENV_DIR"/*; do
        if [[ -f "$file" ]]; then
            local count=$(grep -cE '^[a-zA-Z0-9_]+=' "$file" 2>/dev/null || echo "0")
            total=$((total + count))
        fi
    done
    echo "$total"
}

# Function to generate variable usage table
generate_variable_table() {
    # First, count all variables by processing them
    local total_variables=$(count_total_variables)
    
    # Generate header with actual variable count
    cat << EOF
*Auto-updated variable usage documentation with real-time analysis*

> **Last Updated**: $(date '+%Y-%m-%d %H:%M:%S')  
> **Generated By**: \`utl/doc-var\`  
> **Total Variables**: $total_variables variables analyzed across all configuration files
> **Analysis Command**: \`aux_ffl aux_acu "" "\$CFG_ENV_DIR" "\$LIB_OPS_DIR" "\$SRC_SET_DIR"\`

This documentation provides a comprehensive overview of variable usage across the lab environment:

### **ðŸ“Š Variable Analysis Overview**

Variables are analyzed across three key directories:
- **Configuration Environment** (\`cfg/env/\`) - Environment-specific configuration files
- **Operations Libraries** (\`lib/ops/\`) - Infrastructure and operations function libraries  
- **Deployment Scripts** (\`src/set/\`) - Deployment and setup automation scripts

### **ðŸ“– Variable Usage Table**

| Variable | Value | Total Usage | lib/ops | src/set | cfg/env |
|----------|-------|-------------|---------|---------|---------|
EOF
    
    # Process and output variables using JSON
    process_variables_from_json
}

# Function to process variables using fallback method only
process_variables_from_json() {
    # Always use fallback method to avoid aux_acu hanging issue
    # No debug output here to avoid breaking markdown table format
    extract_variables_fallback
}

# Fallback function to extract variables when aux_acu fails
extract_variables_fallback() {
    declare -A variables
    declare -a var_order
    
    # Extract variables from config files
    for file in "$CFG_ENV_DIR"/*; do
        if [[ -f "$file" ]]; then
            while IFS= read -r line || [[ -n "$line" ]]; do
                if [[ "$line" =~ ^[[:space:]]*# || -z "$line" || "$line" =~ ^[[:space:]]*declare || ! "$line" =~ = ]]; then
                    continue
                fi
                local var_raw value_raw
                var_raw=$(echo "$line" | cut -d'=' -f1)
                value_raw=$(echo "$line" | cut -d'=' -f2-)
                var=$(echo "$var_raw" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                if [[ ! "$var" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
                    continue
                fi
                value=$(echo "$value_raw" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^"\\(.*\\)"$/\\1/' -e "s/^'\\([^']*\)'$/\\1/")
                if [[ -n "$var" ]]; then
                    variables["$var"]="$value"
                    if ! printf '%s\n' "${var_order[@]}" 2>/dev/null | grep -qFx "$var"; then
                        var_order+=("$var")
                    fi
                fi
            done < "$file"
        fi
    done
    
    # Generate table rows
    for var in "${var_order[@]}"; do
        local var_value="${variables[$var]}"
        
        # Count usage in each directory
        local ops_usage=0
        local set_usage=0
        
        if [[ -d "$LIB_OPS_DIR" ]]; then
            for file in "$LIB_OPS_DIR"/*; do
                if [[ -f "$file" && -r "$file" ]]; then
                    local count=$(grep -E -o "\\b${var}\\b" "$file" 2>/dev/null | wc -l)
                    if [[ "$count" =~ ^[0-9]+$ ]]; then
                        ops_usage=$((ops_usage + count))
                    fi
                fi
            done
        fi
        
        if [[ -d "$SRC_SET_DIR" ]]; then
            for file in "$SRC_SET_DIR"/*; do
                if [[ -f "$file" && -r "$file" ]]; then
                    local count=$(grep -E -o "\\b${var}\\b" "$file" 2>/dev/null | wc -l)
                    if [[ "$count" =~ ^[0-9]+$ ]]; then
                        set_usage=$((set_usage + count))
                    fi
                fi
            done
        fi
        
        local cfg_usage=1  # Variable is defined in config
        local total_usage=$((ops_usage + set_usage + cfg_usage))
        
        # Truncate long values for display
        local display_value="$var_value"
        if [[ ${#display_value} -gt 25 ]]; then
            display_value="${display_value:0:22}..."
        fi
        
        # Output the table row
        echo "| $var | $display_value | $total_usage | $ops_usage | $set_usage | $cfg_usage |"
    done
}

# Function to parse variables using the simple, proven approach
parse_variables_simple() {
    local json_file="$1"
    
    # Extract each variable using grep and process line by line
    grep -n '"name":' "$json_file" | while IFS=: read -r line_num line_content; do
        if [[ "$line_content" =~ \"name\":[[:space:]]*\"([^\"]+)\" ]]; then
            local var_name="${BASH_REMATCH[1]}"
            
            # Get the variable block (next 20 lines from this line should contain all needed info)
            local var_block=$(sed -n "${line_num},$((line_num + 20))p" "$json_file")
            
            # Extract value - handle different value formats
            local var_value=""
            # Match quoted values that may contain escaped quotes or special characters
            if [[ "$var_block" =~ \"value\":[[:space:]]*\"([^\"]*)\", ]]; then
                var_value="${BASH_REMATCH[1]}"
            # Match unquoted values (arrays, numbers, etc.) - look for value followed by comma
            elif [[ "$var_block" =~ \"value\":[[:space:]]*([^,]+), ]]; then
                var_value="${BASH_REMATCH[1]}"
                # Clean up whitespace and quotes
                var_value="${var_value## }"
                var_value="${var_value%% }"
                var_value="${var_value#\"}"
                var_value="${var_value%\"}"
            fi
            
            # Extract total occurrences
            local var_total="0"
            if [[ "$var_block" =~ \"total_occurrences\":[[:space:]]*([0-9]+) ]]; then
                var_total="${BASH_REMATCH[1]}"
            fi
            
            # Extract ops usage - look for ops path in usage_by_folder
            local ops_usage="0"
            if [[ "$var_block" =~ \"path\":\"ops\",\"total_occurrences\":([0-9]+) ]]; then
                ops_usage="${BASH_REMATCH[1]}"
            fi
            
            # Extract set usage - look for set path in usage_by_folder
            local set_usage="0"
            if [[ "$var_block" =~ \"path\":\"set\",\"total_occurrences\":([0-9]+) ]]; then
                set_usage="${BASH_REMATCH[1]}"
            fi
            
            # Calculate cfg/env usage (total - ops - set)
            local cfg_usage=$((var_total - ops_usage - set_usage))
            if [[ $cfg_usage -lt 0 ]]; then
                cfg_usage=0
            fi
            
            # Truncate long values for display
            local display_value="$var_value"
            if [[ ${#display_value} -gt 25 ]]; then
                display_value="${display_value:0:22}..."
            fi
            
            # Output the table row with proper cfg/env usage
            echo "| $var_name | $display_value | $var_total | $ops_usage | $set_usage | $cfg_usage |"
        fi
    done
}

# Function to update the documentation file
update_documentation() {
    local temp_file=$(mktemp)
    local in_auto_section=false
    
    echo "Updating variable usage table in $DOC_FILE..."
    
    # Check if the file exists, create if not
    if [[ ! -f "$DOC_FILE" ]]; then
        cat > "$DOC_FILE" << 'EOF'
<!-- 
    This documentation provides comprehensive analysis of variable usage across the lab environment.
    Variables are analyzed from configuration files and their usage patterns across different modules.
    
    The analysis covers:
    - cfg/env/  : Environment-specific configuration files
    - lib/ops/  : Operations function libraries
    - src/set/  : Deployment and setup automation scripts
-->

# Variable Usage Documentation

Comprehensive analysis of environment variables and their usage patterns across the Lab Environment Management System.

## ðŸ“š Variable Categories

Variables in the lab environment are organized into several categories:

### Environment Configuration (`cfg/env/`)
- **Site Configuration**: Site-specific settings and parameters
- **Environment Overrides**: Development, testing, and production overrides
- **Node Configuration**: Node-specific infrastructure settings

### Operations Integration (`lib/ops/`)
- **Infrastructure Functions**: Variables used in infrastructure management
- **System Operations**: Variables for system-level operations
- **Service Management**: Variables for service configuration and management

### Deployment Scripts (`src/set/`)
- **Deployment Parameters**: Variables used in deployment automation
- **Setup Configuration**: Variables for environment setup and initialization
- **Runtime Constants**: Variables for runtime behavior control

<!-- AUTO-GENERATED SECTION: DO NOT EDIT MANUALLY -->

<!-- END AUTO-GENERATED SECTION -->

## ðŸ”§ Variable Analysis Tools

- **[`utl/doc-var`](../utl/doc-var)** - Updates this variable usage documentation automatically using `aux_acu`
- **[`lib/gen/aux` (aux_acu)](../lib/gen/aux)** - Variable usage analysis function with JSON output support
- **[`utl/doc-func`](../utl/doc-func)** - Function metadata table generator
- **[`utl/doc-index`](../utl/doc-index)** - Documentation index generator

```bash
# Update variable usage documentation
./utl/doc-var

# Analyze variable usage manually
aux_acu "" cfg/env lib/ops src/set

# Generate variable analysis as JSON
aux_acu -j "" cfg/env lib/ops src/set

# View specific variable usage patterns
aux_acu -a cfg/env lib/ops src/set  # Alphabetical order
```

## ðŸ“– Related Documentation

- **[Functions Reference](functions.md)** - Pure function documentation and metadata
- **[System Architecture](architecture.md)** - Complete system design and variable flow
- **[Configuration Guide](../adm/configuration.md)** - Configuration file formats and variable definitions
EOF
    fi
    
    # Read the original file and replace the auto-generated section
    while IFS= read -r line; do
        if [[ "$line" == *"<!-- AUTO-GENERATED SECTION: DO NOT EDIT MANUALLY -->"* ]]; then
            echo "$line" >> "$temp_file"
            echo "<!-- Command: aux_ffl aux_acu \"\" \"\$CFG_ENV_DIR\" \"\$LIB_OPS_DIR\" \"\$SRC_SET_DIR\" -->" >> "$temp_file"
            echo "" >> "$temp_file"
            
            # Generate variable table with real-time data
            generate_variable_table >> "$temp_file"
            
            echo "" >> "$temp_file"
            in_auto_section=true
        elif [[ "$line" == *"<!-- END AUTO-GENERATED SECTION -->"* ]]; then
            echo "$line" >> "$temp_file"
            in_auto_section=false
        elif [[ "$in_auto_section" == false ]]; then
            echo "$line" >> "$temp_file"
        fi
    done < "$DOC_FILE"
    
    # Replace the original file
    mv "$temp_file" "$DOC_FILE"
    echo "Variable usage documentation updated successfully."
}

# Main execution
main() {
    echo "Generating variable usage documentation..."
    echo "Analyzing directories: cfg/env, lib/ops, src/set"
    
    # Check if required directories exist
    for dir in "$CFG_ENV_DIR" "$LIB_OPS_DIR" "$SRC_SET_DIR"; do
        if [[ ! -d "$dir" ]]; then
            echo "Error: Directory $dir not found"
            exit 1
        fi
    done
    
    # Create documentation directory if it doesn't exist
    mkdir -p "$(dirname "$DOC_FILE")"
    
    # Update the documentation
    update_documentation
    
    echo "Variable usage documentation generation complete."
}

# Execute main function
main "$@"
