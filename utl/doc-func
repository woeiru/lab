#!/bin/bash

# utl/doc-func - Automatic function metadata table generator
# Populates the function metadata table in doc/dev/functions.md
# Uses aux-ffl and aux-laf to extract function information from lib/ directories

# Set script directory and lab root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LAB_DIR="$(dirname "$SCRIPT_DIR")"

# Source required utilities
source "$LAB_DIR/lib/ops/aux"

# Define library directories
LIB_CORE_DIR="$LAB_DIR/lib/core"
LIB_OPS_DIR="$LAB_DIR/lib/ops"
LIB_GEN_DIR="$LAB_DIR/lib/gen"

# Output file
DOC_FILE="$LAB_DIR/doc/dev/functions.md"

# Function to generate metadata table
generate_function_table() {
    echo "| Library | Module | Function | Description |"
    echo "|---------|--------|----------|-------------|"
    
    # Process core functions
    echo "<!-- CORE FUNCTIONS -->"
    process_library_functions "core" "$LIB_CORE_DIR"
    
    # Process ops functions
    echo "<!-- OPS FUNCTIONS -->"
    process_library_functions "ops" "$LIB_OPS_DIR"
    
    # Process gen functions
    echo "<!-- GEN FUNCTIONS -->"
    process_library_functions "gen" "$LIB_GEN_DIR"
}

# Function to process functions from a library directory using JSON output
process_library_functions() {
    local lib_name="$1"
    local lib_dir="$2"
    
    # Use centralized .tmp/doc directory
    local tmp_dir="$LAB_DIR/.tmp/doc"
    mkdir -p "$tmp_dir"
    
    # Process each file in the library directory
    for file in "$lib_dir"/*; do
        if [[ -f "$file" ]]; then
            # Generate JSON output using aux-laf with -j flag
            aux-laf -j "$file" >/dev/null 2>&1
            
            # Generate JSON filename based on file path structure
            local relative_path="${file#$LAB_DIR/}"
            local json_filename="${relative_path//\//_}.json"
            local json_file="$tmp_dir/$json_filename"
            
            if [[ -f "$json_file" ]]; then
                local module_name=$(basename "$file")
                
                # Parse JSON and extract function information
                # Using a simple approach since we control the JSON format
                local in_functions=false
                local in_function=false
                local func_name=""
                local func_desc=""
                
                while IFS= read -r line; do
                    # Remove leading/trailing whitespace
                    line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    
                    if [[ "$line" == '"functions": [' ]]; then
                        in_functions=true
                        continue
                    fi
                    
                    if [[ "$in_functions" == true && "$line" == "{" ]]; then
                        in_function=true
                        func_name=""
                        func_desc=""
                        continue
                    fi
                    
                    if [[ "$in_function" == true ]]; then
                        if [[ "$line" =~ \"name\":[[:space:]]*\"([^\"]+)\" ]]; then
                            func_name="${BASH_REMATCH[1]}"
                        elif [[ "$line" =~ \"description\":[[:space:]]*\"([^\"]*)\" ]]; then
                            func_desc="${BASH_REMATCH[1]}"
                        elif [[ "$line" == "}" ]]; then
                            # End of function object - output the row
                            if [[ -n "$func_name" ]]; then
                                echo "| $lib_name | $module_name | $func_name | $func_desc |"
                            fi
                            in_function=false
                        fi
                    fi
                    
                    if [[ "$line" == "]" && "$in_functions" == true ]]; then
                        in_functions=false
                        break
                    fi
                done < "$json_file"
            fi
        fi
    done
    
    # Keep JSON files for reference (they will be overwritten on next run)
    echo "JSON files preserved in: $tmp_dir"
}

# Function to update the documentation file
update_documentation() {
    local temp_file=$(mktemp)
    local in_auto_section=false
    
    echo "Updating function metadata table in $DOC_FILE..."
    
    # Read the original file and replace the auto-generated section
    while IFS= read -r line; do
        if [[ "$line" == *"<!-- AUTO-GENERATED SECTION: DO NOT EDIT MANUALLY -->"* ]]; then
            echo "$line" >> "$temp_file"
            echo "<!-- Command: aux-ffl aux-laf \"\" \"\$LIB_CORE_DIR\" & aux-ffl aux-laf \"\" \"\$LIB_OPS_DIR\" & aux-ffl aux-laf \"\" \"\$LIB_GEN_DIR\" -->" >> "$temp_file"
            echo "" >> "$temp_file"
            generate_function_table >> "$temp_file"
            echo "" >> "$temp_file"
            in_auto_section=true
        elif [[ "$line" == *"<!-- END AUTO-GENERATED SECTION -->"* ]]; then
            echo "$line" >> "$temp_file"
            in_auto_section=false
        elif [[ "$in_auto_section" == false ]]; then
            echo "$line" >> "$temp_file"
        fi
    done < "$DOC_FILE"
    
    # Replace the original file
    mv "$temp_file" "$DOC_FILE"
    echo "Function metadata table updated successfully."
}

# Main execution
main() {
    echo "Generating function metadata table..."
    echo "Processing libraries: core, ops, gen"
    
    # Check if required directories exist
    for dir in "$LIB_CORE_DIR" "$LIB_OPS_DIR" "$LIB_GEN_DIR"; do
        if [[ ! -d "$dir" ]]; then
            echo "Error: Directory $dir not found"
            exit 1
        fi
    done
    
    # Check if documentation file exists
    if [[ ! -f "$DOC_FILE" ]]; then
        echo "Error: Documentation file $DOC_FILE not found"
        exit 1
    fi
    
    # Update the documentation
    update_documentation
    
    echo "Function metadata table generation complete."
}

# Execute main function
main "$@"
