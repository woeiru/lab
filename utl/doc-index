#!/bin/bash
#######################################################################
# Lab Environment Documentation Index Generator
#######################################################################
# File: doc-index
# Description: Automatically generates comprehensive documentation index 
#              using aux-lad for autonomous documentation discovery and 
#              updates the Documentation Structure section in README.md
#
# Usage: ./doc-index [--update|--analyze|--dry-run]
#   --update    Update the Documentation Structure section in README.md
#   --analyze   Show documentation analysis without updating files
#   --dry-run   Preview changes without modifying README.md
#   (default)   Update README.md with current documentation index
#######################################################################

set -euo pipefail

# Initialize lab environment
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Set LAB_DIR if not already set
if [[ -z "${LAB_DIR:-}" ]]; then
    readonly LAB_DIR="$(dirname "$SCRIPT_DIR")"
fi

# Source required utilities
source "$LAB_DIR/lib/ops/aux"

# Configuration
readonly DOC_DIR="$LAB_DIR/doc"
readonly OUTPUT_FILE="$LAB_DIR/README.md"
readonly BACKUP_FILE="$LAB_DIR/README.md.backup"

# Color definitions
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Enhanced logging functions
log() { 
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $*"
}

success() { 
    echo -e "${GREEN}âœ…${NC} $*"
}

warning() { 
    echo -e "${YELLOW}âš ï¸${NC} $*"
}

error() { 
    echo -e "${RED}âŒ${NC} $*"
}

# Function to count total documents using aux-lad JSON output
count_total_documents() {
    # Generate JSON output and count documents
    aux-lad -j "$DOC_DIR" >/dev/null 2>&1
    
    local json_file="$LAB_DIR/.tmp/doc/doc.json"
    if [[ -f "$json_file" ]]; then
        grep '"total_documents":' "$json_file" | awk -F: '{print $2}' | tr -d ' ,'
    else
        echo "0"
    fi
}

# Function to generate documentation table from aux-lad JSON output
generate_documentation_table() {
    local category="$1"
    local icon="$2"
    local description="$3"
    local filter_pattern="$4"
    
    # Generate JSON output for the documentation directory
    aux-lad -j "$DOC_DIR" >/dev/null 2>&1
    
    local json_file="$LAB_DIR/.tmp/doc/doc.json"
    if [[ ! -f "$json_file" ]]; then
        echo "*No documentation found*"
        return
    fi
    
    echo "#### $icon $category"
    echo "**Purpose**: $description"
    echo ""
    
    # Use a simpler approach - directly parse the aux-lad output and filter
    # First, let's just re-run aux-lad and parse its table output directly
    local temp_table="/tmp/aux_lad_output_$$"
    aux-lad "$DOC_DIR" > "$temp_table" 2>/dev/null
    
    # Parse the table output and filter by type
    local found_docs=false
    while IFS='|' read -r type_col path_col title_col desc_col lines_col words_col modified_col; do
        # Clean up the columns (remove leading/trailing spaces and pipe characters)
        local doc_type=$(echo "$type_col" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local doc_path=$(echo "$path_col" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local doc_title=$(echo "$title_col" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local doc_description=$(echo "$desc_col" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local doc_lines=$(echo "$lines_col" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local doc_words=$(echo "$words_col" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip header and separator lines
        if [[ "$doc_type" =~ ^(Type|[-+]+)$ ]] || [[ -z "$doc_type" ]]; then
            continue
        fi
        
        # Check if this document matches our filter
        if [[ "$doc_type" == "$filter_pattern" ]]; then
            echo "- **[$doc_title]($doc_path)** - *($doc_lines lines, $doc_words words)* - $doc_description"
            found_docs=true
        fi
    done < "$temp_table"
    
    # Clean up temp file
    rm -f "$temp_table"
    
    # If no documents found, show a placeholder
    if [[ "$found_docs" == false ]]; then
        echo "*No documents found in this category*"
    fi
    
    echo ""
}

# Generate the comprehensive documentation index
generate_documentation_index() {
    local total_docs=$(count_total_documents)
    
    cat << EOF
## ğŸ“š Documentation Structure

*Auto-updated documentation index with real-time metadata*

> **Last Updated**: $(date '+%Y-%m-%d %H:%M:%S')  
> **Generated By**: \`utl/doc-index\` using \`aux-lad\`  
> **Total Documents**: $total_docs documents

Our documentation is organized for both quick reference and comprehensive guidance:

### **ğŸ“‹ Quick Reference (Folder READMEs)**
Individual folder READMEs provide immediate context when browsing directories with quick orientation for developers and direct links to detailed documentation.

### **ğŸ“– Comprehensive Documentation (\`/doc/\`)**

EOF

    # Generate sections for each documentation category
    generate_documentation_table "Documentation Hub" "ğŸ“š" "Central navigation and documentation organization" "Hub"
    generate_documentation_table "Developer Documentation" "ğŸ‘¨â€ğŸ’»" "Technical guides, API references, and integration documentation" "Developer"
    generate_documentation_table "System Administrator Documentation" "ğŸ› ï¸" "Operations, configuration, and system management guides" "Admin"
    generate_documentation_table "Infrastructure as Code Documentation" "ğŸ—ï¸" "Infrastructure automation, deployment guides, and environment management" "IaC"
    generate_documentation_table "Command-Line Interface Documentation" "ğŸ“±" "CLI guides, command references, and user interaction documentation" "CLI"
    generate_documentation_table "Core Documentation" "ğŸ“‹" "Standards, architecture principles, and foundational documents" "Core"
    
    cat << 'EOF'

### **ğŸ”§ Documentation Tools**
- **[`utl/doc-index`](utl/doc-index)** - Updates this documentation section automatically using `aux-lad`
- **[`lib/ops/aux` (aux-lad)](lib/ops/aux)** - Documentation listing and analysis function
- **[`utl/doc-func`](utl/doc-func)** - Function metadata table generator using `aux-laf`
- **[`utl/doc-stats`](utl/doc-stats)** - Generate real-time codebase statistics and update README metrics

```bash
# Update documentation index in README.md
./utl/doc-index

# List all documentation with metadata
aux-lad doc

# Generate documentation metadata as JSON
aux-lad -j doc

# Update function metadata table
./utl/doc-func
```

EOF
}

# Function to update the README.md file
update_readme_file() {
    local temp_file=$(mktemp)
    local in_doc_section=false
    
    log "Creating backup of README.md..."
    cp "$OUTPUT_FILE" "$BACKUP_FILE"
    
    log "Updating documentation section in README.md..."
    
    # Read the original file and replace the documentation section
    while IFS= read -r line; do
        if [[ "$line" == "## ğŸ“š Documentation Structure" ]]; then
            # Generate the new documentation section
            generate_documentation_index >> "$temp_file"
            in_doc_section=true
            # Skip until we find the next ## section or end of file
            continue
        elif [[ "$in_doc_section" == true && "$line" =~ ^##[[:space:]] ]]; then
            # Found the next section, stop skipping
            echo "$line" >> "$temp_file"
            in_doc_section=false
        elif [[ "$in_doc_section" == false ]]; then
            echo "$line" >> "$temp_file"
        fi
        # If in_doc_section is true, we skip the line (don't write it)
    done < "$OUTPUT_FILE"
    
    # Replace the original file
    mv "$temp_file" "$OUTPUT_FILE"
    success "Documentation index updated successfully in README.md"
}

# Function to analyze documentation without updating files
analyze_documentation() {
    log "Analyzing documentation structure..."
    
    local total_docs=$(count_total_documents)
    
    cat << EOF
ğŸ“š Documentation Analysis Report
===============================

ğŸ“Š Overview:
- Total Documents: $total_docs
- Documentation Directory: $DOC_DIR
- Analysis Method: Autonomous using aux-lad

ğŸ—ï¸ Structure Analysis:
EOF
    
    # Show the documentation structure that would be generated
    echo ""
    echo "Documentation categories found:"
    aux-lad "$DOC_DIR" | grep -E "^\| (Developer|Admin|IaC|CLI|Core|Hub|Index)" | awk -F'|' '{print "- " $2 ": " $3}' | sort | uniq -c
    
    echo ""
    echo "ğŸ“‹ Sample of documentation that would be indexed:"
    aux-lad -t "$DOC_DIR"
}

# Function to preview changes without updating
preview_changes() {
    log "Generating preview of documentation index changes..."
    
    cat << 'EOF'
ğŸ“‹ Preview of Documentation Index Changes
=========================================

The following content would replace the "Documentation Structure" section in README.md:

---
EOF

    generate_documentation_index

    cat << 'EOF'
---

ğŸ” Changes Summary:
- Automatically discovered documentation using aux-lad
- Generated categorized documentation listings
- Included real-time metadata (lines, words, modification dates)
- Organized by documentation type and purpose

To apply these changes, run: ./utl/doc-index --update
EOF
}

# Main execution function
main() {
    local action="${1:-update}"
    
    # Ensure documentation directory exists
    if [[ ! -d "$DOC_DIR" ]]; then
        error "Documentation directory not found: $DOC_DIR"
        exit 1
    fi
    
    # Ensure README.md exists
    if [[ ! -f "$OUTPUT_FILE" ]]; then
        error "README.md not found: $OUTPUT_FILE"
        exit 1
    fi
    
    case "$action" in
        --update|update)
            update_readme_file
            ;;
        --analyze|analyze)
            analyze_documentation
            ;;
        --dry-run|dry-run|preview)
            preview_changes
            ;;
        *)
            error "Invalid action: $action"
            echo "Usage: $0 [--update|--analyze|--dry-run]"
            exit 1
            ;;
    esac
}

# Execute if run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
