#!/bin/bash
#######################################################################
# Lab Environment Function Metadata Table Generator
#######################################################################
# File: func
# Description: Automatic function metadata table generator that populates 
#              the function metadata table in doc/dev/functions.md using 
#              aux_ffl and ana_laf to extract function information from lib/ directories
#
# Usage: ./func
#   (default)   Updates the function metadata table in doc/dev/functions.md
#######################################################################

# Use safer error handling
set -e

# Initialize lab environment
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Set LAB_DIR if not already set - PORTABLE for generators subfolder
if [[ -z "${LAB_DIR:-}" ]]; then
    # Script is now in utl/doc/generators, so LAB_DIR is three levels up
    readonly LAB_DIR="$(dirname "$(dirname "$(dirname "$SCRIPT_DIR")")")"
fi

# Source required utilities
source "$LAB_DIR/lib/gen/aux"
source "$LAB_DIR/lib/gen/ana"

# Load targets configuration
TARGETS_FILE="$(dirname "$SCRIPT_DIR")/config/targets"
if [[ -f "$TARGETS_FILE" ]]; then
    source "$TARGETS_FILE"
else
    echo "Warning: targets file not found at $TARGETS_FILE"
    # Fallback to hardcoded directories
    TARGET_DIRECTORIES=("lib/core" "lib/ops" "lib/gen")
fi

# Get output file from configuration
if [[ -n "${GENERATOR_OUTPUT_FILES[func]:-}" ]]; then
    DOC_FILE="$LAB_DIR/${GENERATOR_OUTPUT_FILES[func]}"
else
    # Fallback to default
    DOC_FILE="$LAB_DIR/doc/dev/functions.md"
fi

# Function to count functions from a library directory
count_library_functions() {
    local lib_name="$1"
    local lib_dir="$2"
    local function_count=0
    
    # Use centralized .tmp/doc directory
    local tmp_dir="$LAB_DIR/.tmp/doc"
    mkdir -p "$tmp_dir"
    
    # Process each file in the library directory
    for file in "$lib_dir"/*; do
        if [[ -f "$file" ]]; then
            # Generate JSON output using ana_laf with -j flag
            set +e  # Temporarily disable exit on error
            ana_laf -j "$file" >/dev/null 2>&1
            set -e  # Re-enable exit on error
            
            # Generate JSON filename based on file path structure
            local relative_path="${file#$LAB_DIR/}"
            local json_filename="${relative_path//\//_}.json"
            local json_file="$tmp_dir/$json_filename"
            
            if [[ -f "$json_file" ]]; then
                # Count functions in this file by counting function objects
                local file_function_count
                file_function_count=$(grep -c '"name":' "$json_file" 2>/dev/null || echo "0")
                # Clean the variable to ensure it's a valid number
                file_function_count=$(echo "$file_function_count" | grep -o '[0-9]*' | head -1)
                file_function_count=${file_function_count:-0}
                function_count=$((function_count + file_function_count))
            fi
        fi
    done
    
    echo "$function_count"
}

# Function to generate metadata table
generate_function_table() {
    # First, count all functions by processing them and counting output lines
    local total_functions=0
    
    # Count functions from all target directories
    for target_dir in "${TARGET_DIRECTORIES[@]}"; do
        local full_path="$LAB_DIR/$target_dir"
        if [[ -d "$full_path" && "$target_dir" == lib/* ]]; then
            local lib_name=$(basename "$target_dir")
            local count=$(count_library_functions "$lib_name" "$full_path")
            total_functions=$((total_functions + count))
        fi
    done
    
    # Generate header with actual function count
    cat << EOF
*Auto-updated function metadata table with real-time analysis*

> **Last Updated**: $(date '+%Y-%m-%d %H:%M:%S')  
> **Generated By**: \`utl/doc/generators/func\`  
> **Total Functions**: $total_functions functions across all libraries

This table provides a comprehensive overview of all functions available across the lab environment libraries:

### **ðŸ“‹ Function Library Overview**
Functions are organized by library modules for systematic access and reference.

### **ðŸ“– Function Metadata Table**

| Library | Module | Function | Description |
|---------|--------|----------|-------------|
EOF
    
    # Process and output functions from all target lib directories
    for target_dir in "${TARGET_DIRECTORIES[@]}"; do
        local full_path="$LAB_DIR/$target_dir"
        if [[ -d "$full_path" && "$target_dir" == lib/* ]]; then
            local lib_name=$(basename "$target_dir")
            process_library_functions "$lib_name" "$full_path"
        fi
    done
}

# Function to process functions from a library directory using JSON output
process_library_functions() {
    local lib_name="$1"
    local lib_dir="$2"
    
    # Use centralized .tmp/doc directory
    local tmp_dir="$LAB_DIR/.tmp/doc"
    mkdir -p "$tmp_dir"
    
    # Process each file in the library directory
    for file in "$lib_dir"/*; do
        if [[ -f "$file" ]]; then
            # Generate JSON output using ana_laf with -j flag
            set +e  # Temporarily disable exit on error
            ana_laf -j "$file" >/dev/null 2>&1
            set -e  # Re-enable exit on error
            
            # Generate JSON filename based on file path structure
            local relative_path="${file#$LAB_DIR/}"
            local json_filename="${relative_path//\//_}.json"
            local json_file="$tmp_dir/$json_filename"
            
            if [[ -f "$json_file" ]]; then
                local module_name=$(basename "$file")
                
                # Parse JSON and extract function information
                # Using a simple approach since we control the JSON format
                local in_functions=false
                local in_function=false
                local func_name=""
                local func_desc=""
                
                while IFS= read -r line; do
                    # Remove leading/trailing whitespace
                    line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    
                    if [[ "$line" == '"functions": [' ]]; then
                        in_functions=true
                        continue
                    fi
                    
                    if [[ "$in_functions" == true && "$line" == "{" ]]; then
                        in_function=true
                        func_name=""
                        func_desc=""
                        continue
                    fi
                    
                    if [[ "$in_function" == true ]]; then
                        if [[ "$line" =~ \"name\":[[:space:]]*\"([^\"]+)\" ]]; then
                            func_name="${BASH_REMATCH[1]}"
                        elif [[ "$line" =~ \"description\":[[:space:]]*\"([^\"]*)\" ]]; then
                            func_desc="${BASH_REMATCH[1]}"
                        elif [[ "$line" == "}" ]]; then
                            # End of function object - output the row
                            if [[ -n "$func_name" ]]; then
                                echo "| $lib_name | $module_name | $func_name | $func_desc |"
                            fi
                            in_function=false
                        fi
                    fi
                    
                    if [[ "$line" == "]" && "$in_functions" == true ]]; then
                        in_functions=false
                        break
                    fi
                done < "$json_file"
            fi
        fi
    done
    
}

# Function to update the documentation file
update_documentation() {
    local temp_file=$(mktemp)
    local in_auto_section=false

    echo "Updating function metadata table in $DOC_FILE..."

    while IFS= read -r line; do
        if [[ "$line" == *"<!-- AUTO-GENERATED SECTION: DO NOT EDIT MANUALLY -->"* ]]; then
            echo "$line" >> "$temp_file"
            echo "<!-- Command: aux_ffl ana_laf \"\" \"$LIB_CORE_DIR\" & aux_ffl ana_laf \"\" \"$LIB_OPS_DIR\" & aux_ffl ana_laf \"\" \"$LIB_GEN_DIR\" -->" >> "$temp_file"
            echo "" >> "$temp_file"
            # Write the new table only, skip all old lines until END marker
            generate_function_table | grep -vE '\|[[:space:]]*[a-zA-Z0-9_]+-[a-zA-Z0-9_]+[[:space:]]*\|' >> "$temp_file"
            echo "" >> "$temp_file"
            in_auto_section=true
            continue
        fi
        if [[ "$line" == *"<!-- END AUTO-GENERATED SECTION -->"* ]]; then
            echo "$line" >> "$temp_file"
            in_auto_section=false
            continue
        fi
        if [[ "$in_auto_section" == false ]]; then
            echo "$line" >> "$temp_file"
        fi
        # If in_auto_section is true, skip all lines until END marker
    done < "$DOC_FILE"

    mv "$temp_file" "$DOC_FILE"
    echo "Function metadata table updated successfully."
}

# Main execution
main() {
    echo "Generating function metadata table..."
    echo "Processing target directories from config: ${TARGET_DIRECTORIES[*]}"
    
    # Check if required lib directories exist
    local lib_dirs_found=false
    for target_dir in "${TARGET_DIRECTORIES[@]}"; do
        local full_path="$LAB_DIR/$target_dir"
        if [[ -d "$full_path" && "$target_dir" == lib/* ]]; then
            lib_dirs_found=true
            echo "Found lib directory: $target_dir"
        fi
    done
    
    if [[ "$lib_dirs_found" == "false" ]]; then
        echo "Error: No lib directories found in targets configuration"
        exit 1
    fi
    
    # Check if documentation file exists
    if [[ ! -f "$DOC_FILE" ]]; then
        echo "Error: Documentation file $DOC_FILE not found"
        exit 1
    fi
    
    # Update the documentation
    update_documentation
    
    echo "Function metadata table generation complete."
}

# Execute main function
main "$@"