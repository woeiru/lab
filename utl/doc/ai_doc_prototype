#!/bin/bash
#######################################################################
# AI Documentation Generator Prototype
#######################################################################
# File: utl/doc/ai_doc_prototype
# Description: Working prototype of AI-powered documentation generation
#              that integrates with existing lab tools (ana_laf, ana_acu, ana_lad)
#
# Usage: ./ai_doc_prototype <directory_path> [ai_service]
#   directory_path: Target directory to document
#   ai_service: ollama|openai|mock (default: mock for testing)
#
# Dependencies:
#   - Existing lab tools: ana_laf, ana_acu, ana_lad
#   - Optional: Ollama (for local AI) or OpenAI API key
#   - jq (for JSON parsing)
#######################################################################

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LAB_DIR="${LAB_DIR:-$(dirname "$(dirname "$SCRIPT_DIR")")}"
AI_SERVICE="${2:-mock}"  # Default to mock for testing
TMP_DIR="$LAB_DIR/.tmp/ai_analysis"

# Ensure we can source the aux library
if [[ -f "$LAB_DIR/lib/gen/aux" ]]; then
    source "$LAB_DIR/lib/gen/aux"
else
    echo "Error: Cannot find aux library at $LAB_DIR/lib/gen/aux"
    exit 1
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${BLUE}[AI-DOC]${NC} $*"; }
success() { echo -e "${GREEN}âœ…${NC} $*"; }
warning() { echo -e "${YELLOW}âš ï¸${NC} $*"; }
error() { echo -e "${RED}âŒ${NC} $*"; }

# AI Service Functions
call_ollama() {
    local prompt="$1"
    if command -v curl >/dev/null && command -v jq >/dev/null; then
        curl -s http://localhost:11434/api/generate \
            -d "{\"model\": \"deepseek-coder\", \"prompt\": \"$prompt\", \"stream\": false}" 2>/dev/null \
            | jq -r '.response' 2>/dev/null || echo "Error: Ollama service unavailable"
    else
        echo "Error: curl or jq not available for Ollama integration"
    fi
}

call_openai() {
    local prompt="$1"
    if [[ -z "$OPENAI_API_KEY" ]]; then
        echo "Error: OPENAI_API_KEY not set"
        return 1
    fi
    
    if command -v curl >/dev/null && command -v jq >/dev/null; then
        curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"model\": \"gpt-4\", \"messages\": [{\"role\": \"user\", \"content\": \"$prompt\"}]}" 2>/dev/null \
            | jq -r '.choices[0].message.content' 2>/dev/null || echo "Error: OpenAI API call failed"
    else
        echo "Error: curl or jq not available for OpenAI integration"
    fi
}

call_mock_ai() {
    local prompt="$1"
    local target_dir="$2"
    local dir_name=$(basename "$target_dir")
    
    # Generate realistic mock documentation based on directory analysis
    cat << EOF
# ðŸ”§ ${dir_name^} - What You Need to Know

## ðŸŽ¯ What This Does for You
The \`$dir_name\` module helps you manage your Lab Environment efficiently. Whether you're a developer, system administrator, or DevOps engineer, this tool streamlines your workflow and reduces manual configuration tasks.

**Key Benefits:**
- âš¡ Saves time on routine infrastructure tasks
- ðŸ›¡ï¸ Reduces configuration errors through automation
- ðŸ”„ Integrates seamlessly with your existing workflow

## ðŸš€ Get Started in 2 Minutes
\`\`\`bash
# Step 1: Initialize your lab environment
source bin/ini

# Step 2: Navigate to the module
cd $target_dir

# Step 3: You're ready to go!
\`\`\`

## ðŸ“ What's Inside - Key Files You'll Use
$(ls -la "$target_dir" 2>/dev/null | grep -v '^total' | grep -v '^d' | head -5 | while read -r line; do
    filename=$(echo "$line" | awk '{print $NF}')
    echo "- **\`$filename\`** - Main functionality (you'll use this often)"
done)

## ðŸ¤ How This Connects to Your Workflow
This module works with your existing tools:
- **ðŸš¨ Error Handling**: Automatically catches and logs issues for you
- **âš™ï¸ Configuration**: Follows your project's config patterns
- **ðŸ“– Documentation**: Self-documents as you work

## ðŸ’¡ Pro Tips & Best Practices
- Always run \`source bin/ini\` first to set up your environment
- Check the logs if something doesn't work as expected
- Use relative paths for better portability

## ðŸ†˜ Need Help? Find More Info
- [ðŸ“š Main Documentation](../../README.md) - Complete system guide
- [ðŸŽ“ Standards & Conventions](../standards.md) - Follow the project patterns
- [ðŸ› Troubleshooting](../troubleshooting.md) - Common issues and solutions

---

**Navigation**: Return to [Parent Directory](../README.md) | [Main Lab Documentation](../../README.md)

*Generated by AI Documentation System using lab metadata analysis*
EOF
}

# Main AI calling function
call_ai() {
    local prompt="$1"
    local target_dir="$2"
    
    case "$AI_SERVICE" in
        "ollama")
            call_ollama "$prompt"
            ;;
        "openai")
            call_openai "$prompt"
            ;;
        "mock")
            call_mock_ai "$prompt" "$target_dir"
            ;;
        *)
            error "Unsupported AI service: $AI_SERVICE"
            echo "Supported services: ollama, openai, mock"
            exit 1
            ;;
    esac
}

# Collect metadata using existing lab tools
collect_metadata() {
    local target_dir="$1"
    
    log "Collecting metadata for: $target_dir"
    
    # Create temporary analysis directory
    mkdir -p "$TMP_DIR"
    
    # Initialize metadata collection
    local metadata_summary="# Metadata Analysis for: $target_dir\n\n"
    
    # Basic directory information
    if [[ -d "$target_dir" ]]; then
        metadata_summary+="## Directory Structure\n"
        metadata_summary+="$(ls -la "$target_dir" 2>/dev/null || echo 'Directory not accessible')\n\n"
        
        # Count different file types
        local file_count=$(find "$target_dir" -maxdepth 1 -type f 2>/dev/null | wc -l)
        local dir_count=$(find "$target_dir" -maxdepth 1 -type d 2>/dev/null | tail -n +2 | wc -l)
        
        metadata_summary+="## Statistics\n"
        metadata_summary+="- Files: $file_count\n"
        metadata_summary+="- Subdirectories: $dir_count\n\n"
    fi
    
    # Try to get function metadata if this looks like a code directory
    if find "$target_dir" -maxdepth 1 -type f -executable 2>/dev/null | head -1 | grep -q .; then
        log "Analyzing functions..."
        for file in "$target_dir"/*; do
            if [[ -f "$file" && -x "$file" ]]; then
                if ana_laf "$file" -j >/dev/null 2>&1; then
                    metadata_summary+="## Functions in $(basename "$file")\n"
                    metadata_summary+="$(ana_laf "$file" 2>/dev/null | head -10 || echo 'No functions found')\n\n"
                fi
            fi
        done
    fi
    
    # Try to get documentation structure if this is a doc directory
    if [[ "$target_dir" =~ doc ]]; then
        log "Analyzing documentation structure..."
        if ana_lad "$target_dir" >/dev/null 2>&1; then
            metadata_summary+="## Documentation Analysis\n"
            metadata_summary+="$(ana_lad "$target_dir" 2>/dev/null | head -10 || echo 'No documentation metadata available')\n\n"
        fi
    fi
    
    # Save metadata summary
    echo -e "$metadata_summary" > "$TMP_DIR/metadata_summary.txt"
    
    log "Metadata collection complete"
}

# Build comprehensive AI prompt
build_ai_prompt() {
    local target_dir="$1"
    local dir_name=$(basename "$target_dir")
    
    # Get example documentation style
    local style_examples=""
    if [[ -f "$LAB_DIR/doc/README.md" ]]; then
        style_examples=$(head -50 "$LAB_DIR/doc/README.md" 2>/dev/null | grep -E '^#|^-|^`|emoji' | head -20)
    fi
    
    cat << EOF
You are documenting a directory in a sophisticated infrastructure management system called "Lab Environment Management System".

TARGET DIRECTORY: $target_dir
DIRECTORY NAME: $dir_name

METADATA ANALYSIS:
$(cat "$TMP_DIR/metadata_summary.txt" 2>/dev/null || echo "No metadata available")

STYLE GUIDELINES (from existing documentation):
$style_examples

DOCUMENTATION REQUIREMENTS:
1. Generate a comprehensive README.md for the directory: $target_dir
2. Use user-focused emoji headers that explain value and purpose:
   - ðŸŽ¯ "What This Does for You" (instead of just "Overview")
   - ðŸš€ "Get Started in X Minutes" (actionable quick start)
   - ðŸ“ "What's Inside - Key Files You'll Use" (practical file guide)
   - ðŸ¤ "How This Connects to Your Workflow" (integration value)
   - ðŸ’¡ "Pro Tips & Best Practices" (user experience insights)
   - ðŸ†˜ "Need Help? Find More Info" (support resources)
3. Lead with user benefits and practical value, not just technical details  
4. Include realistic time estimates ("Get Started in 2 Minutes")
5. Use actionable language ("You'll use this", "This helps you", "Saves time")
6. Add navigation links with descriptive text, not just technical names
7. Include pro tips and best practices from a user perspective
8. Make troubleshooting and help resources prominent
9. Focus on workflow integration and practical use cases

FOCUS ON:
- Practical value for developers and system administrators
- Clear explanations of purpose and functionality
- Working code examples where applicable
- Proper navigation within the project structure

Generate only the README.md content, no additional explanation.
EOF
}

# Validate generated documentation
validate_documentation() {
    local readme_file="$1"
    
    if [[ ! -f "$readme_file" ]]; then
        error "README file not found: $readme_file"
        return 1
    fi
    
    local checks=0
    local total_checks=8
    
    # Check for required elements
    if grep -q '^#' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains headers"
    fi
    
    if grep -q 'ðŸŽ¯\|ðŸš€\|ðŸ“\|ðŸ¤\|ðŸ’¡\|ðŸ†˜' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains user-focused emoji headers"
    fi
    
    if grep -q '```' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains code examples"
    fi
    
    if grep -q '\[.*\](.*)' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains links"
    fi
    
    if grep -q -i 'what this does\|helps you\|benefits\|saves time' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains user-focused language"
    fi
    
    if grep -q 'Navigation\|README.md\|Need Help' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains navigation/help elements"
    fi
    
    if grep -q -i 'minutes\|quick\|get started' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains actionable quick start"
    fi
    
    if grep -q -i 'pro tip\|best practice\|workflow' "$readme_file"; then
        ((checks++))
        log "âœ“ Contains user experience insights"
    fi
    
    local score=$((checks * 100 / total_checks))
    
    if [[ $score -ge 70 ]]; then
        success "Quality check passed: $score% ($checks/$total_checks checks)"
        return 0
    else
        warning "Quality check needs improvement: $score% ($checks/$total_checks checks)"
        return 1
    fi
}

# Main documentation generation function
generate_documentation() {
    local target_dir="$1"
    
    if [[ ! -d "$target_dir" ]]; then
        error "Directory not found: $target_dir"
        exit 1
    fi
    
    log "Starting AI documentation generation for: $target_dir"
    log "Using AI service: $AI_SERVICE"
    
    # Step 1: Collect metadata
    collect_metadata "$target_dir"
    
    # Step 2: Build AI prompt
    log "Building AI prompt..."
    local ai_prompt=$(build_ai_prompt "$target_dir")
    
    # Step 3: Generate documentation
    log "Generating documentation with AI..."
    local generated_docs=$(call_ai "$ai_prompt" "$target_dir")
    
    if [[ -z "$generated_docs" || "$generated_docs" == "Error:"* ]]; then
        error "AI generation failed: $generated_docs"
        exit 1
    fi
    
    # Step 4: Save documentation
    local readme_file="$target_dir/README.md"
    local backup_file="$target_dir/README.md.backup"
    
    # Backup existing README if it exists
    if [[ -f "$readme_file" ]]; then
        cp "$readme_file" "$backup_file"
        log "Backed up existing README to: $backup_file"
    fi
    
    # Save generated documentation
    echo "$generated_docs" > "$readme_file"
    log "Saved generated documentation to: $readme_file"
    
    # Step 5: Validate
    if validate_documentation "$readme_file"; then
        success "Documentation generation completed successfully!"
        log "Generated $(wc -l < "$readme_file") lines of documentation"
    else
        warning "Generated documentation may need manual review"
        if [[ -f "$backup_file" ]]; then
            log "Original backup available at: $backup_file"
        fi
    fi
    
    # Clean up temporary files
    rm -rf "$TMP_DIR"
}

# Help function
show_help() {
    cat << EOF
AI Documentation Generator Prototype

USAGE:
    $0 <directory_path> [ai_service]

PARAMETERS:
    directory_path    Target directory to generate documentation for
    ai_service       AI service to use: ollama|openai|mock (default: mock)

EXAMPLES:
    $0 lib/ops/gpu                    # Generate docs using mock AI
    $0 lib/ops/gpu ollama            # Generate docs using local Ollama
    $0 doc/dev openai                # Generate docs using OpenAI API

AI SERVICES:
    mock     - Mock AI for testing (no external dependencies)
    ollama   - Local AI using Ollama (requires Ollama installation)
    openai   - OpenAI API (requires OPENAI_API_KEY environment variable)

SETUP:
    # For Ollama (local AI):
    curl -fsSL https://ollama.ai/install.sh | sh
    ollama pull deepseek-coder
    
    # For OpenAI:
    export OPENAI_API_KEY="your-api-key-here"

The generated documentation integrates with your existing lab tools:
- Uses ana_laf for function analysis
- Uses ana_lad for documentation structure
- Follows established project patterns and style
EOF
}

# Main execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        "-h"|"--help"|"help")
            show_help
            exit 0
            ;;
        "")
            error "Directory path required"
            show_help
            exit 1
            ;;
        *)
            generate_documentation "$1"
            ;;
    esac
fi
