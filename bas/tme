#!/bin/bash

# Performance monitoring setup
declare -gA TME_START_TIMES     # Stores component start times
declare -gA TME_END_TIMES       # Stores component end times
declare -gA TME_DURATIONS       # Stores calculated durations
declare -gA TME_STATUS          # Stores completion status
declare -gA TME_PARENTS         # Stores parent-child relationships
declare -gA TME_CHILDREN        # Stores child components for each parent
declare -g TME_STARTUP_BEGIN    # Global startup timestamp
declare -g TME_LOG_FILE         # Path to timing log file
declare -g TME_CURRENT_PARENT   # Tracks current parent for nested timing

# Initialize timer system with optional log file
init_timer() {
    local log_dir="${1:-/tmp}"
    TME_LOG_FILE="${log_dir}/rc_timing.log"
    TME_STARTUP_BEGIN=$(date +%s.%N)
    TME_CURRENT_PARENT=""

    # Reset all associative arrays
    TME_START_TIMES=()
    TME_END_TIMES=()
    TME_DURATIONS=()
    TME_STATUS=()
    TME_PARENTS=()
    TME_CHILDREN=()

    [[ ! -d "$log_dir" ]] && mkdir -p "$log_dir"

    {
        echo "RC Timing Log - $(date)"
        echo "===================="
        echo "Startup time: $(date -d @${TME_STARTUP_BEGIN})"
        echo
    } > "$TME_LOG_FILE"
}

# Start timing a component with optional parent component
start_timer() {
    local component="$1"
    local parent="${2:-$TME_CURRENT_PARENT}"  # Use current parent if none specified
    local timestamp=$(date +%s.%N)

    TME_START_TIMES[$component]=$timestamp
    TME_STATUS[$component]="running"

    # Set up parent-child relationship
    if [[ -n "$parent" ]]; then
        TME_PARENTS[$component]=$parent
        # Append to children list, creating if it doesn't exist
        if [[ -z "${TME_CHILDREN[$parent]}" ]]; then
            TME_CHILDREN[$parent]="$component"
        else
            TME_CHILDREN[$parent]="${TME_CHILDREN[$parent]}:$component"
        fi
    fi

    # Set this component as the current parent for nested timing
    TME_CURRENT_PARENT="$component"

    {
        echo "[START] $component"
        [[ -n "$parent" ]] && echo "Parent: $parent"
        echo "Time: $(date -d @${timestamp})"
        echo
    } >> "$TME_LOG_FILE"
}

# End timing for a component
end_timer() {
    local component="$1"
    local status="${2:-success}"
    local timestamp=$(date +%s.%N)

    TME_END_TIMES[$component]=$timestamp

    local start_time="${TME_START_TIMES[$component]}"
    if [[ -n "$start_time" ]]; then
        TME_DURATIONS[$component]=$(echo "$timestamp - $start_time" | bc)
        TME_STATUS[$component]=$status
    else
        TME_DURATIONS[$component]=0
        TME_STATUS[$component]="error_no_start"
    fi

    # Reset current parent to the parent of this component
    TME_CURRENT_PARENT="${TME_PARENTS[$component]}"

    {
        echo "[END] $component"
        echo "Status: $status"
        echo "Duration: ${TME_DURATIONS[$component]}s"
        echo
    } >> "$TME_LOG_FILE"
}

# Example of how to use nested timing
start_nested_timing() {
    local component="$1"
    start_timer "$component"  # Uses TME_CURRENT_PARENT automatically
}

end_nested_timing() {
    local component="$1"
    end_timer "$component"    # Automatically restores previous parent
}

# Cleanup function
cleanup_timer() {
    for component in "${!TME_STATUS[@]}"; do
        if [[ "${TME_STATUS[$component]}" == "running" ]]; then
            end_timer "$component" "interrupted"
        fi
    done

    {
        echo "===================="
        echo "Timer cleanup completed at $(date)"
        echo "Total execution time: $(echo "$(date +%s.%N) - $TME_STARTUP_BEGIN" | bc)s"
        echo
    } >> "$TME_LOG_FILE"
}

# Define timer state directory and files
TME_DIR="/var/log/rc"
[[ ! -d "$TME_DIR" ]] && mkdir -p "$TME_DIR" 2>/dev/null || TME_DIR="/tmp"

TME_STATE_FILE="${TME_DIR}/rc_tme_state"
TME_LEVELS_FILE="${TME_DIR}/rc_tme_levels"

# Initialize timer state if file doesn't exist
if [[ ! -f "$TME_STATE_FILE" ]]; then
    echo "true" > "$TME_STATE_FILE" 2>/dev/null || {
        TME_DIR="/tmp"
        TME_STATE_FILE="${TME_DIR}/rc_tme_state"
        TME_LEVELS_FILE="${TME_DIR}/rc_tme_levels"
        echo "true" > "$TME_STATE_FILE"
    }
fi

# Initialize timer levels
if [[ ! -f "$TME_LEVELS_FILE" ]]; then
    echo "9" > "$TME_LEVELS_FILE"  # Default max depth
fi

# Color codes for timing output
TME_RED='\033[0;31m'
TME_ORANGE='\033[0;33m'
TME_YELLOW='\033[1;33m'
TME_GREEN='\033[0;32m'
TME_CYAN='\033[0;36m'
TME_BLUE='\033[0;34m'
TME_INDIGO='\033[0;35m'
TME_VIOLET='\033[1;35m'
TME_WHITE='\033[1;37m'
TME_NC='\033[0m'

# Calculate the depth of a component in the timing tree
calculate_component_depth() {
    local component="$1"
    local depth=0
    local current="$component"

    while [[ -n "${TME_PARENTS[$current]}" ]]; do
        ((depth++))
        current="${TME_PARENTS[$current]}"
    done

    echo "$depth"
}

# Print formatted timing entry
print_timing_entry() {
    local component="$1"
    local indent="$2"
    local duration="$3"
    local total_time="$4"
    local depth="$5"
    local status="${TME_STATUS[$component]}"

    # Calculate percentage of total time
    local percentage=$(echo "scale=2; ($duration / $total_time) * 100" | bc)

    # Set color based on depth
    local color
    case $depth in
        0) color=$TME_RED ;;
        1) color=$TME_ORANGE ;;
        2) color=$TME_YELLOW ;;
        3) color=$TME_GREEN ;;
        4) color=$TME_CYAN ;;
        5) color=$TME_BLUE ;;
        6) color=$TME_INDIGO ;;
        7) color=$TME_VIOLET ;;
        *) color=$TME_WHITE ;;
    esac

    # Create depth-based indentation
    local depth_indent=""
    if [ $depth -eq 0 ]; then
        depth_indent="    "
    else
        depth_indent="      "
        for ((i=2; i<=$depth; i++)); do
            depth_indent="  $depth_indent"
        done
    fi

    # Generate status indicator
    local status_icon
    case "$status" in
        "success") status_icon="✓";;
        "error"*) status_icon="✗";;
        "running") status_icon="⟳";;
        *) status_icon="?";;
    esac

    # Format duration and percentage
    local time_str=$(printf "%6.3fs" "$duration")
    local perc_str=$(printf "[%5.1f%%]" "$percentage")

    # Print the formatted line
    printf "%s%s%s %-25s %s %s [%s]%s\n" \
        "$depth_indent" \
        "$color" \
        "${depth:+└─}" \
        "$component" \
        "$time_str" \
        "$perc_str" \
        "$status_icon" \
        "$TME_NC"
}

# Enhanced component tree printer
print_enhanced_tree() {
    local component="$1"
    local indent="$2"
    local total_time="$3"
    local depth=$(calculate_component_depth "$component")

    # Read current max depth
    local max_depth
    max_depth=$(cat "$TME_LEVELS_FILE" 2>/dev/null || echo "9")

    # Only proceed if depth is within limits
    if ((depth <= max_depth)); then
        # Print this component
        print_timing_entry "$component" "$indent" "${TME_DURATIONS[$component]}" "$total_time" "$depth"

        # Process children if any exist
        if [[ -n "${TME_CHILDREN[$component]}" ]]; then
            local new_indent="${indent}   "
            local IFS=':'
            local children=(${TME_CHILDREN[$component]})
            # Sort children by duration
            IFS=$'\n'
            children=($(for child in "${children[@]}"; do
                echo "${TME_DURATIONS[$child]}:$child"
            done | sort -rn | cut -d: -f2))
            unset IFS

            for child in "${children[@]}"; do
                print_enhanced_tree "$child" "$new_indent" "$total_time"
            done
        fi
    fi
}

# Enhanced timing report
print_timing_report() {
    # Check if timing is enabled
    local current_state
    current_state=$(cat "$TME_STATE_FILE" 2>/dev/null || echo "true")
    [[ "${current_state}" != "true" ]] && return 0

    local total_time=$(echo "$(date +%s.%N) - $TME_STARTUP_BEGIN" | bc)

    {
        echo
        printf " %s━ RC Performance Report%s\n" "$TME_BLUE" "$TME_NC"
        printf " %s━ Total startup time: %s%.3fs%s\n" "$TME_BLUE" "$TME_GREEN" "$total_time" "$TME_NC"
        printf " %s━ Generated: %s%s%s\n" "$TME_BLUE" "$TME_CYAN" "$(date)" "$TME_NC"
        echo
        printf " %s━ Component Timing Tree:%s\n" "$TME_BLUE" "$TME_NC"
        echo

        # Find and sort root components by duration
        local root_components=()
        for comp in "${!TME_START_TIMES[@]}"; do
            if [[ -z "${TME_PARENTS[$comp]}" ]]; then
                root_components+=("$comp")
            fi
        done

        # Sort root components by duration
        IFS=$'\n'
        root_components=($(for comp in "${root_components[@]}"; do
            echo "${TME_DURATIONS[$comp]}:$comp"
        done | sort -rn | cut -d: -f2))
        unset IFS

        # Print tree for each root component
        for comp in "${root_components[@]}"; do
            print_enhanced_tree "$comp" "" "$total_time"
            echo
        done

        printf " %s━ Log file: %s%s%s\n" "$TME_BLUE" "$TME_CYAN" "$TME_LOG_FILE" "$TME_NC"
        echo

    } | tee -a "$TME_LOG_FILE"
}

# The settme function to control timer output
settme() {
    local arg=$1

    case "$arg" in
        "off")
            echo "false" > "$TME_STATE_FILE"
            echo "Timer output has been disabled"
            return 0
            ;;
        "on")
            echo "true" > "$TME_STATE_FILE"
            echo "9" > "$TME_LEVELS_FILE"
            echo "Timer output has been enabled with maximum depth"
            return 0
            ;;
        *)
            if [[ "$(cat "$TME_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                echo "Timer output is currently disabled. Use 'settme on' to enable first."
                return 1
            fi

            # Handle depth range setting
            if [[ $arg =~ ^([0-9]+)$ ]]; then
                local depth=${BASH_REMATCH[1]}
                if ((depth > 0 && depth <= 9)); then
                    echo "$depth" > "$TME_LEVELS_FILE"
                    echo "Timer depth set to $depth"
                    return 0
                fi
            fi

            echo "Invalid input. Usage:"
            echo "   settme on|off            - Enable or disable timer output"
            echo "   settme <depth>           - Set maximum depth to show (1-9)"
            return 1
            ;;
    esac
}

# Export functions and variables
export TME_STARTUP_BEGIN
export -A TME_START_TIMES
export -A TME_END_TIMES
export -A TME_DURATIONS
export -A TME_STATUS
export -A TME_PARENTS
export -A TME_CHILDREN
export TME_CURRENT_PARENT
export TME_LOG_FILE
export -f init_timer
export -f start_timer
export -f end_timer
export -f start_nested_timing
export -f end_nested_timing
export -f calculate_component_depth
export -f print_timing_entry
export -f print_enhanced_tree
export -f print_timing_report
export -f settme
export -f cleanup_timer

# Set up cleanup trap
trap cleanup_timer EXIT
