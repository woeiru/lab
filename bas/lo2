#!/bin/bash

# Verify base module is loaded
if ! declare -F log >/dev/null; then
    echo "Error: Base logging module (lo1) must be loaded first" >&2
    return 1
fi

# Verify required environment variables
[[ -z "$LOG_DIR" ]] && {
    echo "Fatal: LOG_DIR environment variable not set" >&2
    return 1
}
[[ -z "$TMP_DIR" ]] && {
    echo "Fatal: TMP_DIR environment variable not set" >&2
    return 1
}

# Define module-specific directories and files
readonly LOG_LO_DIR="$LOG_DIR/lo"
readonly TMP_LO_DIR="$TMP_DIR/lo"
readonly LOG_CONTROL_STATE_FILE="${TMP_LO_DIR}/lo2_state"
readonly LOG_DEBUG_FILE="${LOG_LO_DIR}/debug.log"

# Global state
declare -g LOG_CONTROL_DEPTH_ENABLED=false

# Pre-analyzed file cache structure
declare -gA LO2_FILE_ANALYSIS=()  # Stores complete file analysis
declare -gA LO2_LINE_DEPTH=()     # Stores pre-calculated depths for each line
declare -g LO2_INITIALIZED=false   # Track if initialization is complete

# Enhanced debug logging
lo2_debug_log() {
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local source="${2:-unknown}"
    printf "[LO2-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "$LOG_DEBUG_FILE"
}

# Pre-analyze a file completely
analyze_source_file() {
    local file="$1"
    local key="$file"

    # Skip if already analyzed
    [[ -n "${LO2_FILE_ANALYSIS[$key]}" ]] && return 0

    [[ ! -f "$file" ]] && {
        lo2_debug_log "File not found: $file" "analyze_source"
        return 1
    }

    lo2_debug_log "Pre-analyzing file: $file" "analyze_source"

    local -a file_lines
    mapfile -t file_lines < "$file"

    local line_number=0
    local -a control_stack=()
    local depth=0
    local analysis=""

    while ((line_number < ${#file_lines[@]})); do
        local line="${file_lines[$line_number]}"
        local trimmed="${line#"${line%%[![:space:]]*}"}"

        case "$trimmed" in
            if*|for*|while*|until*|case*|select*)
                ((depth++))
                control_stack+=("$depth")
                LO2_LINE_DEPTH["$key:$line_number"]=$depth
                ;;
            elif*|else*)
                # Maintain same depth as parent if
                [[ ${#control_stack[@]} -gt 0 ]] && {
                    depth=${control_stack[-1]}
                    LO2_LINE_DEPTH["$key:$line_number"]=$depth
                }
                ;;
            fi|done|esac)
                [[ ${#control_stack[@]} -gt 0 ]] && {
                    unset 'control_stack[-1]'
                    ((depth--))
                }
                LO2_LINE_DEPTH["$key:$line_number"]=$depth
                ;;
            *)
                LO2_LINE_DEPTH["$key:$line_number"]=$depth
                ;;
        esac

        analysis+="$line_number:$depth;"
        ((line_number++))
    done

    LO2_FILE_ANALYSIS[$key]="$analysis"
    lo2_debug_log "Analysis complete for $file. Processed $line_number lines" "analyze_source"
    return 0
}

# Get the depth for a specific line in a file
get_line_depth() {
    local file="$1"
    local line="$2"

    echo "${LO2_LINE_DEPTH["$file:$line"]:-0}"
}

# Get the actual source file from the call stack
get_actual_source_file() {
    local stack_size=${#FUNCNAME[@]}
    local current_file=""

    # Start from 2 to skip get_actual_source_file and immediate caller
    for ((i=2; i<stack_size; i++)); do
        local source="${BASH_SOURCE[$i]}"
        if [[ "$source" =~ ^/root/lab/(con/rc|con/rc[0-9]+|fun/.*|gem/.*)$ ]]; then
            current_file="$source"
            break
        fi
    done

    echo "$current_file"
}

# Pre-initialize analysis for known script files
initialize_lo2() {
    [[ "$LO2_INITIALIZED" == "true" ]] && return 0

    lo2_debug_log "Starting LO2 initialization" "init"

    # Define paths to pre-analyze
    local base_path="/root/lab"
    local paths=(
        "$base_path/con/rc"
        "$base_path/con/rc1"
        "$base_path/con/rc2"
        "$base_path/con/rc3"
        "$base_path/fun"
        "$base_path/gem"
    )

    # Pre-analyze all relevant files
    for path in "${paths[@]}"; do
        if [[ -d "$path" ]]; then
            while IFS= read -r -d '' file; do
                analyze_source_file "$file"
            done < <(find "$path" -type f -name "*.sh" -print0 2>/dev/null)
        elif [[ -f "$path" ]]; then
            analyze_source_file "$path"
        fi
    done

    LO2_INITIALIZED=true
    lo2_debug_log "LO2 initialization complete" "init"
}

# Calculate total control structure depth
calculate_control_depth() {
    local caller_file="$1"
    local line="${BASH_LINENO[1]}"
    local current_func="${FUNCNAME[2]:-main}"

    [[ -z "$caller_file" ]] && {
        lo2_debug_log "No valid source file found" "depth_calc"
        return 0
    }

    # Ensure file is analyzed
    analyze_source_file "$caller_file"

    # Get pre-calculated depth
    local depth=$(get_line_depth "$caller_file" "$line")
    lo2_debug_log "Retrieved cached depth $depth for $caller_file:$line" "depth_calc"

    echo "${depth:-0}"
}

# Override calculate_final_depth for control structure awareness
calculate_final_depth() {
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local base_depth
        base_depth=$(get_base_depth)
        lo2_debug_log "Base depth: $base_depth" "final_depth"

        local source_file
        source_file=$(get_actual_source_file)
        local control_depth
        control_depth=$(calculate_control_depth "$source_file")
        local total_depth=$((base_depth + control_depth))

        lo2_debug_log "Control depth: $control_depth, Total depth: $total_depth" "final_depth"
        echo "$total_depth"
    else
        get_base_depth
    fi
}

# Control structure tracking toggle
setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            echo "true" > "$LOG_CONTROL_STATE_FILE"
            initialize_lo2
            lo2_debug_log "Control structure depth tracking enabled" "setlogcontrol"
            printf "%sControl structure depth tracking enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            echo "false" > "$LOG_CONTROL_STATE_FILE"
            lo2_debug_log "Control structure depth tracking disabled" "setlogcontrol"
            printf "%sControl structure depth tracking disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlogcontrol on|off\n"
            return 1
            ;;
    esac
}

# Cleanup function
cleanup_lo2() {
    lo2_debug_log "Starting cleanup" "cleanup_lo2"
    LO2_FILE_ANALYSIS=()
    LO2_LINE_DEPTH=()
    LO2_INITIALIZED=false
    lo2_debug_log "Cleanup complete" "cleanup_lo2"
}

# Export necessary functions and variables
export LOG_CONTROL_DEPTH_ENABLED
export -f setlogcontrol
export -f lo2_debug_log
export -f calculate_final_depth

# Set up cleanup trap
trap cleanup_lo2 EXIT

# Initialize control tracking based on saved state
[[ -f "$LOG_CONTROL_STATE_FILE" ]] && {
    saved_state=$(cat "$LOG_CONTROL_STATE_FILE")
    [[ "$saved_state" == "true" ]] && setlogcontrol on
}

lo2_debug_log "lo2 module loaded successfully" "init"
