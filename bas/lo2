#!/bin/bash

# Verify base module is loaded
if ! declare -F log >/dev/null; then
    echo "Error: Base logging module (lo1) must be loaded first" >&2
    return 1
fi

# Verify required environment variables
[[ -z "$LOG_DIR" ]] && {
    echo "Fatal: LOG_DIR environment variable not set" >&2
    return 1
}
[[ -z "$TMP_DIR" ]] && {
    echo "Fatal: TMP_DIR environment variable not set" >&2
    return 1
}

# Define module-specific directories and files
readonly LOG_LO_DIR="$LOG_DIR/lo"
readonly TMP_LO_DIR="$TMP_DIR/lo"
readonly LOG_CONTROL_STATE_FILE="${TMP_LO_DIR}/lo2_state"
readonly LOG_DEBUG_FILE="${LOG_LO_DIR}/debug.log"

# Control structure tracking state
declare -g LOG_CONTROL_DEPTH_ENABLED=false
declare -gA LO2_CONTROL_RANGES=()
declare -gA LO2_CONTROL_TYPES=()
declare -g LO2_LAST_ANALYZED_FILE=""
declare -ga LO2_SOURCE_LINES=()
declare -ga LO2_CONTROL_STACK=()

# Initialize state file if it doesn't exist
[[ ! -f "$LOG_CONTROL_STATE_FILE" ]] && echo "false" > "$LOG_CONTROL_STATE_FILE"

# Enhanced debug logging
lo2_debug_log() {
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local source="${2:-unknown}"
    printf "[LO2-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "$LOG_DEBUG_FILE"
}

# Improved control structure detection
detect_control_structure() {
    local line="$1"
    local trimmed="${line#"${line%%[![:space:]]*}"}"

    case "$trimmed" in
        if*|for*|while*|until*|case*|select*)
            echo "${trimmed%% *}"
            return 0
            ;;
        elif*|else*)
            echo "branch"
            return 0
            ;;
        fi|done|esac)
            echo "end"
            return 0
            ;;
        *)
            echo ""
            return 1
            ;;
    esac
}

# Add cache for analyzed files
declare -gA LO2_FILE_CACHE=()  # Stores analyzed file data
declare -gA LO2_CONTROL_CACHE=()  # Stores control structure data by file

# Modified analyze_source_file with caching
analyze_source_file() {
    local file="$1"
    local file_hash

    # Check if file exists and is readable
    [[ ! -f "$file" ]] && {
        lo2_debug_log "File not found: $file" "analyze_source"
        return 1
    }

    # Generate hash of file content for cache validation
    file_hash=$(md5sum "$file" | cut -d' ' -f1)

    # Check if we have a valid cache entry
    if [[ -n "${LO2_FILE_CACHE[$file]}" ]]; then
        local cached_hash="${LO2_FILE_CACHE[$file]}"
        if [[ "$cached_hash" == "$file_hash" ]]; then
            lo2_debug_log "Using cached analysis for $file" "analyze_source"
            # Restore cached control structures
            eval "$(_deserialize_cache "$file")"
            return 0
        fi
    fi

    lo2_debug_log "Starting fresh analysis of file: $file" "analyze_source"

    # Reset state for new analysis
    LO2_CONTROL_RANGES=()
    LO2_CONTROL_TYPES=()
    LO2_SOURCE_LINES=()
    LO2_CONTROL_STACK=()

    # Load and analyze file
    mapfile -t LO2_SOURCE_LINES < "$file"
    local line_number=0
    local structure_id=0

    while ((line_number < ${#LO2_SOURCE_LINES[@]})); do
        local line="${LO2_SOURCE_LINES[$line_number]}"
        local structure_type=$(detect_control_structure "$line")

        case "$structure_type" in
            if|for|while|until|case|select)
                ((structure_id++))
                LO2_CONTROL_STACK+=("$structure_type:$structure_id:$line_number")
                lo2_debug_log "Found $structure_type block at line $line_number (ID: $structure_id)" "analyze_source"
                ;;
            end)
                if ((${#LO2_CONTROL_STACK[@]} > 0)); then
                    local last_idx=$((${#LO2_CONTROL_STACK[@]} - 1))
                    local struct="${LO2_CONTROL_STACK[$last_idx]}"
                    IFS=':' read -r type id start <<< "$struct"

                    LO2_CONTROL_RANGES["$type:$id"]="$start:$line_number"
                    LO2_CONTROL_TYPES["$type:$id"]="$type"

                    lo2_debug_log "Completed $type block (ID: $id) from line $start to $line_number" "analyze_source"
                    unset 'LO2_CONTROL_STACK[$last_idx]'
                fi
                ;;
        esac
        ((line_number++))
    done

    # Cache the results
    LO2_FILE_CACHE[$file]="$file_hash"
    _cache_control_structures "$file"

    lo2_debug_log "Analysis complete and cached. Found ${#LO2_CONTROL_RANGES[@]} control structures" "analyze_source"
    return 0
}

# Helper function to serialize control structure data
_cache_control_structures() {
    local file="$1"
    local cache_data=""

    # Serialize control ranges
    for key in "${!LO2_CONTROL_RANGES[@]}"; do
        cache_data+="LO2_CONTROL_RANGES[$key]='${LO2_CONTROL_RANGES[$key]}';"
    done

    # Serialize control types
    for key in "${!LO2_CONTROL_TYPES[@]}"; do
        cache_data+="LO2_CONTROL_TYPES[$key]='${LO2_CONTROL_TYPES[$key]}';"
    done

    LO2_CONTROL_CACHE[$file]="$cache_data"
}

# Helper function to deserialize cached control structure data
_deserialize_cache() {
    local file="$1"
    echo "${LO2_CONTROL_CACHE[$file]}"
}


# Modified calculate_control_depth to use cached data efficiently
calculate_control_depth() {
    local caller_file="$1"
    local line="${BASH_LINENO[1]}"
    local current_func="${FUNCNAME[2]:-main}"

    lo2_debug_log "Calculating control depth for $current_func (line $line in $caller_file)" "depth_calc"

    [[ -z "$caller_file" ]] && {
        lo2_debug_log "No valid source file found" "depth_calc"
        return 0
    }

    analyze_source_file "$caller_file"

    local depth=0
    for control in "${!LO2_CONTROL_RANGES[@]}"; do
        IFS=':' read -r start end <<< "${LO2_CONTROL_RANGES[$control]}"
        if ((line >= start && line <= end)); then
            type="${LO2_CONTROL_TYPES[$control]}"
            ((depth++))
            lo2_debug_log "Inside $type control structure (range $start-$end) at depth $depth" "depth_calc"
        fi
    done

    lo2_debug_log "Final control depth: $depth" "depth_calc"
    echo "$depth"
}

# Override calculate_final_depth for control structure awareness
calculate_final_depth() {
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local base_depth
        base_depth=$(get_base_depth)
        lo2_debug_log "Base depth: $base_depth" "final_depth"

        local source_file
        source_file=$(get_actual_source_file)
        local control_depth
        control_depth=$(calculate_control_depth "$source_file")
        local total_depth=$((base_depth + control_depth))

        lo2_debug_log "Control depth: $control_depth, Total depth: $total_depth" "final_depth"
        echo "$total_depth"
    else
        get_base_depth
    fi
}

# Get actual source file helper
get_actual_source_file() {
    local stack_size=${#FUNCNAME[@]}
    local current_file=""

    lo2_debug_log "Inspecting call stack for source file" "get_source"

    # Start from 2 to skip get_actual_source_file and immediate caller
    for ((i=2; i<stack_size; i++)); do
        local source="${BASH_SOURCE[$i]}"
        lo2_debug_log "Checking source file: $source" "get_source"

        if [[ "$source" =~ ^/root/lab/(con/rc|con/rc[0-9]+|fun/.*|gem/.*)$ ]]; then
            current_file="$source"
            lo2_debug_log "Found matching source file: $current_file" "get_source"
            break
        fi
    done

    echo "$current_file"
}

# Control structure tracking toggle
setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            echo "true" > "$LOG_CONTROL_STATE_FILE"
            lo2_debug_log "Control structure depth tracking enabled" "setlogcontrol"
            printf "%sControl structure depth tracking enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            echo "false" > "$LOG_CONTROL_STATE_FILE"
            # Reset state
            LO2_CONTROL_RANGES=()
            LO2_CONTROL_TYPES=()
            LO2_LAST_ANALYZED_FILE=""
            LO2_SOURCE_LINES=()
            LO2_CONTROL_STACK=()
            lo2_debug_log "Control structure depth tracking disabled" "setlogcontrol"
            printf "%sControl structure depth tracking disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlogcontrol on|off\n"
            return 1
            ;;
    esac
}

# Add cleanup for caches
cleanup_lo2() {
    lo2_debug_log "Starting cleanup" "cleanup_lo2"
    LO2_CONTROL_RANGES=()
    LO2_CONTROL_TYPES=()
    LO2_SOURCE_LINES=()
    LO2_CONTROL_STACK=()
    LO2_FILE_CACHE=()
    LO2_CONTROL_CACHE=()
    lo2_debug_log "Cleanup complete" "cleanup_lo2"
}

# Export necessary functions and variables
export LOG_CONTROL_DEPTH_ENABLED
export -f setlogcontrol
export -f lo2_debug_log
export -f calculate_final_depth
export -A LO2_FILE_CACHE
export -A LO2_CONTROL_CACHE


# Set up cleanup trap
trap cleanup_lo2 EXIT

# Initialize control tracking based on saved state
[[ -f "$LOG_CONTROL_STATE_FILE" ]] && {
    saved_state=$(cat "$LOG_CONTROL_STATE_FILE")
    [[ "$saved_state" == "true" ]] && setlogcontrol on
}

lo2_debug_log "lo2 module loaded successfully" "init"
