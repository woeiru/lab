#!/bin/bash

# Enable immediate exit on error
set -e

# Start debug logging to both stderr and file
exec 19>/tmp/lo2_trace.log
BASH_XTRACEFD=19
set -x

echo "=== LO2 Loading Process Start ===" >&2

# First verify dependencies from lo1
for func in log get_base_depth get_indent get_color; do
    if ! declare -F "$func" >/dev/null; then
        echo "Error: Required function $func not found from lo1" >&2
        exit 1
    fi
done
echo "Phase 1: lo1 dependencies verified" >&2

# Verify environment variables
if [[ -z "$LOG_DIR" || -z "$TMP_DIR" ]]; then
    echo "Error: Required environment variables not set" >&2
    exit 1
fi
echo "Phase 2: Environment variables verified" >&2

# Verify directories exist and are writable
for dir in "$LOG_DIR/lo" "$TMP_DIR/lo"; do
    if [[ ! -d "$dir" ]]; then
        echo "Error: Directory $dir does not exist" >&2
        exit 1
    fi
    if [[ ! -w "$dir" ]]; then
        echo "Error: Directory $dir not writable" >&2
        exit 1
    fi
done
echo "Phase 3: Directories verified" >&2

# Define constants
LOG_LO_DIR="$LOG_DIR/lo"
TMP_LO_DIR="$TMP_DIR/lo"
LOG_CONTROL_STATE_FILE="${TMP_LO_DIR}/lo2_state"
LOG_DEBUG_FILE="${LOG_LO_DIR}/debug.log"

# Verify we can write to our state files
for file in "$LOG_CONTROL_STATE_FILE" "$LOG_DEBUG_FILE"; do
    if ! touch "$file" 2>/dev/null; then
        echo "Error: Cannot write to $file" >&2
        exit 1
    fi
done
echo "Phase 4: File access verified" >&2

# Initialize state
declare -g LOG_CONTROL_DEPTH_ENABLED=false
declare -ga CONTROL_DEPTH_STACK=()
declare -g LAST_COMMAND=""

echo "Phase 5: State initialized" >&2

# Core functions
lo2_debug_log() {
    local timestamp=$(date '+%H:%M:%S')
    local message="$1"
    local source="${2:-unknown}"
    printf "[LO2-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "$LOG_DEBUG_FILE"
    return 0
}

calculate_final_depth() {
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local base_depth control_depth total_depth
        base_depth=$(get_base_depth)
        control_depth=$(get_current_control_depth)
        total_depth=$((base_depth + control_depth))
        echo "$total_depth"
    else
        get_base_depth
    fi
}

get_current_control_depth() {
    echo "${#CONTROL_DEPTH_STACK[@]}"
}

track_control_depth() {
    local command="$1"
    [[ "$command" == "$LAST_COMMAND" ]] && return
    LAST_COMMAND="$command"

    case "$command" in
        if*|for*|while*|until*|case*|select*)
            CONTROL_DEPTH_STACK+=("$command")
            ;;
        fi|done|esac)
            if ((${#CONTROL_DEPTH_STACK[@]} > 0)); then
                unset 'CONTROL_DEPTH_STACK[-1]'
            fi
            ;;
    esac
}

setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            echo "true" > "$LOG_CONTROL_STATE_FILE"
            trap 'track_control_depth "$BASH_COMMAND"' DEBUG
            CONTROL_DEPTH_STACK=()
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            echo "false" > "$LOG_CONTROL_STATE_FILE"
            trap - DEBUG
            CONTROL_DEPTH_STACK=()
            ;;
        *)
            echo "Usage: setlogcontrol on|off" >&2
            return 1
            ;;
    esac
}

cleanup_lo2() {
    trap - DEBUG
    CONTROL_DEPTH_STACK=()
    LAST_COMMAND=""
}

echo "Phase 6: Functions defined" >&2

# Export functions and variables
export LOG_CONTROL_DEPTH_ENABLED
export -f lo2_debug_log
export -f calculate_final_depth
export -f get_current_control_depth
export -f track_control_depth
export -f setlogcontrol
export -f cleanup_lo2

echo "Phase 7: Exports completed" >&2

# Set up cleanup trap if none exists
if [[ -z "$(trap -p EXIT)" ]]; then
    trap cleanup_lo2 EXIT
fi

echo "Phase 8: Traps configured" >&2

# Initialize from saved state if exists
if [[ -f "$LOG_CONTROL_STATE_FILE" ]]; then
    saved_state=$(cat "$LOG_CONTROL_STATE_FILE")
    if [[ "$saved_state" == "true" ]]; then
        setlogcontrol on
    fi
fi

echo "Phase 9: State restored" >&2

# Disable error immediate exit
set +e

echo "=== LO2 Loading Process Complete ===" >&2

# Return explicitly
return 0
