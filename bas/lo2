#!/bin/bash

# Verify base module is loaded
if ! declare -F log >/dev/null; then
    echo "Error: Base logging module (lo1) must be loaded first" >&2
    return 1
fi

# Control structure tracking state
LOG_CONTROL_DEPTH_ENABLED=false
declare -A LO2_CONTROL_RANGES
declare -A LO2_CONTROL_TYPES
declare -g LO2_LAST_ANALYZED_FILE=""
declare -a LO2_SOURCE_LINES

# Cache the source file content and analyze control structures
analyze_source_file() {
    local file="$1"

    # Skip if already analyzed
    [[ "$file" == "$LO2_LAST_ANALYZED_FILE" ]] && return 0

    # Reset state
    LO2_CONTROL_RANGES=()
    LO2_CONTROL_TYPES=()
    LO2_SOURCE_LINES=()

    # Skip non-existent files
    [[ ! -f "$file" ]] && return 1

    # Load file content
    mapfile -t LO2_SOURCE_LINES < "$file"
    LO2_LAST_ANALYZED_FILE="$file"

    local line_number=0
    local structure_stack=()
    local structure_id=0

    while ((line_number < ${#LO2_SOURCE_LINES[@]})); do
        local line="${LO2_SOURCE_LINES[$line_number]}"
        local trimmed="${line#"${line%%[![:space:]]*}"}"

        case "$trimmed" in
            if*|for*|while*|until*|case*)
                local type="${trimmed%% *}"
                ((structure_id++))
                structure_stack+=("$type:$structure_id:$line_number")
                ;;
            elif*|else*)
                : # Just track these but don't increment depth
                ;;
            fi|done|esac)
                if ((${#structure_stack[@]} > 0)); then
                    local last_idx=$((${#structure_stack[@]} - 1))
                    local struct="${structure_stack[$last_idx]}"
                    IFS=':' read -r type id start <<< "$struct"
                    LO2_CONTROL_RANGES["$type:$id"]="$start:$line_number"
                    LO2_CONTROL_TYPES["$type:$id"]="$type"
                    unset 'structure_stack[$last_idx]'
                fi
                ;;
        esac
        ((line_number++))
    done
}

# Calculate depth from control structures
calculate_control_depth() {
    local file="${BASH_SOURCE[2]}"
    local line="${BASH_LINENO[1]}"
    local current_func="${FUNCNAME[2]:-main}"

    # If we're in a root function, no control depth
    if is_root_function "$current_func"; then
        return 0
    fi

    # Analyze file if needed
    analyze_source_file "$file"

    local depth=0
    # Count active control structures
    for control in "${!LO2_CONTROL_RANGES[@]}"; do
        IFS=':' read -r start end <<< "${LO2_CONTROL_RANGES[$control]}"
        if ((line > start && line < end)); then
            ((depth++))
        fi
    done

    echo "$depth"
}

# Override the final depth calculation when enabled
calculate_final_depth_with_controls() {
    local base_depth
    base_depth=$(get_base_depth)

    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local control_depth
        control_depth=$(calculate_control_depth)
        echo $((base_depth + control_depth))
    else
        echo "$base_depth"
    fi
}

# Toggle control structure tracking
setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            # Override depth calculation
            eval "function calculate_final_depth() { calculate_final_depth_with_controls; }"
            printf "%sControl structure depth tracking enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            # Restore original depth calculation
            eval "function calculate_final_depth() { get_base_depth; }"
            # Clean up state
            LO2_CONTROL_RANGES=()
            LO2_CONTROL_TYPES=()
            LO2_LAST_ANALYZED_FILE=""
            LO2_SOURCE_LINES=()
            printf "%sControl structure depth tracking disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlogcontrol on|off\n"
            return 1
            ;;
    esac
}

# Clean up on exit
cleanup_lo2() {
    [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]] && setlogcontrol off
    LO2_CONTROL_RANGES=()
    LO2_CONTROL_TYPES=()
    LO2_LAST_ANALYZED_FILE=""
    LO2_SOURCE_LINES=()
}

# Export necessary functions
export LOG_CONTROL_DEPTH_ENABLED
export -f setlogcontrol

# Set up cleanup trap
trap cleanup_lo2 EXIT
