#!/bin/bash

# Verify base module is loaded
if ! declare -F log >/dev/null; then
    echo "Error: Base logging module (lo1) must be loaded first" >&2
    return 1
fi

# Verify required environment variables
[[ -z "$LOG_DIR" ]] && {
    echo "Fatal: LOG_DIR environment variable not set" >&2
    return 1
}
[[ -z "$TMP_DIR" ]] && {
    echo "Fatal: TMP_DIR environment variable not set" >&2
    return 1
}

# Define module-specific directories and files
readonly LOG_LO_DIR="$LOG_DIR/lo"
readonly TMP_LO_DIR="$TMP_DIR/lo"
readonly LOG_CONTROL_STATE_FILE="${TMP_LO_DIR}/lo2_state"
readonly LOG_DEBUG_FILE="${LOG_LO_DIR}/debug.log"

# Verify critical directories exist
for dir in "$LOG_LO_DIR" "$TMP_LO_DIR"; do
    [[ ! -d "$dir" ]] && {
        echo "Critical: Required directory missing: $dir" >&2
        return 1
    }
done

# Control structure tracking state
declare -g LOG_CONTROL_DEPTH_ENABLED=false  # Start disabled by default
declare -gA LO2_CONTROL_RANGES=()
declare -gA LO2_CONTROL_TYPES=()
declare -g LO2_LAST_ANALYZED_FILE=""
declare -ga LO2_SOURCE_LINES=()

# Initialize state file
[[ ! -f "$LOG_CONTROL_STATE_FILE" ]] && echo "false" > "$LOG_CONTROL_STATE_FILE"

# Enhanced debug logging for lo2
lo2_debug_log() {
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local source="${2:-unknown}"
    printf "[LO2-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "$LOG_DEBUG_FILE"
}

# Debug helper for control structure analysis
debug_control_structure() {
    [[ "${LOG_DEBUG_ENABLED:-0}" != "1" ]] && return 0
    local type="$1"
    local id="$2"
    local range="${LO2_CONTROL_RANGES["$type:$id"]}"
    lo2_debug_log "Found control structure: $type (ID: $id) Range: $range" "analyze_source"
}

# Improved source file analysis
analyze_source_file() {
    local file="$1"

    # Skip if already analyzed
    [[ "$file" == "$LO2_LAST_ANALYZED_FILE" ]] && return 0

    lo2_debug_log "Starting analysis of file: $file" "analyze_source"

    # Reset state
    LO2_CONTROL_RANGES=()
    LO2_CONTROL_TYPES=()
    LO2_SOURCE_LINES=()

    [[ ! -f "$file" ]] && {
        lo2_debug_log "File not found: $file" "analyze_source"
        return 1
    }

    # Load file content
    mapfile -t LO2_SOURCE_LINES < "$file"
    LO2_LAST_ANALYZED_FILE="$file"

    local line_number=0
    local structure_stack=()
    local structure_id=0

    while ((line_number < ${#LO2_SOURCE_LINES[@]})); do
        local line="${LO2_SOURCE_LINES[$line_number]}"
        local trimmed="${line#"${line%%[![:space:]]*}"}"

        case "$trimmed" in
            if*|for*|while*|until*|case*)
                local type="${trimmed%% *}"
                ((structure_id++))
                structure_stack+=("$type:$structure_id:$line_number")
                lo2_debug_log "Started $type block at line $line_number (ID: $structure_id)" "analyze_source"
                ;;
            fi|done|esac)
                if ((${#structure_stack[@]} > 0)); then
                    local last_idx=$((${#structure_stack[@]} - 1))
                    local struct="${structure_stack[$last_idx]}"
                    IFS=':' read -r type id start <<< "$struct"
                    LO2_CONTROL_RANGES["$type:$id"]="$start:$line_number"
                    LO2_CONTROL_TYPES["$type:$id"]="$type"
                    debug_control_structure "$type" "$id"
                    unset 'structure_stack[$last_idx]'
                fi
                ;;
        esac
        ((line_number++))
    done

    lo2_debug_log "Analysis complete. Found ${#LO2_CONTROL_RANGES[@]} control structures" "analyze_source"
}

# Calculate depth from control structures
calculate_control_depth() {
    local file="${BASH_SOURCE[2]}"
    local line="${BASH_LINENO[1]}"
    local current_func="${FUNCNAME[2]:-main}"

    lo2_debug_log "Calculating control depth for $current_func (line $line in $file)" "depth_calc"

    # If we're in a root function, no control depth
    is_root_function "$current_func" && return 0

    analyze_source_file "$file"

    local depth=0
    for control in "${!LO2_CONTROL_RANGES[@]}"; do
        IFS=':' read -r start end <<< "${LO2_CONTROL_RANGES[$control]}"
        if ((line > start && line < end)); then
            ((depth++))
            lo2_debug_log "Inside control structure $control (${LO2_CONTROL_TYPES[$control]}) at depth $depth" "depth_calc"
        fi
    done

    lo2_debug_log "Final control depth: $depth" "depth_calc"
    echo "$depth"
}

# Direct function override instead of using eval
calculate_final_depth() {
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        local base_depth
        base_depth=$(get_base_depth)
        lo2_debug_log "Base depth: $base_depth" "final_depth"

        local control_depth
        control_depth=$(calculate_control_depth)
        local total_depth=$((base_depth + control_depth))
        lo2_debug_log "Control depth: $control_depth, Total depth: $total_depth" "final_depth"
        echo "$total_depth"
    else
        get_base_depth
    fi
}

# Improved control structure tracking toggle
setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            echo "true" > "$LOG_CONTROL_STATE_FILE"
            lo2_debug_log "Control structure depth tracking enabled" "setlogcontrol"
            printf "%sControl structure depth tracking enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            echo "false" > "$LOG_CONTROL_STATE_FILE"
            # Clean up state
            LO2_CONTROL_RANGES=()
            LO2_CONTROL_TYPES=()
            LO2_LAST_ANALYZED_FILE=""
            LO2_SOURCE_LINES=()
            lo2_debug_log "Control structure depth tracking disabled" "setlogcontrol"
            printf "%sControl structure depth tracking disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlogcontrol on|off\n"
            return 1
            ;;
    esac
}

# Cleanup function
cleanup_lo2() {
    lo2_debug_log "Starting cleanup" "cleanup_lo2"
    LO2_CONTROL_RANGES=()
    LO2_CONTROL_TYPES=()
    LO2_LAST_ANALYZED_FILE=""
    LO2_SOURCE_LINES=()
    lo2_debug_log "Cleanup complete" "cleanup_lo2"
}

# Export necessary functions and variables
export LOG_CONTROL_DEPTH_ENABLED
export -f setlogcontrol
export -f lo2_debug_log
export -f calculate_final_depth

# Set up cleanup trap
trap cleanup_lo2 EXIT

# Initialize control tracking based on saved state
[[ -f "$LOG_CONTROL_STATE_FILE" ]] && {
    saved_state=$(cat "$LOG_CONTROL_STATE_FILE")
    [[ "$saved_state" == "true" ]] && setlogcontrol on
}

lo2_debug_log "lo2 module loaded successfully" "init"
