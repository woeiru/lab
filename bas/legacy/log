#!/bin/bash

# ============================================================================
# Advanced Automatic Hierarchical Logger v2.0
# ============================================================================
# This module provides automatic hierarchical logging with improved depth
# handling and more consistent visual formatting. Key improvements include:
# - Enhanced depth calculation with better call stack analysis
# - Improved parent-child relationship tracking
# - More consistent visual formatting
# - Better subshell handling
# - Comprehensive debugging capabilities
# - Memory optimization with periodic cache cleanup

# ============================================================================
# Configuration and Environment Setup
# ============================================================================

# Directory and file setup with fallback handling
LOG_DIR="${LOG_DIR:-/var/log/rc}"
TMP_DIR="${TMP_DIR:-/tmp}"  # New temporary directory for state files

# Ensure directories exist with fallbacks
[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/var/log/rc"
[[ ! -d "$TMP_DIR" ]] && mkdir -p "$TMP_DIR" 2>/dev/null || TMP_DIR="/tmp"

# Log files
LOG_FILE="${LOG_DIR}/rc_hierarchical.log"
LOG_DEBUG_FILE="${LOG_DIR}/rc_debug.log"

# State files (now in TMP_DIR)
LOG_STATE_FILE="${TMP_DIR}/rc_log_state"
LOG_DEPTH_CACHE_FILE="${TMP_DIR}/rc_depth_cache"
LOG_CONTEXT_FILE="${TMP_DIR}/rc_context"
LOG_TRACE_FILE="${TMP_DIR}/rc_trace"

# Enable debug mode through environment variable
readonly LOG_DEBUG_ENABLED="${LOG_DEBUG:-1}"

# ============================================================================
# Color Definitions
# ============================================================================
# Using printf for proper escape sequence handling
readonly LOG_RED=$(printf '\033[0;31m')      # Level 1 (Critical)
readonly LOG_ORANGE=$(printf '\033[0;33m')   # Level 2 (Error)
readonly LOG_YELLOW=$(printf '\033[1;33m')   # Level 3 (Warning)
readonly LOG_GREEN=$(printf '\033[0;32m')    # Level 4 (Success)
readonly LOG_CYAN=$(printf '\033[0;36m')     # Level 5 (Info)
readonly LOG_BLUE=$(printf '\033[0;34m')     # Level 6 (Debug)
readonly LOG_INDIGO=$(printf '\033[0;35m')   # Level 7 (Trace)
readonly LOG_VIOLET=$(printf '\033[1;35m')   # Level 8 (Detail)
readonly LOG_WHITE=$(printf '\033[1;37m')    # Level 9+ (Extra)
readonly LOG_NC=$(printf '\033[0m')          # No Color

# ============================================================================
# Constants
# ============================================================================
readonly ROOT_LEVEL=1
readonly MAX_DEPTH=20
readonly MAX_TRACKING_ENTRIES=1000
readonly CACHE_CLEANUP_INTERVAL=300  # 5 minutes

# ============================================================================
# State Management
# ============================================================================

# Core state tracking
declare -A LOG_ROOT_FUNCTIONS     # Registered root functions that reset hierarchy
declare -A LOG_DEPTH_CACHE       # Cache of calculated depths for performance
declare -A LOG_PARENT_CONTEXTS   # Track parent-child relationships
declare -A LOG_STACK_TRACES      # Store stack traces for debugging
declare -a LOG_CONTEXT_STACK     # Stack of current execution context
declare -i LOG_CURRENT_DEPTH=0   # Current depth in the hierarchy
declare -i LAST_CACHE_CLEANUP=0  # Timestamp of last cache cleanup

# Function to ensure state file directories exist
ensure_state_directories() {
    local dirs=("$LOG_DIR" "$TMP_DIR")
    local success=true

    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            if ! mkdir -p "$dir" 2>/dev/null; then
                echo "Warning: Failed to create directory: $dir" >&2
                success=false
            fi
        fi
    done

    $success
}

# Function to initialize state files
init_state_files() {
    # Initialize log state file if it doesn't exist
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"

    # Initialize other state files if needed
    [[ ! -f "$LOG_DEPTH_CACHE_FILE" ]] && touch "$LOG_DEPTH_CACHE_FILE"
    [[ ! -f "$LOG_CONTEXT_FILE" ]] && touch "$LOG_CONTEXT_FILE"
    [[ ! -f "$LOG_TRACE_FILE" ]] && touch "$LOG_TRACE_FILE"
}

# ============================================================================
# Debug Support Functions
# ============================================================================

# Enhanced debug logging function
debug_log() {
    [[ "${LOG_DEBUG_ENABLED}" != "1" ]] && return 0

    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    printf "[DEBUG] %s - %s\n" "$timestamp" "$message" >> "$LOG_DEBUG_FILE"
}

# Function to dump current stack trace
dump_stack_trace() {
    local func="${1:-${FUNCNAME[1]}}"
    debug_log "Stack trace for $func:"
    local i=0
    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        debug_log "  $i: ${FUNCNAME[$i]:-main} (${BASH_SOURCE[$i]:-unknown}:${BASH_LINENO[$i]:-0})"
        ((i++))
    done
}

# ============================================================================
# Cache Management
# ============================================================================

# Periodic cache cleanup to prevent memory bloat
cleanup_cache() {
    local current_time=$(date +%s)
    if ((current_time - LAST_CACHE_CLEANUP >= CACHE_CLEANUP_INTERVAL)); then
        debug_log "Performing cache cleanup"
        LOG_DEPTH_CACHE=()
        : > "$LOG_DEPTH_CACHE_FILE"  # Clear cache file
        LAST_CACHE_CLEANUP=$current_time
    fi
}

# ============================================================================
# Core Logging Functions
# ============================================================================

# Improved depth calculation with better stack analysis
calculate_stack_depth() {
    local current_func="${FUNCNAME[1]:-main}"
    local depth=0

    # Perform cache cleanup if needed
    cleanup_cache

    debug_log "Calculating depth for function: $current_func"

    # Check cache first for performance
    if [[ -n "${LOG_DEPTH_CACHE[$current_func]:-}" ]]; then
        debug_log "Cache hit for $current_func: ${LOG_DEPTH_CACHE[$current_func]}"
        echo "${LOG_DEPTH_CACHE[$current_func]}"
        return
    fi

    # Store the initial stack for reference
    local -a initial_stack=("${FUNCNAME[@]}")
    local stack_size=${#initial_stack[@]}

    # Walk up the call stack counting actual function calls
    local i=1
    local prev_func=""
    local stack_trace=""
    local current_depth=0
    local found_exec=false

    while [[ -n "${initial_stack[$i]:-}" ]]; do
        local func="${initial_stack[$i]}"

        # Skip internal logging functions
        if [[ "$func" =~ ^(log|debug_log|calculate_stack_depth|get_indent)$ ]]; then
            ((i++))
            continue
        fi

        # Track execution_rc specially
        if [[ "$func" == "execution_rc" ]]; then
            found_exec=true
        fi

        # Skip direct recursion
        if [[ "$func" == "$prev_func" ]]; then
            ((i++))
            continue
        fi

        # Add to depth unless it's a root function
        if ! is_root_function "$func"; then
            ((current_depth++))
        elif [[ "$func" == "main_rc" ]]; then
            break
        fi

        # Track the function in our trace
        stack_trace+="$func:"

        prev_func="$func"
        ((i++))
    done

    # Adjust depth for execution_rc context
    if [[ "$found_exec" == "true" ]]; then
        ((current_depth++))
    fi

    # Store results
    LOG_DEPTH_CACHE[$current_func]=$current_depth
    LOG_STACK_TRACES[$current_func]=$stack_trace

    debug_log "Calculated depth for $current_func: $current_depth (stack: $stack_trace)"
    echo "$current_depth"
}

# Improved indentation generation
get_indent() {
    local depth="$1"
    local indent=""

    # Base indentation
    case $depth in
        0) indent="    " ;; # 4 spaces for root
        1) indent="      " ;; # 6 spaces for first level
        *) # For deeper levels, start with 6 spaces and add 2 for each level
           indent="      "
           for ((i=2; i<=depth; i++)); do
               indent="  $indent"
           done
           ;;
    esac

    echo -n "$indent└─"
}

# Get appropriate color for current depth
get_color() {
    local depth="$1"
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Main logging function with improved formatting
log() {
    # Validate input
    if [[ "$1" != "lvl" ]]; then
        echo "Error: Invalid log command" >&2
        return 1
    fi
    local message="$2"

    # Check if logging is enabled
    local log_enabled
    log_enabled=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$log_enabled" != "true" ]] && return 0

    # Calculate depth and get formatting
    local depth
    depth=$(calculate_stack_depth)
    local indent
    indent=$(get_indent "$depth")
    local color
    color=$(get_color "$depth")
    local timestamp
    timestamp=$(date '+%H:%M:%S')

    # Special handling for report headers
    if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
        printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC" | tee -a "$LOG_FILE"
    else
        printf "%s%s %s [%s]%s\n" \
            "$color" \
            "$indent" \
            "$message" \
            "$timestamp" \
            "$LOG_NC" | tee -a "$LOG_FILE"
    fi

    # Update context
    local current_func="${FUNCNAME[1]:-main}"
    if [[ -n "$current_func" && "$current_func" != "main" ]]; then
        push_context "$current_func"
    fi

    # Debug logging if enabled
    if [[ "${LOG_DEBUG_ENABLED}" == "1" ]]; then
        debug_log "Logged message from $current_func (depth: $depth)"
        dump_stack_trace "$current_func"
    fi
}

# ============================================================================
# Context Management
# ============================================================================

# Push new context onto the stack
push_context() {
    local context="$1"
    LOG_CONTEXT_STACK+=("$context")
    debug_log "Pushed context: $context"
}

# Pop context from the stack
pop_context() {
    local stack_size=${#LOG_CONTEXT_STACK[@]}
    if ((stack_size > 0)); then
        local popped="${LOG_CONTEXT_STACK[stack_size-1]}"
        unset 'LOG_CONTEXT_STACK[stack_size-1]'
        debug_log "Popped context: $popped"
    fi
}

# ============================================================================
# Utility Functions
# ============================================================================

# Toggle logging on/off
setlog() {
    case "$1" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            printf "%sLogging disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            printf "%sLogging enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        *)
            if [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                printf "%sLogging is currently disabled. Use 'setlog on' to enable.%s\n" \
                    "$LOG_YELLOW" "$LOG_NC"
                return 1
            fi

            printf "%sInvalid input. Usage:%s\n" "$LOG_RED" "$LOG_NC"
            printf "   setlog on|off    - Enable or disable logging\n"
            return 1
            ;;
    esac
}

# Print current hierarchy (for debugging)
print_hierarchy() {
    printf "\n%sCurrent Logging Hierarchy:%s\n" "$LOG_BLUE" "$LOG_NC"
    printf "%s=========================%s\n" "$LOG_BLUE" "$LOG_NC"

    local i=0
    for context in "${LOG_CONTEXT_STACK[@]}"; do
        printf "%s%$(($i * 2))s%s%s\n" \
            "$(get_color $i)" \
            "" \
            "$context" \
            "$LOG_NC"
        ((i++))
    done

    printf "%s=========================%s\n\n" "$LOG_BLUE" "$LOG_NC"
}

# ============================================================================
# Initialization
# ============================================================================

init_logger() {
    # Ensure required directories exist
    ensure_state_directories || {
        echo "Fatal: Failed to initialize logger directories" >&2
        return 1
    }

    # Initialize state files
    init_state_files

    # Clear any existing state
    LOG_ROOT_FUNCTIONS=()
    LOG_DEPTH_CACHE=()
    LOG_PARENT_CONTEXTS=()
    LOG_STACK_TRACES=()
    LOG_CONTEXT_STACK=()
    LOG_CURRENT_DEPTH=0
    LAST_CACHE_CLEANUP=$(date +%s)

    # Initialize debug log if enabled
    if [[ "${LOG_DEBUG_ENABLED}" == "1" ]]; then
        : > "$LOG_DEBUG_FILE"
        debug_log "Logger initialized"
        debug_log "Using LOG_DIR: $LOG_DIR"
        debug_log "Using TMP_DIR: $TMP_DIR"
    fi

    # Create initial log entry
    printf "Logger initialized at %s\n" "$(date)" > "$LOG_FILE"
    printf "Using LOG_DIR: %s\n" "$LOG_DIR" >> "$LOG_FILE"
    printf "Using TMP_DIR: %s\n" "$TMP_DIR" >> "$LOG_FILE"
}

# ============================================================================
# Cleanup
# ============================================================================

cleanup_logger() {
    debug_log "Cleaning up logger state"
    LOG_ROOT_FUNCTIONS=()
    LOG_DEPTH_CACHE=()
    LOG_PARENT_CONTEXTS=()
    LOG_STACK_TRACES=()
    LOG_CONTEXT_STACK=()
    LOG_CURRENT_DEPTH=0

    # Clean up state files in TMP_DIR
    rm -f "$LOG_DEPTH_CACHE_FILE" "$LOG_CONTEXT_FILE" "$LOG_TRACE_FILE"
}

# ============================================================================
# Root Function Detection
# ============================================================================

# Initialize array of known root functions
declare -gA ROOT_FUNCTIONS=(
    [main_rc]=1
    [setup_rc]=1
    [source_rc]=1
    [execution_rc]=1
)

# Function to register additional root functions
register_root_function() {
    local func_name="$1"
    ROOT_FUNCTIONS[$func_name]=1
    debug_log "Registered root function: $func_name"
}

# Function to check if a function is a root function
is_root_function() {
    local func_name="$1"

    debug_log "Checking if $func_name is root function"

    # Only consider main_rc as a true root
    # Treat execution_rc as a special case that contributes to depth
    case "$func_name" in
        main_rc)
            debug_log "$func_name is the main root function"
            return 0
            ;;
        *)
            debug_log "$func_name is not a root function"
            return 1
            ;;
    esac
}

# Function to list all registered root functions
list_root_functions() {
    printf "Registered Root Functions:\n"
    for func in "${!ROOT_FUNCTIONS[@]}"; do
        printf "  - %s\n" "$func"
    done
}

# ============================================================================
# Export Functions and Variables
# ============================================================================

export -f log
export -f setlog
export -f print_hierarchy
export LOG_FILE
export LOG_STATE_FILE
export TMP_DIR
export -f register_root_function
export -f is_root_function
export -f list_root_functions
export -A ROOT_FUNCTIONS

# Set up cleanup trap
trap cleanup_logger EXIT

# Initialize logger on source
init_logger
