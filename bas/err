#!/bin/bash

# Define the error log file location and additional tracking files
ERROR_LOG="${LOG_DIR:-/var/log/rc}/rc_error.log"
ERROR_COUNT_FILE="/tmp/rc_error_count"
ERROR_STATE_FILE="/tmp/rc_error_state"

# Define error codes with descriptive names
declare -gA ERROR_CODES=(
    [SUCCESS]=0
    [GENERAL_ERROR]=1
    [FILE_NOT_FOUND]=2
    [PERMISSION_DENIED]=3
    [FUNCTION_NOT_FOUND]=4
    [EXECUTION_FAILED]=5
    [SOURCE_ERROR]=6
    [DEPENDENCY_ERROR]=7
    [CONFIG_ERROR]=8
    [OPTIONAL_WARNING]=100  # Special code for optional component warnings
)

# Initialize error tracking arrays with better scope control
declare -gA ERROR_COMPONENTS
declare -gA ERROR_MESSAGES
declare -gA ERROR_TIMESTAMPS
declare -gA ERROR_EXIT_CODES
declare -gA ERROR_SEVERITIES
declare -ga ERROR_ORDER

# Function to ensure clean exit from the script
clean_exit() {
    local exit_code=${1:-${ERROR_CODES[SUCCESS]}}
    trap - ERR  # Remove the error handling trap
    trap - EXIT # Remove exit trap if present
    exit $exit_code
}

# Function to check if a component has any errors
has_errors() {
    local component="$1"
    local has_error=false

    for error_id in "${ERROR_ORDER[@]}"; do
        if [[ "${ERROR_COMPONENTS[$error_id]}" == "$component" ]]; then
            has_error=true
            break
        fi
    done

    $has_error
}

# Enhanced error handler function with improved tracking
error_handler() {
    local line_number="$1"
    local error_code="${2:-${ERROR_CODES[GENERAL_ERROR]}}"
    local is_optional="${3:-false}"
    local exit_code="$?"
    local command="${BASH_COMMAND:-Unknown command}"
    local timestamp=$(date '+%Y%m%d%H%M%S')
    local source_file="${BASH_SOURCE[1]:-unknown}"
    local component="${FUNCNAME[1]:-main}"

    # Determine error description
    local error_desc=""
    for key in "${!ERROR_CODES[@]}"; do
        if [[ ${ERROR_CODES[$key]} -eq $error_code ]]; then
            error_desc="$key"
            break
        fi
    done
    [[ -z "$error_desc" ]] && error_desc="UNKNOWN_ERROR"

    # Generate unique error ID with more information
    local error_id="${timestamp}_${component}_${line_number}"

    # Store error information with enhanced detail
    ERROR_COMPONENTS[$error_id]="$component"
    ERROR_MESSAGES[$error_id]="[$error_desc] In $source_file on line $line_number: $command failed with status $error_code"
    ERROR_TIMESTAMPS[$error_id]="$timestamp"
    ERROR_EXIT_CODES[$error_id]="$error_code"
    ERROR_SEVERITIES[$error_id]="$is_optional"
    ERROR_ORDER+=("$error_id")

    # Log to both error log file and stderr with improved formatting
    local severity_prefix="ERROR"
    [[ "$is_optional" == "true" ]] && severity_prefix="WARNING"

    {
        echo "└─ $severity_prefix($error_desc) $timestamp - In $source_file on line $line_number: Command '$command' failed with status $error_code"
    } | tee -a "$ERROR_LOG" >&2

    # Return appropriate status
    return $([[ "$is_optional" == "true" ]] && echo "${ERROR_CODES[SUCCESS]}" || echo "$error_code")
}

# Enhanced error reporting function with better organization
print_error_report() {
    local total_errors=0
    local total_warnings=0
    declare -A error_types
    declare -A warnings_by_type

    # Count and categorize issues
    for error_id in "${ERROR_ORDER[@]}"; do
        local error_code="${ERROR_EXIT_CODES[$error_id]}"
        local is_optional="${ERROR_SEVERITIES[$error_id]}"

        if [[ "$is_optional" == "true" ]]; then
            ((total_warnings++))
            ((warnings_by_type[$error_code]++))
        else
            ((total_errors++))
            ((error_types[$error_code]++))
        fi
    done

    # Print report header
    {
        printf "\n"
        printf " ━ RC Error Report\n"
        printf " ━ Generated: %s\n" "$(date)"
        printf " ━ Total issues: %d (Errors: %d, Warnings: %d)\n" "$((total_errors + total_warnings))" "$total_errors" "$total_warnings"
        printf "\n"

        # Print errors first if any exist
        if ((total_errors > 0)); then
            printf " ━ Errors by type:\n"
            for code in "${!error_types[@]}"; do
                local count=${error_types[$code]}
                local desc
                for key in "${!ERROR_CODES[@]}"; do
                    if [[ ${ERROR_CODES[$key]} -eq $code ]]; then
                        desc="$key"
                        break
                    fi
                done
                printf "   └─ %s: %d occurrences\n" "$desc" "$count"
            done
            printf "\n"

            printf " ━ Error details:\n"
            for error_id in "${ERROR_ORDER[@]}"; do
                if [[ "${ERROR_SEVERITIES[$error_id]}" != "true" ]]; then
                    printf "   └─ [%s] %s\n" "${ERROR_COMPONENTS[$error_id]}" "${ERROR_MESSAGES[$error_id]}"
                    printf "      Time: %s\n" "$(date -d "@${ERROR_TIMESTAMPS[$error_id]%.*}")"
                fi
            done
            printf "\n"
        fi

        # Print warnings if any exist
        if ((total_warnings > 0)); then
            printf " ━ Warnings by type:\n"
            for code in "${!warnings_by_type[@]}"; do
                local count=${warnings_by_type[$code]}
                local desc
                for key in "${!ERROR_CODES[@]}"; do
                    if [[ ${ERROR_CODES[$key]} -eq $code ]]; then
                        desc="$key"
                        break
                    fi
                done
                printf "   └─ %s: %d occurrences\n" "$desc" "$count"
            done
            printf "\n"

            printf " ━ Warning details:\n"
            for error_id in "${ERROR_ORDER[@]}"; do
                if [[ "${ERROR_SEVERITIES[$error_id]}" == "true" ]]; then
                    printf "   └─ [%s] %s\n" "${ERROR_COMPONENTS[$error_id]}" "${ERROR_MESSAGES[$error_id]}"
                    printf "      Time: %s\n" "$(date -d "@${ERROR_TIMESTAMPS[$error_id]%.*}")"
                fi
            done
            printf "\n"
        fi

        if ((total_errors + total_warnings == 0)); then
            printf " ━ No issues detected during startup\n"
        fi

        printf " ━ Error log file: %s\n" "$ERROR_LOG"
        printf "\n"
    } >&2

    # Return non-zero if there were any non-optional errors
    return $((total_errors > 0 ? 1 : 0))
}

# Setup function to initialize error handling
setup_error_handling() {
    # Clear existing error tracking
    ERROR_COMPONENTS=()
    ERROR_MESSAGES=()
    ERROR_TIMESTAMPS=()
    ERROR_EXIT_CODES=()
    ERROR_SEVERITIES=()
    ERROR_ORDER=()

    # Set up error handling trap
    trap 'error_handler $LINENO' ERR
}

# Export functions and variables
export ERROR_LOG
export -A ERROR_CODES
export -A ERROR_COMPONENTS
export -A ERROR_MESSAGES
export -A ERROR_TIMESTAMPS
export -A ERROR_EXIT_CODES
export -A ERROR_SEVERITIES
export -a ERROR_ORDER
export -f clean_exit
export -f has_errors
export -f error_handler
export -f print_error_report
export -f setup_error_handling
