#!/bin/bash
# bas/var - Variable verification module

# First declare all module variables
declare -g VAR_DEBUG_ENABLED="${VAR_DEBUG_ENABLED:-0}"
declare -g VAR_LAST_CHECK
declare -gA VAR_CHECK_CACHE

# Basic verification functions that will be used immediately
var_debug_log() {
    [[ "${VAR_DEBUG_ENABLED}" != "1" ]] && return 0
    local timestamp=$(date '+%H:%M:%S')
    local message="$1"
    local source="${2:-unknown}"
    printf "[VAR-DEBUG] %s - [%s] %s\n" "$timestamp" "$source" "$message" >> "$LOG_DEBUG_FILE"
}

# Enhanced verification with caching
verify_var() {
    local var_name="$1"
    local var_value="${!var_name}"
    local caller="${FUNCNAME[1]:-main}"
    local lineno="${BASH_LINENO[0]}"
    local source="${BASH_SOURCE[1]:-unknown}"
    local cache_key="${var_name}:${source}:${lineno}"

    # Use cache to avoid repeated checks in hot paths
    if [[ -n "${VAR_CHECK_CACHE[$cache_key]}" ]]; then
        var_debug_log "Cache hit for $var_name" "verify"
        return 0
    fi

    if [[ -z "$var_name" ]]; then
        var_debug_log "Empty variable name passed to verify_var" "error"
        return 1
    fi

    if [[ -z "$var_value" ]]; then
        var_debug_log "Variable '$var_name' is empty (called from $source:$lineno in $caller)" "error"
        return 1
    fi

    # Cache successful verification
    VAR_CHECK_CACHE[$cache_key]=1
    var_debug_log "Verified and cached $var_name" "verify"
    return 0
}

verify_vars() {
    local failed=0
    local var_name

    for var_name in "$@"; do
        if ! verify_var "$var_name"; then
            ((failed++))
        fi
    done

    return $((failed > 0))
}

verify_path() {
    local path_var="$1"
    local path_type="$2"  # dir or file
    local create="${3:-false}"  # whether to create if missing
    local path_value="${!path_var}"
    local caller="${FUNCNAME[1]:-main}"
    local lineno="${BASH_LINENO[0]}"
    local source="${BASH_SOURCE[1]:-unknown}"

    # First verify the variable itself
    if ! verify_var "$path_var"; then
        return 1
    fi

    case "$path_type" in
        dir)
            if [[ ! -d "$path_value" ]]; then
                if [[ "$create" == "true" ]]; then
                    var_debug_log "Creating directory $path_value" "path"
                    if ! mkdir -p "$path_value"; then
                        var_debug_log "Failed to create directory $path_value" "error"
                        return 1
                    fi
                else
                    var_debug_log "Directory $path_value does not exist" "error"
                    return 1
                fi
            fi
            ;;
        file)
            if [[ ! -f "$path_value" ]]; then
                if [[ "$create" == "true" ]]; then
                    var_debug_log "Creating file $path_value" "path"
                    if ! touch "$path_value" 2>/dev/null; then
                        var_debug_log "Failed to create file $path_value" "error"
                        return 1
                    fi
                else
                    var_debug_log "File $path_value does not exist" "error"
                    return 1
                fi
            fi
            ;;
    esac

    return 0
}

# Path verification with automatic parent directory creation
verify_path_auto() {
    local path="$1"
    local type="$2"

    # Create parent directory if needed
    local parent_dir=$(dirname "$path")
    if [[ ! -d "$parent_dir" ]]; then
        var_debug_log "Creating parent directory $parent_dir" "path"
        mkdir -p "$parent_dir"
    fi

    verify_path "$path" "$type" true
}

# Cleanup function
cleanup_var() {
    var_debug_log "Cleaning up VAR module" "cleanup"
    VAR_CHECK_CACHE=()
    unset VAR_LAST_CHECK
}

# Export all functions and variables
export VAR_DEBUG_ENABLED
export -A VAR_CHECK_CACHE
export -f var_debug_log verify_var verify_vars verify_path verify_path_auto cleanup_var
