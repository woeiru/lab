#!/bin/bash

# Directory and file setup
LOG_DIR="${LOG_DIR:-/var/log/lab/lo}"
TMP_DIR="${TMP_DIR:-/tmp/lab/lo}"

[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp/lab/lo"
[[ ! -d "$TMP_DIR" ]] && mkdir -p "$TMP_DIR" 2>/dev/null || TMP_DIR="/tmp/lab/lo"

LOG_FILE="${LOG_DIR}/hierarchical.log"
LOG_STATE_FILE="${TMP_DIR}/log_state"
LOG_DEBUG_FILE="${LOG_DIR}/debug.log"
LOG_DEPTH_CACHE_FILE="${TMP_DIR}/depth_cache"
LOG_DEBUG_ENABLED="${LOG_DEBUG:-1}"

# Initialize state file if it doesn't exist
[[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"

# Color definitions
readonly LOG_RED=$(printf '\033[0;31m')
readonly LOG_ORANGE=$(printf '\033[0;33m')
readonly LOG_YELLOW=$(printf '\033[1;33m')
readonly LOG_GREEN=$(printf '\033[0;32m')
readonly LOG_CYAN=$(printf '\033[0;36m')
readonly LOG_BLUE=$(printf '\033[0;34m')
readonly LOG_INDIGO=$(printf '\033[0;35m')
readonly LOG_VIOLET=$(printf '\033[1;35m')
readonly LOG_WHITE=$(printf '\033[1;37m')
readonly LOG_NC=$(printf '\033[0m')

# State tracking
declare -A LOG_DEPTH_CACHE
declare -A LOG_PARENTS
declare -A LOG_CHILDREN
declare -g LOG_CURRENT_PARENT=""
declare -i LAST_CACHE_CLEANUP=0
readonly CACHE_CLEANUP_INTERVAL=300  # 5 minutes

# Root function handling
declare -gA ROOT_FUNCTIONS=([main_rc]=1)

# Debug support
# In lo1, find and modify the debug_log function:
debug_log() {
    [[ "${LOG_DEBUG_ENABLED}" != "1" ]] && return 0
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    printf "[LO1-DEBUG] %s - %s\n" "$timestamp" "$message" >> "$LOG_DEBUG_FILE"
}

dump_stack_trace() {
    local func="${1:-${FUNCNAME[1]}}"
    debug_log "Stack trace for $func:"
    local i=0
    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        debug_log "  $i: ${FUNCNAME[$i]:-main} (${BASH_SOURCE[$i]:-unknown}:${BASH_LINENO[$i]:-0})"
        ((i++))
    done
}

# Performance optimization
cleanup_cache() {
    local current_time=$(date +%s)
    if ((current_time - LAST_CACHE_CLEANUP >= CACHE_CLEANUP_INTERVAL)); then
        debug_log "Performing cache cleanup"
        LOG_DEPTH_CACHE=()
        : > "$LOG_DEPTH_CACHE_FILE"
        LAST_CACHE_CLEANUP=$current_time
    fi
}

# Maintenance functions
ensure_state_directories() {
    local dirs=("$LOG_DIR" "$TMP_DIR")
    local success=true

    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            if ! mkdir -p "$dir" 2>/dev/null; then
                echo "Warning: Failed to create directory: $dir" >&2
                success=false
            fi
        fi
    done

    $success
}

init_state_files() {
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"
    [[ ! -f "$LOG_DEPTH_CACHE_FILE" ]] && touch "$LOG_DEPTH_CACHE_FILE"
    [[ ! -f "$LOG_DEBUG_FILE" ]] && touch "$LOG_DEBUG_FILE"
}

# Core functions
is_root_function() {
    local func_name="$1"
    case "$func_name" in
        main_rc) return 0 ;;
        *) return 1 ;;
    esac
}

get_base_depth() {
    local current_func="${FUNCNAME[1]:-main}"

    # Performance: Check cache first
    if [[ -n "${LOG_DEPTH_CACHE[$current_func]:-}" ]]; then
        debug_log "Cache hit for $current_func: ${LOG_DEPTH_CACHE[$current_func]}"
        echo "${LOG_DEPTH_CACHE[$current_func]}"
        return
    fi

    cleanup_cache

    local depth=0
    local i=1
    local prev_func=""
    local found_exec=false
    local stack_trace=""

    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        local func="${FUNCNAME[$i]}"

        [[ "$func" =~ ^(log|debug_log|get_base_depth|get_indent)$ ]] && { ((i++)); continue; }
        [[ "$func" == "execution_rc" ]] && found_exec=true
        [[ "$func" == "$prev_func" ]] && { ((i++)); continue; }

        if ! is_root_function "$func"; then
            ((depth++))
        elif [[ "$func" == "main_rc" ]]; then
            break
        fi

        stack_trace+="$func:"
        prev_func="$func"
        ((i++))
    done

    [[ "$found_exec" == "true" ]] && ((depth++))

    # Cache the result
    LOG_DEPTH_CACHE[$current_func]=$depth
    debug_log "Cached depth for $current_func: $depth (stack: $stack_trace)"

    echo "$depth"
}

calculate_final_depth() {
    get_base_depth
}

get_indent() {
    local depth="$1"
    local indent=""

    case $depth in
        0) indent="    " ;;
        1) indent="      " ;;
        *)
            indent="      "
            for ((i=2; i<=depth; i++)); do
                indent="  $indent"
            done
            ;;
    esac

    echo -n "$indent└─"
}

get_color() {
    local depth="$1"
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Main logging function
log() {
    [[ "$1" != "lvl" ]] && { echo "Error: Invalid log command" >&2; return 1; }
    local message="$2"
    local log_enabled
    log_enabled=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$log_enabled" != "true" ]] && return 0

    local depth
    depth=$(calculate_final_depth)
    local indent
    indent=$(get_indent "$depth")
    local color
    color=$(get_color "$depth")
    local timestamp
    timestamp=$(date '+%H:%M:%S')

    if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
        printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC" | tee -a "$LOG_FILE"
    else
        printf "%s%s %s [%s]%s\n" \
            "$color" \
            "$indent" \
            "$message" \
            "$timestamp" \
            "$LOG_NC" | tee -a "$LOG_FILE"
    fi

    [[ "${LOG_DEBUG_ENABLED}" == "1" ]] && {
        debug_log "Logged message at depth $depth: $message"
        dump_stack_trace
    }
}

# Logger control
setlog() {
    case "$1" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            printf "%sLogging disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            printf "%sLogging enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlog on|off\n"
            return 1
            ;;
    esac
}

# Initialization and cleanup
init_logger() {
    ensure_state_directories || {
        echo "Fatal: Failed to initialize logger directories" >&2
        return 1
    }
    init_state_files
    LOG_DEPTH_CACHE=()
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_CURRENT_PARENT=""
    LAST_CACHE_CLEANUP=$(date +%s)

    if [[ "${LOG_DEBUG_ENABLED}" == "1" ]]; then
        : > "$LOG_DEBUG_FILE"
        debug_log "Logger initialized"
        debug_log "Using LOG_DIR: $LOG_DIR"
        debug_log "Using TMP_DIR: $TMP_DIR"
    fi

    printf "Logger initialized at %s\n" "$(date)" > "$LOG_FILE"
}

cleanup_logger() {
    debug_log "Cleaning up logger state"
    LOG_DEPTH_CACHE=()
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_CURRENT_PARENT=""
    [[ -f "$LOG_DEPTH_CACHE_FILE" ]] && : > "$LOG_DEPTH_CACHE_FILE"
}

# Export functions and variables
export LOG_FILE LOG_STATE_FILE TMP_DIR
export -f log setlog init_logger cleanup_logger
export -f is_root_function get_base_depth calculate_final_depth
export -f get_indent get_color debug_log dump_stack_trace
export -A ROOT_FUNCTIONS

# Set up cleanup trap
trap cleanup_logger EXIT

# Initialize on source
init_logger
