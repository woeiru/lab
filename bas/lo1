#!/bin/bash

# Directory and file setup
LOG_DIR="${LOG_DIR:-/var/log/rc}"
TMP_DIR="${TMP_DIR:-/tmp}"

[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp"
[[ ! -d "$TMP_DIR" ]] && mkdir -p "$TMP_DIR" 2>/dev/null || TMP_DIR="/tmp"

LOG_FILE="${LOG_DIR}/rc_hierarchical.log"
LOG_STATE_FILE="${TMP_DIR}/rc_log_state"
LOG_DEBUG_ENABLED="${LOG_DEBUG:-0}"
LOG_DEBUG_FILE="${LOG_DIR}/rc_debug.log"

# Color definitions
readonly LOG_RED=$(printf '\033[0;31m')
readonly LOG_ORANGE=$(printf '\033[0;33m')
readonly LOG_YELLOW=$(printf '\033[1;33m')
readonly LOG_GREEN=$(printf '\033[0;32m')
readonly LOG_CYAN=$(printf '\033[0;36m')
readonly LOG_BLUE=$(printf '\033[0;34m')
readonly LOG_INDIGO=$(printf '\033[0;35m')
readonly LOG_VIOLET=$(printf '\033[1;35m')
readonly LOG_WHITE=$(printf '\033[1;37m')
readonly LOG_NC=$(printf '\033[0m')

# State tracking
declare -A LOG_DEPTH_CACHE
declare -A LOG_PARENTS
declare -A LOG_CHILDREN
declare -g LOG_CURRENT_PARENT=""

# Root function handling
declare -gA ROOT_FUNCTIONS=([main_rc]=1)

is_root_function() {
    local func_name="$1"
    case "$func_name" in
        main_rc) return 0 ;;
        *) return 1 ;;
    esac
}

# Core depth calculation
get_base_depth() {
    local current_func="${FUNCNAME[1]:-main}"
    local depth=0
    local i=1
    local prev_func=""
    local found_exec=false

    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        local func="${FUNCNAME[$i]}"

        [[ "$func" =~ ^(log|debug_log|get_base_depth|get_indent)$ ]] && { ((i++)); continue; }
        [[ "$func" == "execution_rc" ]] && found_exec=true
        [[ "$func" == "$prev_func" ]] && { ((i++)); continue; }

        if ! is_root_function "$func"; then
            ((depth++))
        elif [[ "$func" == "main_rc" ]]; then
            break
        fi

        prev_func="$func"
        ((i++))
    done

    [[ "$found_exec" == "true" ]] && ((depth++))
    echo "$depth"
}

# Pluggable final depth calculation
calculate_final_depth() {
    get_base_depth
}

get_indent() {
    local depth="$1"
    local indent=""

    case $depth in
        0) indent="    " ;;
        1) indent="      " ;;
        *)
            indent="      "
            for ((i=2; i<=depth; i++)); do
                indent="  $indent"
            done
            ;;
    esac

    echo -n "$indent└─"
}

get_color() {
    local depth="$1"
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Main logging function
log() {
    [[ "$1" != "lvl" ]] && { echo "Error: Invalid log command" >&2; return 1; }
    local message="$2"
    local log_enabled
    log_enabled=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$log_enabled" != "true" ]] && return 0

    local depth
    depth=$(calculate_final_depth)
    local indent
    indent=$(get_indent "$depth")
    local color
    color=$(get_color "$depth")
    local timestamp
    timestamp=$(date '+%H:%M:%S')

    if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
        printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC" | tee -a "$LOG_FILE"
    else
        printf "%s%s %s [%s]%s\n" \
            "$color" \
            "$indent" \
            "$message" \
            "$timestamp" \
            "$LOG_NC" | tee -a "$LOG_FILE"
    fi
}

# Logger control
setlog() {
    case "$1" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            printf "%sLogging disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            printf "%sLogging enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        *)
            printf "Usage: setlog on|off\n"
            return 1
            ;;
    esac
}

# Initialize logger
init_logger() {
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"
    LOG_DEPTH_CACHE=()
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_CURRENT_PARENT=""
    printf "Logger initialized at %s\n" "$(date)" > "$LOG_FILE"
}

cleanup_logger() {
    LOG_DEPTH_CACHE=()
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_CURRENT_PARENT=""
}

# Export functions and variables
export LOG_FILE LOG_STATE_FILE TMP_DIR
export -f log setlog init_logger cleanup_logger
export -f is_root_function get_base_depth calculate_final_depth
export -f get_indent get_color
export -A ROOT_FUNCTIONS

trap cleanup_logger EXIT

# Initialize on source
init_logger
