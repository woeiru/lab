#!/bin/bash

# ============================================================================
# Advanced Automatic Hierarchical Logger
# ============================================================================
# This module provides automatic hierarchical logging based on the call stack
# rather than message content. It handles:
# - Automatic level determination from call stack
# - Root function-based hierarchy reset
# - Context preservation across subshells
# - Performance optimization through caching
# - Clean state management

# Directory and file setup with fallback handling
LOG_DIR="/var/log/rc"
[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp"
LOG_FILE="${LOG_DIR}/rc_hierarchical.log"
LOG_STATE_FILE="${LOG_DIR}/rc_log_state"

# ============================================================================
# Color Management
# ============================================================================
# Define colors using printf to properly handle escape sequences
readonly LOG_RED=$(printf '\033[0;31m')      # Level 1
readonly LOG_ORANGE=$(printf '\033[0;33m')   # Level 2
readonly LOG_YELLOW=$(printf '\033[1;33m')   # Level 3
readonly LOG_GREEN=$(printf '\033[0;32m')    # Level 4
readonly LOG_CYAN=$(printf '\033[0;36m')     # Level 5
readonly LOG_BLUE=$(printf '\033[0;34m')     # Level 6
readonly LOG_INDIGO=$(printf '\033[0;35m')   # Level 7
readonly LOG_VIOLET=$(printf '\033[1;35m')   # Level 8
readonly LOG_WHITE=$(printf '\033[1;37m')    # Level 9+
readonly LOG_NC=$(printf '\033[0m')          # No Color

# ============================================================================
# Constants
# ============================================================================
readonly ROOT_LEVEL=1
readonly MAX_DEPTH=20
readonly MAX_TRACKING_ENTRIES=1000

# ============================================================================
# State Management
# ============================================================================

# These arrays handle the hierarchical state of the logger
declare -A LOG_ROOT_FUNCTIONS     # Registered root functions that reset hierarchy
declare -A LOG_DEPTH_CACHE       # Cache of calculated depths for performance
declare -A LOG_PARENT_CONTEXTS   # Track parent-child relationships
declare -a LOG_CONTEXT_STACK     # Stack of current execution context
declare -i LOG_CURRENT_DEPTH=0   # Current depth in the hierarchy

# Challenge: State persistence across subshells
# Solution: Use temporary files to maintain state across subshells
LOG_STATE_DIR="/tmp/logger_state_$$"
mkdir -p "$LOG_STATE_DIR"

# Cleanup function to remove temporary state
cleanup_logger_state() {
    rm -rf "$LOG_STATE_DIR"
    LOG_ROOT_FUNCTIONS=()
    LOG_DEPTH_CACHE=()
    LOG_PARENT_CONTEXTS=()
    LOG_CONTEXT_STACK=()
    LOG_CURRENT_DEPTH=0
}

# Ensure cleanup happens on script exit
trap cleanup_logger_state EXIT

# ============================================================================
# Root Function Management
# ============================================================================

# Challenge: Defining hierarchy reset points
# Solution: Maintain a registry of root functions that reset the hierarchy
register_root_function() {
    local func_name="$1"
    LOG_ROOT_FUNCTIONS["$func_name"]=1
    # Persist root function registration for subshells
    echo "$func_name" >> "$LOG_STATE_DIR/root_functions"
}

is_root_function() {
    local func_name="$1"
    [[ -n "${LOG_ROOT_FUNCTIONS[$func_name]:-}" ]]
}

# ============================================================================
# Context Management
# ============================================================================

# Challenge: Maintaining correct context across function calls
# Solution: Stack-based context tracking with file persistence
push_context() {
    local context="$1"
    LOG_CONTEXT_STACK+=("$context")
    # Persist context for subshells
    echo "${LOG_CONTEXT_STACK[*]}" > "$LOG_STATE_DIR/context_stack"
}

pop_context() {
    local stack_size=${#LOG_CONTEXT_STACK[@]}
    if ((stack_size > 0)); then
        unset 'LOG_CONTEXT_STACK[stack_size-1]'
        # Update persisted context
        echo "${LOG_CONTEXT_STACK[*]}" > "$LOG_STATE_DIR/context_stack"
    fi
}

# ============================================================================
# Call Stack Analysis
# ============================================================================

# Challenge: Accurate stack depth calculation
# Solution: Walk the call stack until we hit a root function or top
calculate_stack_depth() {
    local current_func="${FUNCNAME[1]:-main}"
    local depth=0

    # Check cache first for performance
    if [[ -n "${LOG_DEPTH_CACHE[$current_func]:-}" ]]; then
        echo "${LOG_DEPTH_CACHE[$current_func]}"
        return
    fi

    # Walk up the call stack
    local i=1
    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        local func="${FUNCNAME[$i]}"

        # Reset depth at root functions
        if is_root_function "$func"; then
            break
        fi

        ((depth++))
        ((i++))
    done

    # Cache the result for better performance
    LOG_DEPTH_CACHE[$current_func]=$depth
    echo "$depth"
}

# ============================================================================
# Formatting Helpers
# ============================================================================

# Get appropriate color for current depth
get_color() {
    local depth="$1"
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Calculate indentation based on depth
get_indent() {
    local depth="$1"
    local base_indent="    "  # Base indentation for root level

    case $depth in
        0)  echo -n "${base_indent}" ;;
        1)  echo -n "      " ;;
        *)  # For deeper levels, add two spaces per level
            local indent="      "
            for ((i=2; i<=depth; i++)); do
                indent="  $indent"
            done
            echo -n "$indent"
            ;;
    esac
    echo -n "└─"
}

# ============================================================================
# Main Logging Function
# ============================================================================

# The primary logging function that combines all functionality
log() {
    # Validate arguments
    if [[ "$1" != "lvl" ]]; then
        echo "Error: Invalid log command" >&2
        return 1
    fi
    local message="$2"

    # Check if logging is enabled
    local log_enabled
    log_enabled=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$log_enabled" != "true" ]] && return 0

    # Calculate depth based on call stack
    local depth
    depth=$(calculate_stack_depth)

    # Get formatting elements
    local indent
    indent=$(get_indent "$depth")
    local color
    color=$(get_color "$depth")
    local timestamp
    timestamp=$(date '+%H:%M:%S')

    # Format and output the message
    # Special handling for report headers
    if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
        printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC" | tee -a "$LOG_FILE"
    else
        printf "%s%s %s [%s]%s\n" \
            "$color" \
            "$indent" \
            "$message" \
            "$timestamp" \
            "$LOG_NC" | tee -a "$LOG_FILE"
    fi

    # Maintain context
    local current_func="${FUNCNAME[1]:-main}"
    if [[ -n "$current_func" && "$current_func" != "main" ]]; then
        push_context "$current_func"
    fi
}

# ============================================================================
# Utility Functions
# ============================================================================

# Toggle logging on/off
setlog() {
    case "$1" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            printf "%sLogging disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            printf "%sLogging enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        *)
            if [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                printf "%sLogging is currently disabled. Use 'setlog on' to enable first.%s\n" \
                    "$LOG_YELLOW" "$LOG_NC"
                return 1
            fi

            printf "%sInvalid input. Usage:%s\n" "$LOG_RED" "$LOG_NC"
            printf "   setlog on|off    - Enable or disable logging\n"
            return 1
            ;;
    esac
}

# Print current hierarchy (for debugging)
print_hierarchy() {
    printf "\n%sCurrent Logging Hierarchy:%s\n" "$LOG_BLUE" "$LOG_NC"
    printf "%s=========================%s\n" "$LOG_BLUE" "$LOG_NC"

    local i=0
    for context in "${LOG_CONTEXT_STACK[@]}"; do
        printf "%s%$(($i * 2))s%s%s\n" \
            "$(get_color $i)" \
            "" \
            "$context" \
            "$LOG_NC"
        ((i++))
    done

    printf "%s=========================%s\n\n" "$LOG_BLUE" "$LOG_NC"
}

# ============================================================================
# Initialize Logger
# ============================================================================

init_logger() {
    # Create required directories
    mkdir -p "$LOG_DIR"

    # Initialize log state file
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"

    # Clear any existing state
    cleanup_logger_state

    # Initialize new state directory
    mkdir -p "$LOG_STATE_DIR"

    # Create initial log entry
    printf "Logger initialized at %s\n" "$(date)" > "$LOG_FILE"
}

# ============================================================================
# Export Functions and Variables
# ============================================================================

export -f log
export -f setlog
export -f register_root_function
export -f print_hierarchy
export LOG_FILE
export LOG_STATE_FILE

# Initialize logger on source
init_logger
