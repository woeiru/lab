#!/bin/bash

# Directory and file setup
LOG_DIR="${LOG_DIR:-/var/log/rc}"
TMP_DIR="${TMP_DIR:-/tmp}"

[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/var/log/rc"
[[ ! -d "$TMP_DIR" ]] && mkdir -p "$TMP_DIR" 2>/dev/null || TMP_DIR="/tmp"

# Log files and state files
LOG_FILE="${LOG_DIR}/rc_hierarchical.log"
LOG_DEBUG_FILE="${LOG_DIR}/rc_debug.log"
LOG_STATE_FILE="${TMP_DIR}/rc_log_state"
LOG_DEPTH_CACHE_FILE="${TMP_DIR}/rc_depth_cache"
LOG_CONTEXT_FILE="${TMP_DIR}/rc_context"
LOG_TRACE_FILE="${TMP_DIR}/rc_trace"

# Configuration
LOG_DEBUG_ENABLED="${LOG_DEBUG:-0}"
LOG_CONTROL_DEPTH_ENABLED=true

# Color definitions
readonly LOG_RED=$(printf '\033[0;31m')
readonly LOG_ORANGE=$(printf '\033[0;33m')
readonly LOG_YELLOW=$(printf '\033[1;33m')
readonly LOG_GREEN=$(printf '\033[0;32m')
readonly LOG_CYAN=$(printf '\033[0;36m')
readonly LOG_BLUE=$(printf '\033[0;34m')
readonly LOG_INDIGO=$(printf '\033[0;35m')
readonly LOG_VIOLET=$(printf '\033[1;35m')
readonly LOG_WHITE=$(printf '\033[1;37m')
readonly LOG_NC=$(printf '\033[0m')

# State tracking
declare -A LOG_ROOT_FUNCTIONS
declare -A LOG_DEPTH_CACHE
declare -A LOG_PARENT_CONTEXTS
declare -A LOG_STACK_TRACES
declare -a LOG_CONTEXT_STACK
declare -i LOG_CURRENT_DEPTH=0
declare -i LAST_CACHE_CLEANUP=0

# Control structure tracking
declare -ga LOG_SOURCE_LINES=()
declare -gi CURRENT_LINE=0
declare -gA LOOP_START_LINES=()
declare -gA IF_START_LINES=()

ensure_state_directories() {
    local dirs=("$LOG_DIR" "$TMP_DIR")
    local success=true
    for dir in "${dirs[@]}"; do
        [[ ! -d "$dir" ]] && ! mkdir -p "$dir" 2>/dev/null && success=false
    done
    $success
}

init_state_files() {
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"
    [[ ! -f "$LOG_DEPTH_CACHE_FILE" ]] && touch "$LOG_DEPTH_CACHE_FILE"
    [[ ! -f "$LOG_CONTEXT_FILE" ]] && touch "$LOG_CONTEXT_FILE"
    [[ ! -f "$LOG_TRACE_FILE" ]] && touch "$LOG_TRACE_FILE"
}

debug_log() {
    [[ "${LOG_DEBUG_ENABLED}" != "1" ]] && return 0
    printf "[DEBUG] %s - %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$1" >> "$LOG_DEBUG_FILE"
}

dump_stack_trace() {
    local func="${1:-${FUNCNAME[1]}}"
    debug_log "Stack trace for $func:"
    local i=0
    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        debug_log "  $i: ${FUNCNAME[$i]:-main} (${BASH_SOURCE[$i]:-unknown}:${BASH_LINENO[$i]:-0})"
        ((i++))
    done
}

analyze_context() {
    local current_file="${BASH_SOURCE[2]}"
    local line_number="$1"
    local depth=0

    # Cache source file contents if not already cached
    if [[ ${#LOG_SOURCE_LINES[@]} -eq 0 && -f "$current_file" ]]; then
        mapfile -t LOG_SOURCE_LINES < "$current_file"
    fi

    # Look at lines before current line for control structures
    local i=$((line_number - 1))
    local loop_count=0
    local if_count=0

    while ((i >= 0)) && ((i < ${#LOG_SOURCE_LINES[@]})); do
        local line="${LOG_SOURCE_LINES[$i]}"

        # Check for loop structures
        if [[ "$line" =~ ^[[:space:]]*(for|while|until)[[:space:]] ]]; then
            ((loop_count++))
        elif [[ "$line" =~ ^[[:space:]]*done[[:space:]]*$ ]]; then
            ((loop_count--))
        fi

        # Check for if structures
        if [[ "$line" =~ ^[[:space:]]*if[[:space:]] ]]; then
            ((if_count++))
        elif [[ "$line" =~ ^[[:space:]]*fi[[:space:]]*$ ]]; then
            ((if_count--))
        fi

        ((i--))
    done

    echo $((loop_count + if_count))
}

cleanup_cache() {
    local current_time=$(date +%s)
    if ((current_time - LAST_CACHE_CLEANUP >= 300)); then
        LOG_DEPTH_CACHE=()
        : > "$LOG_DEPTH_CACHE_FILE"
        LAST_CACHE_CLEANUP=$current_time
    fi
}

calculate_stack_depth() {
    local current_func="${FUNCNAME[1]:-main}"
    local line_number="${BASH_LINENO[0]}"
    cleanup_cache

    # Function depth calculation
    local function_depth=0
    local i=1
    local prev_func=""
    local found_exec=false

    while [[ -n "${FUNCNAME[$i]:-}" ]]; do
        local func="${FUNCNAME[$i]}"
        [[ "$func" =~ ^(log|debug_log|calculate_stack_depth|get_indent|analyze_context)$ ]] && { ((i++)); continue; }
        [[ "$func" == "execution_rc" ]] && found_exec=true
        [[ "$func" == "$prev_func" ]] && { ((i++)); continue; }
        ! is_root_function "$func" && ((function_depth++))
        [[ "$func" == "main_rc" ]] && break
        prev_func="$func"
        ((i++))
    done

    [[ "$found_exec" == "true" ]] && ((function_depth++))

    # Control structure depth calculation
    local control_depth=0
    if [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]]; then
        control_depth=$(analyze_context "$line_number")
    fi

    echo $((function_depth + control_depth))
}

get_indent() {
    local depth="$1"
    local indent=""
    case $depth in
        0) indent="    " ;;
        1) indent="      " ;;
        *)
            indent="      "
            for ((i=2; i<=depth; i++)); do
                indent="  $indent"
            done
            ;;
    esac
    echo -n "$indent└─"
}

get_color() {
    case $1 in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

__log_debug_trap() {
    CURRENT_LINE=$1
    [[ "$LOG_CONTROL_DEPTH_ENABLED" == "true" ]] || return 0
}

log() {
    [[ "$1" != "lvl" ]] && { echo "Error: Invalid log command" >&2; return 1; }
    local message="$2"
    local log_enabled=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$log_enabled" != "true" ]] && return 0

    local depth=$(calculate_stack_depth)
    local indent=$(get_indent "$depth")
    local color=$(get_color "$depth")
    local timestamp=$(date '+%H:%M:%S')

    if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
        printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC" | tee -a "$LOG_FILE"
    else
        printf "%s%s %s [%s]%s\n" "$color" "$indent" "$message" "$timestamp" "$LOG_NC" | tee -a "$LOG_FILE"
    fi

    local current_func="${FUNCNAME[1]:-main}"
    [[ -n "$current_func" && "$current_func" != "main" ]] && push_context "$current_func"

    [[ "${LOG_DEBUG_ENABLED}" == "1" ]] && {
        debug_log "Logged message from $current_func (depth: $depth)"
        dump_stack_trace "$current_func"
    }
}

setlog() {
    case "$1" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            printf "%sLogging disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            printf "%sLogging enabled%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        *)
            [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]] && {
                printf "%sLogging is currently disabled. Use 'setlog on' to enable.%s\n" "$LOG_YELLOW" "$LOG_NC"
                return 1
            }
            printf "%sInvalid input. Usage: setlog on|off%s\n" "$LOG_RED" "$LOG_NC"
            return 1
            ;;
    esac
}

setlogcontrol() {
    case "$1" in
        "on")
            LOG_CONTROL_DEPTH_ENABLED=true
            trap '__log_debug_trap ${LINENO}' DEBUG
            printf "%sControl structure depth tracking enabled with automatic detection%s\n" "$LOG_GREEN" "$LOG_NC"
            ;;
        "off")
            LOG_CONTROL_DEPTH_ENABLED=false
            trap - DEBUG
            LOG_SOURCE_LINES=()
            CURRENT_LINE=0
            LOOP_START_LINES=()
            IF_START_LINES=()
            printf "%sControl structure depth tracking disabled%s\n" "$LOG_RED" "$LOG_NC"
            ;;
        *)
            printf "%sUsage: setlogcontrol on|off%s\n" "$LOG_YELLOW" "$LOG_NC"
            return 1
            ;;
    esac
}

push_context() {
    LOG_CONTEXT_STACK+=("$1")
    debug_log "Pushed context: $1"
}

pop_context() {
    local stack_size=${#LOG_CONTEXT_STACK[@]}
    if ((stack_size > 0)); then
        local popped="${LOG_CONTEXT_STACK[stack_size-1]}"
        unset 'LOG_CONTEXT_STACK[stack_size-1]'
        debug_log "Popped context: $popped"
    fi
}

print_hierarchy() {
    printf "\n%sCurrent Logging Hierarchy:%s\n" "$LOG_BLUE" "$LOG_NC"
    printf "%s=========================%s\n" "$LOG_BLUE" "$LOG_NC"
    local i=0
    for context in "${LOG_CONTEXT_STACK[@]}"; do
        printf "%s%$(($i * 2))s%s%s\n" "$(get_color $i)" "" "$context" "$LOG_NC"
        ((i++))
    done
    printf "%s=========================%s\n\n" "$LOG_BLUE" "$LOG_NC"
}

is_root_function() {
    local func_name="$1"
    debug_log "Checking if $func_name is root function"
    case "$func_name" in
        main_rc)
            debug_log "$func_name is the main root function"
            return 0
            ;;
        *)
            debug_log "$func_name is not a root function"
            return 1
            ;;
    esac
}

list_root_functions() {
    printf "Registered Root Functions:\n"
    for func in "${!ROOT_FUNCTIONS[@]}"; do
        printf "  - %s\n" "$func"
    done
}

init_logger() {
    ensure_state_directories || return 1
    init_state_files
    LOG_ROOT_FUNCTIONS=()
    LOG_DEPTH_CACHE=()
    LOG_PARENT_CONTEXTS=()
    LOG_STACK_TRACES=()
    LOG_CONTEXT_STACK=()
    LOG_CURRENT_DEPTH=0
    LAST_CACHE_CLEANUP=$(date +%s)
    LOG_SOURCE_LINES=()
    CURRENT_LINE=0
    LOOP_START_LINES=()
    IF_START_LINES=()

    [[ "${LOG_DEBUG_ENABLED}" == "1" ]] && {
        : > "$LOG_DEBUG_FILE"
        debug_log "Logger initialized"
        debug_log "Using LOG_DIR: $LOG_DIR"
        debug_log "Using TMP_DIR: $TMP_DIR"
    }

    printf "Logger initialized at %s\n" "$(date)" > "$LOG_FILE"
    printf "Using LOG_DIR: %s\n" "$LOG_DIR" >> "$LOG_FILE"
    printf "Using TMP_DIR: %s\n" "$TMP_DIR" >> "$LOG_FILE"
}

cleanup_logger() {
    debug_log "Cleaning up logger state"
    LOG_ROOT_FUNCTIONS=()
    LOG_DEPTH_CACHE=()
    LOG_PARENT_CONTEXTS=()
    LOG_STACK_TRACES=()
    LOG_CONTEXT_STACK=()
    LOG_CURRENT_DEPTH=0
    LOG_SOURCE_LINES=()
    CURRENT_LINE=0
    LOOP_START_LINES=()
    IF_START_LINES=()
    rm -f "$LOG_DEPTH_CACHE_FILE" "$LOG_CONTEXT_FILE" "$LOG_TRACE_FILE"
}

export -f log
export -f setlog
export -f setlogcontrol
export -f print_hierarchy
export LOG_FILE
export LOG_STATE_FILE
export TMP_DIR
export -f is_root_function
export -f list_root_functions
export -A ROOT_FUNCTIONS

trap cleanup_logger EXIT

init_logger
