#!/bin/bash

# Directory and file setup with fallback handling
LOG_DIR="/var/log/rc"
[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp"

# State and configuration files
LOG_STATE_FILE="${LOG_DIR}/rc_log_state"
LOG_LEVEL_FILE="${LOG_DIR}/rc_log_level"
ERROR_LOG="${LOG_DIR}/rc_error.log"

# Color definitions
readonly LOG_RED=$(printf '\033[0;31m')
readonly LOG_ORANGE=$(printf '\033[0;33m')
readonly LOG_YELLOW=$(printf '\033[1;33m')
readonly LOG_GREEN=$(printf '\033[0;32m')
readonly LOG_CYAN=$(printf '\033[0;36m')
readonly LOG_BLUE=$(printf '\033[0;34m')
readonly LOG_INDIGO=$(printf '\033[0;35m')
readonly LOG_VIOLET=$(printf '\033[1;35m')
readonly LOG_WHITE=$(printf '\033[1;37m')
readonly LOG_NC=$(printf '\033[0m')

# Constants
readonly ROOT_LEVEL=1
readonly ERROR_LEVEL=9
readonly MAX_TRACKING_ENTRIES=1000
readonly MAX_DEPTH=20

# Improved hierarchy tracking
declare -A LOG_PARENTS
declare -A LOG_CHILDREN
declare -A LOG_LEVELS
declare -g LOG_CURRENT_PARENT=""
declare -i LOG_TRACKING_COUNT=0
declare -i _LOG_DEPTH=0
declare -g _LOG_IN_PROGRESS=0
declare -g _LOG_LAST_MESSAGE=""
declare -a LOG_CONTEXT_STACK=()

# Stack management functions
push_context() {
    LOG_CONTEXT_STACK+=("$1")
    LOG_CURRENT_PARENT="$1"
}

pop_context() {
    local len=${#LOG_CONTEXT_STACK[@]}
    if ((len > 0)); then
        unset 'LOG_CONTEXT_STACK[len-1]'
        len=${#LOG_CONTEXT_STACK[@]}
        if ((len > 0)); then
            LOG_CURRENT_PARENT="${LOG_CONTEXT_STACK[len-1]}"
        else
            LOG_CURRENT_PARENT=""
        fi
    fi
}

# Enhanced component depth calculation
calculate_log_depth() {
    local component="${1:-}"
    [[ -z "$component" ]] && echo 0 && return

    echo "${LOG_LEVELS[$component]:-0}"
}

# Improved color selection based on depth
get_log_color() {
    local depth="${1:-0}"
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Fixed indentation generator with better depth handling
generate_log_indent() {
    local depth="${1:-0}"
    local depth_indent=""

    case "${depth}" in
        0)  depth_indent="    " ;;
        1)  depth_indent="      " ;;
        *)
            depth_indent="      "
            for ((i=2; i<="${depth}"; i++)); do
                depth_indent="  ${depth_indent}"
            done
            ;;
    esac

    printf "%s└─" "${depth_indent}"
}

# Enhanced relationship tracking
update_component_hierarchy() {
    local component="${1:-}"
    local parent="${2:-}"

    [[ -z "$component" || "$component" == "main" ]] && return

    # If no explicit parent is provided, use current context
    if [[ -z "$parent" || "$parent" == "main" ]]; then
        parent="$LOG_CURRENT_PARENT"
    fi

    # Check tracking limit
    if ((LOG_TRACKING_COUNT >= MAX_TRACKING_ENTRIES)); then
        return
    fi

    # Only update if relationship doesn't exist or parent has changed
    if [[ -n "$parent" && "$parent" != "main" ]]; then
        if [[ -z "${LOG_PARENTS[$component]:-}" || "${LOG_PARENTS[$component]}" != "$parent" ]]; then
            LOG_PARENTS[$component]="$parent"
            ((LOG_TRACKING_COUNT++))

            # Update children tracking
            if [[ -z "${LOG_CHILDREN[$parent]:-}" ]]; then
                LOG_CHILDREN[$parent]="$component"
            else
                # Check if component is not already in children list
                if [[ ! "${LOG_CHILDREN[$parent]}" =~ (^|:)${component}($|:) ]]; then
                    LOG_CHILDREN[$parent]="${LOG_CHILDREN[$parent]}:$component"
                fi
            fi

            # Calculate and store level
            local parent_level="${LOG_LEVELS[$parent]:-0}"
            LOG_LEVELS[$component]=$((parent_level + 1))
        fi
    else
        # Root level component
        LOG_LEVELS[$component]=0
        # Clear any existing parent relationship
        if [[ -n "${LOG_PARENTS[$component]:-}" ]]; then
            local old_parent="${LOG_PARENTS[$component]}"
            unset "LOG_PARENTS[$component]"
            # Remove from old parent's children
            if [[ -n "${LOG_CHILDREN[$old_parent]:-}" ]]; then
                LOG_CHILDREN[$old_parent]="${LOG_CHILDREN[$old_parent]//:$component/}"
                LOG_CHILDREN[$old_parent]="${LOG_CHILDREN[$old_parent]/$component:/}"
                LOG_CHILDREN[$old_parent]="${LOG_CHILDREN[$old_parent]/$component/}"
                [[ -z "${LOG_CHILDREN[$old_parent]}" ]] && unset "LOG_CHILDREN[$old_parent]"
            fi
        fi
    fi
}

# Improved logging function with context management
# Enhanced logging function with proper context management
log() {
    # Prevent recursive logging and deep nesting
    ((_LOG_IN_PROGRESS > 2 || _LOG_DEPTH > MAX_DEPTH)) && return 0
    ((_LOG_IN_PROGRESS++))
    ((_LOG_DEPTH++))

    # Ensure counters are decremented on return
    trap '((_LOG_IN_PROGRESS--)); ((_LOG_DEPTH--))' RETURN

    # Check logging state
    local state
    state=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$state" != "true" ]] && return 0

    # Get maximum logging level
    local max_level
    max_level=$(cat "$LOG_LEVEL_FILE" 2>/dev/null || echo "$ERROR_LEVEL")

    # Parse input parameters with context awareness
    local command="${1:-}"
    local message="${2:-}"
    local component="${3:-${FUNCNAME[1]:-unknown}}"
    local explicit_parent="${4:-}"

    # Validate command
    [[ "$command" != "lvl" ]] && return 1

    # Prevent duplicate consecutive messages
    [[ "$message" == "$_LOG_LAST_MESSAGE" ]] && return 0
    _LOG_LAST_MESSAGE="$message"

    # Context management based on message content
    if [[ "$message" =~ ^Starting|^Executing|^Processing|^Generating ]]; then
        # Push new context only if this is a "start" message
        update_component_hierarchy "$component" "$explicit_parent"
        push_context "$component"
    elif [[ "$message" =~ completed$|finished$|ended$|^Created|^Found|^Successfully ]]; then
        # Pop context if this is an "end" message, but log the message first
        local current_depth
        current_depth=$(calculate_log_depth "$component")

        if ((current_depth <= max_level)); then
            local color
            color=$(get_log_color "$current_depth")
            local indent
            indent=$(generate_log_indent "$current_depth")
            local timestamp
            timestamp=$(date '+%H:%M:%S')

            printf "%s%s %s [%s]%s\n" "$color" "$indent" "$message" "$timestamp" "$LOG_NC"
        fi

        pop_context
        return 0
    else
        # For other messages, maintain current context
        update_component_hierarchy "$component" "$LOG_CURRENT_PARENT"
    fi

    # Calculate depth and validate against maximum level
    local depth
    depth=$(calculate_log_depth "$component")

    if ((depth <= max_level)); then
        local color
        color=$(get_log_color "$depth")
        local indent
        indent=$(generate_log_indent "$depth")
        local timestamp
        timestamp=$(date '+%H:%M:%S')

        # Format and output the message with proper indentation
        if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
            printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC"
        elif ((depth == 0)); then
            printf "%s%s %s%s\n" "$color" "$indent" "$message" "$LOG_NC"
        else
            printf "%s%s %s [%s]%s\n" "$color" "$indent" "$message" "$timestamp" "$LOG_NC"
        fi
    fi
}

# Helper function to determine if a message indicates task completion
is_completion_message() {
    local message="$1"
    [[ "$message" =~ completed$|finished$|ended$|^Created|^Found|^Successfully ]]
}

# Print enhanced component tree
print_log_component_tree() {
    local component="${1:-}"
    [[ -z "$component" ]] && return

    local visited=()
    local depth
    depth=$(calculate_log_depth "$component")
    local color
    color=$(get_log_color "$depth")

    # Check for circular references
    for v in "${visited[@]}"; do
        [[ "$v" == "$component" ]] && return
    done
    visited+=("$component")

    local indent
    indent=$(generate_log_indent "$depth")
    printf "%s%s%s%s\n" "$indent" "$color" "$component" "$LOG_NC"

    if [[ -n "${LOG_CHILDREN[$component]:-}" ]]; then
        local IFS=':'
        read -ra children <<< "${LOG_CHILDREN[$component]}"
        for child in "${children[@]}"; do
            print_log_component_tree "$child"
        done
    fi
}

# Enhanced print report function
print_log_report() {
    local current_state
    current_state=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$current_state" != "true" ]] && return 0

    printf "\n"
    printf " %s━ Log Report%s\n" "$LOG_BLUE" "$LOG_NC"
    printf " %s━ Generated: %s%s%s\n" "$LOG_BLUE" "$LOG_CYAN" "$(date)" "$LOG_NC"
    printf "\n"

    local root_components=()
    for comp in "${!LOG_LEVELS[@]}"; do
        if [[ "${LOG_LEVELS[$comp]}" -eq 0 ]]; then
            root_components+=("$comp")
        fi
    done

    if ((${#root_components[@]} > 0)); then
        printf " %s━ Component Hierarchy:%s\n" "$LOG_BLUE" "$LOG_NC"
        printf "\n"

        IFS=$'\n'
        root_components=($(printf "%s\n" "${root_components[@]}" | sort))
        unset IFS

        for comp in "${root_components[@]}"; do
            print_log_component_tree "$comp"
        done
    else
        printf " %s━ No components to report%s\n" "$LOG_YELLOW" "$LOG_NC"
    fi

    printf "\n"
    printf " %s━ Log file: %s%s%s\n" "$LOG_BLUE" "$LOG_CYAN" "$ERROR_LOG" "$LOG_NC"
    printf "\n"
}

# Enhanced setlog function
setlog() {
    local arg="${1:-}"
    local color

    case "$arg" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            color=$LOG_RED
            printf " %s━ Logging has been disabled%s\n" "$color" "$LOG_NC"
            return 0
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            echo "$ERROR_LEVEL" > "$LOG_LEVEL_FILE"
            color=$LOG_GREEN
            printf " %s━ Logging has been enabled with maximum level%s\n" "$color" "$LOG_NC"
            return 0
            ;;
        *)
            if [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                color=$LOG_YELLOW
                printf " %s━ Logging is currently disabled. Use 'setlog on' to enable logging first.%s\n" "$color" "$LOG_NC"
                return 1
            fi

            if [[ $arg =~ ^[1-9]$ ]]; then
                echo "$arg" > "$LOG_LEVEL_FILE"
                color=$LOG_GREEN
                printf " %s━ Logging level set to %d%s\n" "$color" "$arg" "$LOG_NC"
                return 0
            else
                color=$LOG_RED
                printf " %s━ Invalid input. Usage:%s\n" "$color" "$LOG_NC"
                printf "    setlog on|off    - Enable or disable logging\n"
                printf "    setlog <number>  - Set maximum log level (1-9)\n"
                return 1
            fi
            ;;
    esac
}

# Enhanced cleanup function
cleanup_log() {
    _LOG_IN_PROGRESS=0
    _LOG_DEPTH=0
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_LEVELS=()
    LOG_CURRENT_PARENT=""
    LOG_TRACKING_COUNT=0
    _LOG_LAST_MESSAGE=""
    LOG_CONTEXT_STACK=()
}

# Initialize log files with error checking
{
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"
    [[ ! -f "$LOG_LEVEL_FILE" ]] && echo "$ERROR_LEVEL" > "$LOG_LEVEL_FILE"
} 2>/dev/null

# Export functions and variables
export -f log
export -f setlog
export -f calculate_log_depth
export -f print_log_component_tree
export -f print_log_report
export -f push_context
export -f pop_context
export LOG_STATE_FILE
export LOG_LEVEL_FILE
export ERROR_LOG
export -A LOG_PARENTS
export -A LOG_CHILDREN
export -A LOG_LEVELS
export LOG_CURRENT_PARENT
export -a LOG_CONTEXT_STACK

# Set up cleanup trap
trap cleanup_log EXIT INT TERM
