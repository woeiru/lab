#!/bin/bash

# Define log directory
LOG_DIR="/var/log/rc"
[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp"

# Store log state and levels in persistent files with proper paths
LOG_STATE_FILE="${LOG_DIR}/rc_log_state"
LOG_LEVELS_FILE="${LOG_DIR}/rc_log_levels"
ERROR_LOG="${LOG_DIR}/rc_error.log"

# Initialize log state if file doesn't exist
if [[ ! -f "$LOG_STATE_FILE" ]]; then
    echo "true" > "$LOG_STATE_FILE" 2>/dev/null || {
        # Fallback to temp directory if can't write to LOG_DIR
        LOG_DIR="/tmp"
        LOG_STATE_FILE="${LOG_DIR}/rc_log_state"
        LOG_LEVELS_FILE="${LOG_DIR}/rc_log_levels"
        ERROR_LOG="${LOG_DIR}/rc_error.log"
        echo "true" > "$LOG_STATE_FILE"
    }
fi

# Initialize log levels if file doesn't exist (now including level 9 for errors)
if [[ ! -f "$LOG_LEVELS_FILE" ]]; then
    echo "1 1 1 1 1 1 1 1 1" > "$LOG_LEVELS_FILE"
fi

# Read the current log state and levels
LOG_TOGGLE=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
read -r -a LOG_LEVELS <<< "$(cat "$LOG_LEVELS_FILE" 2>/dev/null || echo "1 1 1 1 1 1 1 1 1")"

# Color codes
RED='\033[0;31m'
ORANGE='\033[0;33m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
INDIGO='\033[0;35m'
VIOLET='\033[1;35m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Modified logging function that hides the level in output
log() {
    # First check LOG_TOGGLE from the state file
    local current_state
    current_state=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "${current_state}" != "true" ]] && return 0

    # Read current levels
    local -a current_levels
    read -r -a current_levels <<< "$(cat "$LOG_LEVELS_FILE" 2>/dev/null || echo "1 1 1 1 1 1 1 1 1")"

    local level=$1
    local message=$2
    local level_num=${level#lvl-}
    local indent=""
    local color=""

    # Set color based on level
    case $level in
        "lvl-1") color=$RED ;;
        "lvl-2") color=$ORANGE ;;
        "lvl-3") color=$YELLOW ;;
        "lvl-4") color=$GREEN ;;
        "lvl-5") color=$CYAN ;;
        "lvl-6") color=$BLUE ;;
        "lvl-7") color=$INDIGO ;;
        "lvl-8") color=$VIOLET ;;
        "lvl-9") color=$WHITE ;; # Error level
        *) color=$NC ;;
    esac

    # Create indentation and colored indicator
    if [ $level_num -eq 1 ]; then
        indent="${color}    └─${NC}"
    elif [ $level_num -eq 9 ]; then
        indent="                  ${color}█─${NC}" # Thick line for errors
    else
        indent="      ${color}└─${NC}"
        for ((i=3; i<=$level_num; i++)); do
            indent="  $indent"
        done
    fi

    # Format the log message
    local formatted_message
    if [ $level_num -eq 9 ]; then
        formatted_message="$(date '+%Y%m%d%H%M%S') - $message"
        echo -e "${indent}$formatted_message" | tee -a "$ERROR_LOG" >&2
    else
        if [[ ${current_levels[$((level_num-1))]} -eq 1 ]]; then
            if [ $level_num -eq 1 ]; then
                echo -e "${indent}$message" >&2
            else
                echo -e "${indent}$message"
            fi
        fi
    fi
}

# Function to set up logging with persistent state and levels
setlog() {
    local arg=$1

    case "$arg" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            export LOG_TOGGLE="false"
            log "lvl-1" "Logging has been disabled"
            return 0
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            export LOG_TOGGLE="true"
            echo "1 1 1 1 1 1 1 1 1" > "$LOG_LEVELS_FILE"
            read -r -a LOG_LEVELS <<< "$(cat "$LOG_LEVELS_FILE")"
            export LOG_LEVELS
            log "lvl-1" "Logging has been enabled with all levels active"
            return 0
            ;;
        *)
            if [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                log "lvl-1" "Logging is currently disabled. Use 'setlog on' to enable logging first."
                return 1
            fi

            local range=$arg
            local start end
            if [[ $range =~ ^([1-9])-([1-9])$ ]]; then
                start=${BASH_REMATCH[1]}
                end=${BASH_REMATCH[2]}

                if [[ $start -gt $end ]]; then
                    log "lvl-1" "Invalid range: start ($start) cannot be greater than end ($end)"
                    return 1
                fi
            else
                echo "└─Invalid input. Usage:"
                echo "   setlog on|off            - Enable or disable logging"
                echo "   setlog <start>-<end>     - Set logging levels (e.g., '1-3' or '2-5')"
                return 1
            fi

            local -a new_levels=(0 0 0 0 0 0 0 0 0)

            for ((i=start-1; i<=end-1; i++)); do
                new_levels[$i]=1
            done

            printf '%s\n' "${new_levels[*]}" > "$LOG_LEVELS_FILE"
            LOG_LEVELS=("${new_levels[@]}")
            export LOG_LEVELS

            log "lvl-1" "Logging levels updated to: ${new_levels[*]}"
            ;;
    esac
}

# Export functions and variables
export -f log
export -f setlog
export LOG_LEVELS
export LOG_TOGGLE
export LOG_STATE_FILE
export LOG_LEVELS_FILE
export ERROR_LOG
