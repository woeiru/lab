#!/bin/bash

# Directory and file setup with fallback handling
LOG_DIR="/var/log/rc"
[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp"

# State and configuration files
LOG_STATE_FILE="${LOG_DIR}/rc_log_state"
LOG_LEVEL_FILE="${LOG_DIR}/rc_log_level"
ERROR_LOG="${LOG_DIR}/rc_error.log"

# Color definitions using printf for proper escape sequence handling
# Using the same technique as tme module
readonly LOG_RED=$(printf '\033[0;31m')
readonly LOG_ORANGE=$(printf '\033[0;33m')
readonly LOG_YELLOW=$(printf '\033[1;33m')
readonly LOG_GREEN=$(printf '\033[0;32m')
readonly LOG_CYAN=$(printf '\033[0;36m')
readonly LOG_BLUE=$(printf '\033[0;34m')
readonly LOG_INDIGO=$(printf '\033[0;35m')
readonly LOG_VIOLET=$(printf '\033[1;35m')
readonly LOG_WHITE=$(printf '\033[1;37m')
readonly LOG_NC=$(printf '\033[0m')

# Constants
readonly ROOT_LEVEL=1
readonly ERROR_LEVEL=9
readonly MAX_TRACKING_ENTRIES=1000
readonly MAX_DEPTH=20

# Call hierarchy tracking with recursion protection
declare -A LOG_PARENTS
declare -A LOG_CHILDREN
declare -g LOG_CURRENT_PARENT=""
declare -i LOG_TRACKING_COUNT=0
declare -i _LOG_DEPTH=0
declare -g _LOG_IN_PROGRESS=0
declare -g _LOG_LAST_MESSAGE=""

# Calculate component depth based on call hierarchy
calculate_log_depth() {
    local component="$1"
    local depth=0
    local current="$component"
    local visited=()

    while [[ -n "${LOG_PARENTS[$current]}" ]]; do
        # Check for circular references
        for v in "${visited[@]}"; do
            [[ "$v" == "$current" ]] && return $depth
        done
        visited+=("$current")

        ((depth++))
        current="${LOG_PARENTS[$current]}"
        # Prevent infinite loops in hierarchy calculation
        ((depth > MAX_DEPTH)) && break
    done

    echo "$depth"
}

# Get color based on depth level - simplified like tme module
get_log_color() {
    local depth=$1
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Generate proper indentation with tree symbols - aligned with tme module
generate_log_indent() {
    local depth=$1
    local depth_indent=""

    if [ $depth -eq 0 ]; then
        depth_indent="    "
    elif [ $depth -eq 1 ]; then
        depth_indent="      "
    else
        depth_indent="      "
        for ((i=2; i<=$depth; i++)); do
            depth_indent="  $depth_indent"
        done
    fi

    echo -n "${depth_indent}└─"
}

# Enhanced logging function with recursion protection
log() {
    # Prevent recursive logging and deep nesting
    ((_LOG_IN_PROGRESS > 2 || _LOG_DEPTH > MAX_DEPTH)) && return 0
    let _LOG_IN_PROGRESS+=1
    let _LOG_DEPTH+=1

    # Ensure counters are decremented on return
    trap 'let _LOG_IN_PROGRESS-=1; let _LOG_DEPTH-=1' RETURN

    # Check logging state
    local state
    state=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$state" != "true" ]] && return 0

    # Get maximum logging level
    local max_level
    max_level=$(cat "$LOG_LEVEL_FILE" 2>/dev/null || echo "$ERROR_LEVEL")

    # Parse input parameters
    local command="$1"
    local message="$2"
    local component="${3:-${FUNCNAME[1]}}"
    local parent="${FUNCNAME[2]}"

    # Validate command
    [[ "$command" != "lvl" ]] && return 1

    # Prevent duplicate consecutive messages
    if [[ "$message" == "$_LOG_LAST_MESSAGE" ]]; then
        return 0
    fi
    _LOG_LAST_MESSAGE="$message"

    # Update call hierarchy with protection
    if [[ -n "$component" && "$component" != "main" && -n "$parent" && "$parent" != "main" ]]; then
        if [[ -z "${LOG_PARENTS[$component]}" ]]; then
            # Check tracking limit
            if ((LOG_TRACKING_COUNT >= MAX_TRACKING_ENTRIES)); then
                return 0
            fi

            LOG_PARENTS[$component]="$parent"
            ((LOG_TRACKING_COUNT++))

            if [[ -z "${LOG_CHILDREN[$parent]}" ]]; then
                LOG_CHILDREN[$parent]="$component"
            else
                LOG_CHILDREN[$parent]="${LOG_CHILDREN[$parent]}:$component"
            fi
        fi
    fi

    # Calculate depth and check against maximum level
    local depth
    depth=$(calculate_log_depth "$component")

    if ((depth <= max_level)); then
        local color
        color=$(get_log_color "$depth")
        local indent
        indent=$(generate_log_indent "$depth")
        local timestamp=$(date '+%H:%M:%S')

        # Format and output the message with enhanced color handling - aligned with tme module
        if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
            printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC"
        elif ((depth == 0)); then
            printf "%s%s %s%s\n" "$color" "$indent" "$message" "$LOG_NC"
        else
            printf "%s%s %s [%s]%s\n" "$color" "$indent" "$message" "$timestamp" "$LOG_NC"
        fi
    fi
}

# Enhanced setlog function with validation
setlog() {
    local arg=$1
    local color

    case "$arg" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            color=$LOG_RED
            printf " %s━ Logging has been disabled%s\n" "$color" "$LOG_NC"
            return 0
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            echo "$ERROR_LEVEL" > "$LOG_LEVEL_FILE"
            color=$LOG_GREEN
            printf " %s━ Logging has been enabled with maximum level%s\n" "$color" "$LOG_NC"
            return 0
            ;;
        *)
            if [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                color=$LOG_YELLOW
                printf " %s━ Logging is currently disabled. Use 'setlog on' to enable logging first.%s\n" "$color" "$LOG_NC"
                return 1
            fi

            if [[ $arg =~ ^[1-9]$ ]]; then
                echo "$arg" > "$LOG_LEVEL_FILE"
                color=$LOG_GREEN
                printf " %s━ Logging level set to %d%s\n" "$color" "$arg" "$LOG_NC"
                return 0
            else
                color=$LOG_RED
                printf " %s━ Invalid input. Usage:%s\n" "$color" "$LOG_NC"
                printf "    setlog on|off    - Enable or disable logging\n"
                printf "    setlog <number>  - Set maximum log level (1-9)\n"
                return 1
            fi
            ;;
    esac
}

# Print component tree recursively - aligned with tme module style
print_log_component_tree() {
    local component="$1"
    local visited=()
    local depth=$(calculate_log_depth "$component")
    local color=$(get_log_color "$depth")

    # Check for circular references
    for v in "${visited[@]}"; do
        [[ "$v" == "$component" ]] && return
    done
    visited+=("$component")

    local indent=$(generate_log_indent "$depth")
    printf "%s%s%s%s\n" "$indent" "$color" "$component" "$LOG_NC"

    if [[ -n "${LOG_CHILDREN[$component]}" ]]; then
        local IFS=':'
        local children=(${LOG_CHILDREN[$component]})
        for child in "${children[@]}"; do
            print_log_component_tree "$child"
        done
    fi
}

# Print log report with hierarchy - aligned with tme module style
print_log_report() {
    local current_state
    current_state=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$current_state" != "true" ]] && return 0

    printf "\n"
    printf " %s━ Log Report%s\n" "$LOG_BLUE" "$LOG_NC"
    printf " %s━ Generated: %s%s%s\n" "$LOG_BLUE" "$LOG_CYAN" "$(date)" "$LOG_NC"
    printf "\n"

    # Process and print component tree
    local root_components=()
    for comp in "${!LOG_PARENTS[@]}"; do
        if [[ -z "${LOG_PARENTS[$comp]}" ]]; then
            root_components+=("$comp")
        fi
    done

    # Sort root components if needed
    if ((${#root_components[@]} > 0)); then
        IFS=$'\n'
        root_components=($(printf "%s\n" "${root_components[@]}" | sort))
        unset IFS

        for comp in "${root_components[@]}"; do
            print_log_component_tree "$comp"
        done
    else
        printf " %s━ No components to report%s\n" "$LOG_YELLOW" "$LOG_NC"
    fi

    printf "\n"
    printf " %s━ Log file: %s%s%s\n" "$LOG_BLUE" "$LOG_CYAN" "$ERROR_LOG" "$LOG_NC"
    printf "\n"
}

# Cleanup function
cleanup_log() {
    _LOG_IN_PROGRESS=0
    _LOG_DEPTH=0
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_CURRENT_PARENT=""
    LOG_TRACKING_COUNT=0
    _LOG_LAST_MESSAGE=""
}

# Initialize log files with error checking
{
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"
    [[ ! -f "$LOG_LEVEL_FILE" ]] && echo "$ERROR_LEVEL" > "$LOG_LEVEL_FILE"
} 2>/dev/null

# Export functions and variables
export -f log
export -f setlog
export -f calculate_log_depth
export -f print_log_report
export LOG_STATE_FILE
export LOG_LEVEL_FILE
export ERROR_LOG
export -A LOG_PARENTS
export -A LOG_CHILDREN
export LOG_CURRENT_PARENT

# Set up cleanup trap
trap cleanup_log EXIT INT TERM
