#!/bin/bash

# Directory and file setup with fallback handling
LOG_DIR="/var/log/rc"
[[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR" 2>/dev/null || LOG_DIR="/tmp"

# State and configuration files
LOG_STATE_FILE="${LOG_DIR}/rc_log_state"
LOG_LEVEL_FILE="${LOG_DIR}/rc_log_level"
ERROR_LOG="${LOG_DIR}/rc_error.log"

# Color definitions
readonly LOG_RED=$(printf '\033[0;31m')
readonly LOG_ORANGE=$(printf '\033[0;33m')
readonly LOG_YELLOW=$(printf '\033[1;33m')
readonly LOG_GREEN=$(printf '\033[0;32m')
readonly LOG_CYAN=$(printf '\033[0;36m')
readonly LOG_BLUE=$(printf '\033[0;34m')
readonly LOG_INDIGO=$(printf '\033[0;35m')
readonly LOG_VIOLET=$(printf '\033[1;35m')
readonly LOG_WHITE=$(printf '\033[1;37m')
readonly LOG_NC=$(printf '\033[0m')

# Constants
readonly ROOT_LEVEL=1
readonly ERROR_LEVEL=9
readonly MAX_TRACKING_ENTRIES=1000
readonly MAX_DEPTH=20

# Improved hierarchy tracking
declare -A LOG_PARENTS
declare -A LOG_CHILDREN
declare -A LOG_LEVELS
declare -g LOG_CURRENT_PARENT=""
declare -i LOG_TRACKING_COUNT=0
declare -i _LOG_DEPTH=0
declare -g _LOG_IN_PROGRESS=0
declare -g _LOG_LAST_MESSAGE=""

# Enhanced component depth calculation
calculate_log_depth() {
    local component="${1:-}"
    [[ -z "$component" ]] && echo 0 && return

    local depth=0
    local current="$component"
    local visited=()

    while [[ -n "${LOG_PARENTS[$current]:-}" ]]; do
        # Check for circular references
        for v in "${visited[@]}"; do
            [[ "$v" == "$current" ]] && echo "$depth" && return
        done
        visited+=("$current")

        ((depth++))
        current="${LOG_PARENTS[$current]}"
        [[ $depth -gt $MAX_DEPTH ]] && break
    done

    echo "$depth"
}

# Improved color selection based on depth
get_log_color() {
    local depth="${1:-0}"
    case $depth in
        0) echo -n "$LOG_RED" ;;
        1) echo -n "$LOG_ORANGE" ;;
        2) echo -n "$LOG_YELLOW" ;;
        3) echo -n "$LOG_GREEN" ;;
        4) echo -n "$LOG_CYAN" ;;
        5) echo -n "$LOG_BLUE" ;;
        6) echo -n "$LOG_INDIGO" ;;
        7) echo -n "$LOG_VIOLET" ;;
        *) echo -n "$LOG_WHITE" ;;
    esac
}

# Fixed indentation generator
generate_log_indent() {
    local depth="${1:-0}"
    local depth_indent=""

    case "${depth}" in
        0)  depth_indent="    " ;;
        1)  depth_indent="      " ;;
        *)
            depth_indent="      "
            for ((i=2; i<="${depth}"; i++)); do
                depth_indent="  ${depth_indent}"
            done
            ;;
    esac

    printf "%s└─" "${depth_indent}"
}

# Enhanced relationship tracking
update_component_hierarchy() {
    local component="${1:-}"
    local parent="${2:-}"

    [[ -z "$component" || "$component" == "main" ]] && return
    [[ -z "$parent" || "$parent" == "main" ]] && return

    # Check tracking limit
    if ((LOG_TRACKING_COUNT >= MAX_TRACKING_ENTRIES)); then
        return
    fi

    # Only update if relationship doesn't exist
    if [[ -z "${LOG_PARENTS[$component]:-}" ]]; then
        LOG_PARENTS[$component]="$parent"
        ((LOG_TRACKING_COUNT++))

        # Update children tracking
        if [[ -z "${LOG_CHILDREN[$parent]:-}" ]]; then
            LOG_CHILDREN[$parent]="$component"
        else
            LOG_CHILDREN[$parent]="${LOG_CHILDREN[$parent]}:$component"
        fi
    fi
}

# Improved logging function with better state management
log() {
    # Prevent recursive logging and deep nesting
    ((_LOG_IN_PROGRESS > 2 || _LOG_DEPTH > MAX_DEPTH)) && return 0
    ((_LOG_IN_PROGRESS++))
    ((_LOG_DEPTH++))

    # Ensure counters are decremented on return
    trap '((_LOG_IN_PROGRESS--)); ((_LOG_DEPTH--))' RETURN

    # Check logging state
    local state
    state=$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "true")
    [[ "$state" != "true" ]] && return 0

    # Get maximum logging level
    local max_level
    max_level=$(cat "$LOG_LEVEL_FILE" 2>/dev/null || echo "$ERROR_LEVEL")

    # Parse input parameters
    local command="${1:-}"
    local message="${2:-}"
    local component="${3:-${FUNCNAME[1]:-unknown}}"
    local parent="${FUNCNAME[2]:-}"

    # Validate command
    [[ "$command" != "lvl" ]] && return 1

    # Prevent duplicate consecutive messages
    [[ "$message" == "$_LOG_LAST_MESSAGE" ]] && return 0
    _LOG_LAST_MESSAGE="$message"

    # Update hierarchy
    update_component_hierarchy "$component" "$parent"

    # Calculate depth and validate against maximum level
    local depth
    depth=$(calculate_log_depth "$component")

    if ((depth <= max_level)); then
        local color
        color=$(get_log_color "$depth")
        local indent
        indent=$(generate_log_indent "$depth")
        local timestamp
        timestamp=$(date '+%H:%M:%S')

        # Format and output the message
        if [[ "$message" == *"Report"* || "$message" == *"initialization"* ]]; then
            printf " %s━ %s%s\n" "$color" "$message" "$LOG_NC"
        elif ((depth == 0)); then
            printf "%s%s %s%s\n" "$color" "$indent" "$message" "$LOG_NC"
        else
            printf "%s%s %s [%s]%s\n" "$color" "$indent" "$message" "$timestamp" "$LOG_NC"
        fi
    fi
}

# Enhanced component tree printing
print_log_component_tree() {
    local component="${1:-}"
    [[ -z "$component" ]] && return

    local visited=()
    local depth
    depth=$(calculate_log_depth "$component")
    local color
    color=$(get_log_color "$depth")

    # Check for circular references
    for v in "${visited[@]}"; do
        [[ "$v" == "$component" ]] && return
    done
    visited+=("$component")

    local indent
    indent=$(generate_log_indent "$depth")
    printf "%s%s%s%s\n" "$indent" "$color" "$component" "$LOG_NC"

    if [[ -n "${LOG_CHILDREN[$component]:-}" ]]; then
        local IFS=':'
        read -ra children <<< "${LOG_CHILDREN[$component]}"
        for child in "${children[@]}"; do
            print_log_component_tree "$child"
        done
    fi
}

# Rest of the functions remain largely the same but with improved error handling...
setlog() {
    local arg="${1:-}"
    local color

    case "$arg" in
        "off")
            echo "false" > "$LOG_STATE_FILE"
            color=$LOG_RED
            printf " %s━ Logging has been disabled%s\n" "$color" "$LOG_NC"
            return 0
            ;;
        "on")
            echo "true" > "$LOG_STATE_FILE"
            echo "$ERROR_LEVEL" > "$LOG_LEVEL_FILE"
            color=$LOG_GREEN
            printf " %s━ Logging has been enabled with maximum level%s\n" "$color" "$LOG_NC"
            return 0
            ;;
        *)
            if [[ "$(cat "$LOG_STATE_FILE" 2>/dev/null || echo "false")" != "true" ]]; then
                color=$LOG_YELLOW
                printf " %s━ Logging is currently disabled. Use 'setlog on' to enable logging first.%s\n" "$color" "$LOG_NC"
                return 1
            fi

            if [[ $arg =~ ^[1-9]$ ]]; then
                echo "$arg" > "$LOG_LEVEL_FILE"
                color=$LOG_GREEN
                printf " %s━ Logging level set to %d%s\n" "$color" "$arg" "$LOG_NC"
                return 0
            else
                color=$LOG_RED
                printf " %s━ Invalid input. Usage:%s\n" "$color" "$LOG_NC"
                printf "    setlog on|off    - Enable or disable logging\n"
                printf "    setlog <number>  - Set maximum log level (1-9)\n"
                return 1
            fi
            ;;
    esac
}

# Cleanup function with proper reset
cleanup_log() {
    _LOG_IN_PROGRESS=0
    _LOG_DEPTH=0
    LOG_PARENTS=()
    LOG_CHILDREN=()
    LOG_LEVELS=()
    LOG_CURRENT_PARENT=""
    LOG_TRACKING_COUNT=0
    _LOG_LAST_MESSAGE=""
}

# Initialize log files with error checking
{
    [[ ! -f "$LOG_STATE_FILE" ]] && echo "true" > "$LOG_STATE_FILE"
    [[ ! -f "$LOG_LEVEL_FILE" ]] && echo "$ERROR_LEVEL" > "$LOG_LEVEL_FILE"
} 2>/dev/null

# Export functions and variables
export -f log
export -f setlog
export -f calculate_log_depth
export -f print_log_component_tree
export -f print_log_report
export LOG_STATE_FILE
export LOG_LEVEL_FILE
export ERROR_LOG
export -A LOG_PARENTS
export -A LOG_CHILDREN
export -A LOG_LEVELS

# Set up cleanup trap
trap cleanup_log EXIT INT TERM
