#!/bin/bash
#######################################################################
# System Initialization Controller
#######################################################################
# Purpose:
#   Core system initialization script that manages the bootstrapping and
#   configuration of the entire environment through a modular, dependency-
#   aware approach.
#
# Architecture:
#   - Core Components:
#     * Verification Module (ver): Validates system state and dependencies
#     * Runtime Constants (ric): System-wide configuration constants
#     * Module Dependencies (mdc): Module relationship definitions
#     * Runtime Dependencies (rdc): Runtime environment requirements
#     * Component Orchestrator (comp): Manages setup of additional system components
#
# Initialization Flow:
#   1. Module System Initialization:
#      - Validates core dependencies
#      - Sets up required directories
#      - Loads and verifies essential modules (err, lo1, tme)
#
#   2. Core System Configuration & Runtime Initialization:
#      - Sources the Component Orchestrator (bin/core/comp)
#      - Initializes core runtime system (processes configurations, loads dependencies)
#      - Registers and validates system functions
#
#   3. Additional Component Setup:
#      - Utilizes the Component Orchestrator to set up further system components
#
# Error Handling:
#   - Comprehensive error logging via debug_log
#   - Fallback to minimal environment on failure
#   - Verification at each critical step
#
# Dependencies:
#   Required files in cfg/core/:
#   - ric (Runtime initialization constants)
#   - rdc (Runtime dependency constants)
#   - mdc (Module dependency constants)
#   Required modules in lib/core/:
#   - ver (Verification functions)
#   Required scripts in bin/core/:
#   - comp (Component orchestrator)
#
#######################################################################

# Set the base directory path
readonly DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
readonly BASE_DIR="$( cd "$DIR/.." &> /dev/null && pwd )"

# Debug logging function to use before we load the full system
# Now always logs to file and stderr (no verbosity control)
debug_log() {
    local timestamp=$(date '+%H:%M:%S')
    local message="$1"
    local source="${2:-${FUNCNAME[1]:-main}}"
    local LOG_DEBUG_FILE="${BASE_DIR}/.log/debug.log"
    
    # Always log to file
    mkdir -p "$(dirname "$LOG_DEBUG_FILE")" 2>/dev/null
    echo "[DEBUG] $timestamp - [$source] $message" >> "$LOG_DEBUG_FILE"
    # Always output to stderr
    echo "└─ $message [$timestamp]" >&2
}

# Initialization System
# Dependencies: Relies on verification module (ver), runtime and module dependency constants (rdc, mdc)
# Purpose: Manages system initialization in two phases:
#   1. Module dependency initialization (working with mdc)
#   2. Runtime dependency initialization (working with rdc)

# Source runtime initialization constants
source "${BASE_DIR}/cfg/core/ric" || {
    echo "Failed to source runtime constants" >&2
    exit 1
}

# Source runtime dependency constants
source "${BASE_DIR}/cfg/core/rdc" || {
    echo "Failed to source dependency constants" >&2
    exit 1
}

# Source module dependency constants
source "${BASE_DIR}/cfg/core/mdc" || {
    echo "Failed to source dependency constants" >&2
    exit 1
}

# Source verification module
source "${BASE_DIR}/lib/core/ver" || {
    echo "Failed to source verification module" >&2
    exit 1
}

###############################################
# Core initialization orchestrator
# Dependencies:
#   - ver (lib/core/ver) for all verification functions
###############################################
main_ini() {
    local main_op_timer_started=0 # New: Flag to track if MAIN_OPERATIONS timer started

    # Ensure log directory exists and clear logs for the new cycle
    # LOG_DIR, LOG_DEBUG_FILE, and ERROR_LOG are sourced from cfg/core/ric
    if [ -n "$LOG_DIR" ] && [ -n "$LOG_DEBUG_FILE" ] && [ -n "$ERROR_LOG" ]; then
        mkdir -p "$LOG_DIR" 2>/dev/null
        > "$LOG_DEBUG_FILE" # Clear/create debug log
        > "$ERROR_LOG"     # Clear/create error log
    else
        # This case should ideally not be reached if ric is sourced correctly
        echo "Critical Error: Log directory or log file variables not set. Cannot clear logs." >&2
    fi

    debug_log "Starting main initialization"

    # Verify that verification module is loaded
    if ! type verify_module &>/dev/null || ! type verify_path &>/dev/null; then
        echo "ERROR: Verification module not properly loaded" >&2
        return 1
    fi

    # Part 1: Module dependency initialization
    if ! init_module_system "err" "lo1" "tme"; then # Removed "lo2"
        debug_log "Critical error: Module system initialization failed. Exiting." "main_ini" "error"
        return 1
    fi

    # Initialize the timer system and clear its log file
    if type tme_init_timer &>/dev/null; then
        tme_init_timer "${BASE_DIR}/.log"
        debug_log "Timer system initialized and log cleared (${BASE_DIR}/.log/tme.log)."
        # New: Start MAIN_OPERATIONS timer right after tme_init_timer
        if type tme_start_timer &>/dev/null; then
            tme_start_timer "MAIN_OPERATIONS"
            main_op_timer_started=1
        else
            debug_log "WARNING: tme_start_timer function not found. Cannot start MAIN_OPERATIONS timer."
        fi
    else
        debug_log "WARNING: tme_init_timer function not found after module loading."
    fi

    # Source the component orchestrator
    # Ensure BASE_DIR is available to comp script if it needs it explicitly
    # (though sourcing should make variables available)
    local comp_orchestrator_path="${BASE_DIR}/bin/core/comp"
    if [[ ! -f "$comp_orchestrator_path" ]]; then
        debug_log "ERROR: Component orchestrator script not found at $comp_orchestrator_path"
        if ((main_op_timer_started)); then type tme_end_timer &>/dev/null && tme_end_timer "MAIN_OPERATIONS" "1"; fi
        return 1
    fi
    # shellcheck source=bin/core/comp
    if type tme_start_timer &>/dev/null; then tme_start_timer "SOURCE_COMP_ORCHESTRATOR" "MAIN_OPERATIONS"; fi
    if ! source "$comp_orchestrator_path"; then
        debug_log "ERROR: Failed to source component orchestrator $comp_orchestrator_path"
        if type tme_end_timer &>/dev/null; then tme_end_timer "SOURCE_COMP_ORCHESTRATOR" "error"; fi
        if ((main_op_timer_started)); then type tme_end_timer &>/dev/null && tme_end_timer "MAIN_OPERATIONS" "1"; fi
        return 1
    fi
    if type tme_end_timer &>/dev/null; then tme_end_timer "SOURCE_COMP_ORCHESTRATOR" "success"; fi
    debug_log "Component orchestrator sourced successfully"

    # Part 2: Runtime dependency initialization (core)
    if type tme_start_timer &>/dev/null; then tme_start_timer "INIT_RUNTIME_SYSTEM" "MAIN_OPERATIONS"; fi
    if ! init_runtime_system; then
        debug_log "ERROR: Core runtime system initialization failed"
        if type tme_end_timer &>/dev/null; then tme_end_timer "INIT_RUNTIME_SYSTEM" "error"; fi
        if ((main_op_timer_started)); then type tme_end_timer &>/dev/null && tme_end_timer "MAIN_OPERATIONS" "1"; fi
        return 1
    fi
    if type tme_end_timer &>/dev/null; then tme_end_timer "INIT_RUNTIME_SYSTEM" "success"; fi

    # Part 3: Setup additional components using the orchestrator
    debug_log "Setting RC_SOURCED=0 before calling setup_components"
    if ! setup_components; then
        debug_log "ERROR: Component setup failed via orchestrator."
        if ((main_op_timer_started)); then type tme_end_timer &>/dev/null && tme_end_timer "MAIN_OPERATIONS" "1"; fi
        return 1
    fi

    if type tme_start_timer &>/dev/null; then tme_start_timer "FINALIZE_MAIN_INIT" "MAIN_OPERATIONS"; fi
    debug_log "RC_SOURCED value after setup_components: ${RC_SOURCED}"
    
    # Modify this check to set RC_SOURCED=1 if setup_components succeeded
    if [[ -z "${RC_SOURCED:-}" ]] || [[ "${RC_SOURCED:-0}" -ne 1 ]]; then
        debug_log "Note: RC_SOURCED was not set to 1 by setup_components, setting it now"
        export RC_SOURCED=1
    fi

    debug_log "Main initialization completed successfully"
    if type tme_end_timer &>/dev/null; then tme_end_timer "FINALIZE_MAIN_INIT" "success"; fi
    if ((main_op_timer_started)); then type tme_end_timer &>/dev/null && tme_end_timer "MAIN_OPERATIONS" "0"; fi
    return 0
}

###########################################
# PART 1: Module Dependency Management
# Uses verification functions:
#   - verify_module() from ver
#   - verify_path() from ver
#   - validate_module() from ver
###########################################

init_module_system() {
    debug_log "Starting module system initialization"

    # Essential verification check from ver module
    if ! essential_check; then
        debug_log "ERROR: Essential system check failed"
        return 1
    fi

    # Initialize module requirements - make it conditionally run based on existence
    if type init_module_requirements &>/dev/null && ! init_module_requirements; then
        debug_log "ERROR: Failed to initialize module requirements"
        return 1
    fi

    # Initialize directories using ver's verify_path
    if ! init_dirs; then
        debug_log "ERROR: Directory initialization failed"
        return 1
    fi

    # Load and verify modules using ver's validation functions
    if ! load_modules; then
        debug_log "ERROR: Module loading failed"
        return 1
    fi

    debug_log "Module system initialization completed"
    return 0
}

# Initialize directories using ver's verify_path
init_dirs() {
    debug_log "Starting directory initialization"

    # Updated directory paths to use BASE_DIR
    # Removed .log and .tmp as they are handled by essential_check
    local required_dirs=(
        "${BASE_DIR}/lib"
        "${BASE_DIR}/cfg"
    )

    # Using verify_path from ver module
    for dir in "${required_dirs[@]}"; do
        if ! verify_path "$dir" "dir" "true"; then
            debug_log "ERROR: Failed to verify/create directory: $dir"
            return 1
        fi
        chmod 700 "$dir" 2>/dev/null || debug_log "WARNING: Unable to set permissions for $dir"
    done

    return 0
}

# Load modules using ver's validation functions
load_modules() {
    debug_log "Starting module loading"

    local module_loaded=0
    local -a modules=(
        "${BASE_DIR}/lib/core/err" # <-- Changed from lib/core/err
        "${BASE_DIR}/lib/core/lo1"
        "${BASE_DIR}/lib/util/lo2"
        "${BASE_DIR}/lib/core/tme"
    )

    declare -A loaded_modules

    for module in "${modules[@]}"; do
        local module_name="$(basename "$module")"
        debug_log "Processing module: $module_name"

        if [[ "$module_name" == "lo2" ]]; then
            echo "INIT_SCRIPT_FLOW: About to source lo2 - $(date '+%T.%N')" >> "/home/es/lab/.log/init_flow.log"
        fi

        # Using verify_module and validate_module from ver
        if ! verify_module "$module_name" || ! validate_module "$module"; then
            debug_log "ERROR: Module verification/validation failed for $module_name" "verify_module" 1
            continue
        fi

        if [[ -f "$module" ]] && [[ -r "$module" ]]; then
            if source "$module" 2>/dev/null; then
                debug_log "Successfully loaded module: $module_name"
                if [[ "$module_name" == "lo2" ]]; then
                    echo "INIT_SCRIPT_FLOW: Sourced lo2, about to call setlogcontrol on - $(date '+%T.%N')" >> "/home/es/lab/.log/init_flow.log"
                fi
                loaded_modules[$module_name]=1
                ((module_loaded++))
            else
                debug_log "ERROR: Failed to source module $module_name"
            fi
        fi
    done

    echo "INIT_SCRIPT_FLOW: Finished module loading loop in init - $(date '+%T.%N')" >> "/home/es/lab/.log/init_flow.log"

    return $((module_loaded > 0 ? 0 : 1))
}

###########################################
# PART 2: Runtime Dependency Management
# Uses verification functions:
#   - verify_path() from ver
#   - verify_var() from ver
###########################################

init_runtime_system() {
    debug_log "Starting runtime system initialization"
    local parent_timer="INIT_RUNTIME_SYSTEM" # Define parent timer for sub-operations

    # Updated with BASE_DIR - using rdc file which exists
    local rde_path="${BASE_DIR}/cfg/core/rdc"

    # Verify runtime dependency file exists using ver's verify_path
    if type tme_start_timer &>/dev/null; then tme_start_timer "VERIFY_RDC_PATH" "$parent_timer"; fi
    if ! verify_path "$rde_path" "file" "false"; then
        debug_log "ERROR: Runtime dependencies file not found"
        if type tme_end_timer &>/dev/null; then tme_end_timer "VERIFY_RDC_PATH" "error"; fi
        return 1
    fi
    if type tme_end_timer &>/dev/null; then tme_end_timer "VERIFY_RDC_PATH" "success"; fi

    # Load runtime dependencies
    if type tme_start_timer &>/dev/null; then tme_start_timer "LOAD_RDC" "$parent_timer"; fi
    if ! source "$rde_path" 2>/dev/null; then
        debug_log "ERROR: Failed to load runtime dependencies"
        if type tme_end_timer &>/dev/null; then tme_end_timer "LOAD_RDC" "error"; fi
        return 1
    fi
    if type tme_end_timer &>/dev/null; then tme_end_timer "LOAD_RDC" "success"; fi

    # Process runtime configurations
    if type tme_start_timer &>/dev/null; then tme_start_timer "PROCESS_RUNTIME_CONFIG" "$parent_timer"; fi
    if ! process_runtime_config; then
        debug_log "ERROR: Failed to process runtime configuration"
        if type tme_end_timer &>/dev/null; then tme_end_timer "PROCESS_RUNTIME_CONFIG" "error"; fi
        return 1
    fi
    if type tme_end_timer &>/dev/null; then tme_end_timer "PROCESS_RUNTIME_CONFIG" "success"; fi

    # Initialize registered functions
    if type tme_start_timer &>/dev/null; then tme_start_timer "INIT_REGISTERED_FUNCTIONS" "$parent_timer"; fi
    if ! init_registered_functions; then
        debug_log "ERROR: Failed to initialize registered functions"
        if type tme_end_timer &>/dev/null; then tme_end_timer "INIT_REGISTERED_FUNCTIONS" "error"; fi
        return 1
    fi
    if type tme_end_timer &>/dev/null; then tme_end_timer "INIT_REGISTERED_FUNCTIONS" "success"; fi

    debug_log "Runtime system initialization completed"
    return 0
}

# Process runtime configurations
process_runtime_config() {
    debug_log "Processing runtime configuration"
    return 0
}

# Initialize registered functions with verification
init_registered_functions() {
    debug_log "Initializing registered functions" "init_registered_functions" 1
    local parent_timer="INIT_REGISTERED_FUNCTIONS" # Parent timer for this overall function

    # Verify REGISTERED_FUNCTIONS exists using ver's verify_var
    if ! verify_var "REGISTERED_FUNCTIONS" 1; then
        debug_log "No registered functions found" "init_registered_functions" 1
        return 0
    fi

    local failed=0
    local success=0
    for func in "${REGISTERED_FUNCTIONS[@]}"; do
        debug_log "Checking function: $func" "init_registered_functions" 2
        local func_timer_name_deps="VERIFY_FUNC_DEPS_${func//[^A-Za-z0-9_]/_}" # Sanitize func name for timer
        local func_timer_name_reg="REGISTER_FUNC_${func//[^A-Za-z0-9_]/_}" # Sanitize func name for timer

        if type tme_start_timer &>/dev/null; then tme_start_timer "$func_timer_name_deps" "$parent_timer"; fi
        if ! verify_function_dependencies "$func"; then
            debug_log "WARNING: Failed to verify dependencies for function: $func - continuing anyway" "init_registered_functions" 1
            if type tme_end_timer &>/dev/null; then tme_end_timer "$func_timer_name_deps" "error_deps_failed"; fi
            continue
        fi
        if type tme_end_timer &>/dev/null; then tme_end_timer "$func_timer_name_deps" "success"; fi

        if type tme_start_timer &>/dev/null; then tme_start_timer "$func_timer_name_reg" "$parent_timer"; fi
        if register_function "$func"; then
            debug_log "Successfully registered function: $func" "init_registered_functions" 1
            if type tme_end_timer &>/dev/null; then tme_end_timer "$func_timer_name_reg" "success"; fi
            ((success++))
        else
            debug_log "WARNING: Failed to register function: $func - continuing anyway" "init_registered_functions" 1
            if type tme_end_timer &>/dev/null; then tme_end_timer "$func_timer_name_reg" "error_reg_failed"; fi
        fi
    done

    debug_log "Registered $success functions successfully" "init_registered_functions" 1
    return $((success > 0 ? 0 : 1))
}

# Register a function with its dependencies
register_function() {
    local func_name="$1"
    debug_log "Registering function: $func_name" "register_function" 1

    local deps="${FUNCTION_DEPENDENCIES[$func_name]}"
    [[ -z "$deps" ]] && {
        debug_log "ERROR: No dependencies found for function: $func_name" "register_function" 1
        return 1
    }

    local success=0
    IFS=',' read -ra MODULE_ARRAY <<< "$deps"
    
    for module in "${MODULE_ARRAY[@]}"; do
        local module_path="${FUNCTION_MODULES["$func_name:$module"]:-${FUNCTION_MODULES[$func_name]}}"
        
        if [[ -n "$module_path" ]] && [[ -f "$module_path" ]]; then
            debug_log "Checking for function $func_name in module $module_path" "register_function" 2
            
            if verify_function "$func_name" "$module_path" 2; then
                if source "$module_path" 2>/dev/null; then
                    debug_log "Successfully registered function: $func_name from $module_path" "register_function" 1
                    success=1
                    break
                fi
            fi
        else
            debug_log "WARNING: Module path not found for $func_name in module $module" "register_function" 1
        fi
    done

    return $((success == 1 ? 0 : 1))
}

# Setup minimal environment in case of failure
setup_minimal_environment() {
    local base_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$HOME/bin"
    export PATH="$PATH:$base_path"
    PS1="(minimal)[\u@\h \W]\$ "

    # Create essential directories
    local log_dir="${BASE_DIR}/.log"
    local tmp_dir="${BASE_DIR}/.tmp"
    for dir in "$log_dir" "$tmp_dir"; do
        mkdir -p "$dir" 2>/dev/null
    done
}

echo " ─── initializing"
# Execute initialization
main_ini
RC_STATUS=$?

if [ $RC_STATUS -ne 0 ]; then
    echo "Initialization failed with status $RC_STATUS. Check logs for details" >&2
    setup_minimal_environment
    exit 1
fi

# Export only the main initialization function
export -f main_ini

# --- Force timer output and print timing report at the end ---
if type tme_settme &>/dev/null; then
    tme_settme on
fi
if type tme_print_timing_report &>/dev/null; then
    tme_print_timing_report
fi
