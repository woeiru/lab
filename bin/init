#!/bin/bash
#######################################################################
# System Initialization Controller
#######################################################################
# Purpose:
#   Core system initialization script that manages the bootstrapping and 
#   configuration of the entire environment through a modular, dependency-
#   aware approach.
#
# Architecture:
#   - Core Components:
#     * Verification Module (ver): Validates system state and dependencies
#     * Runtime Constants (ric): System-wide configuration constants
#     * Module Dependencies (mdc): Module relationship definitions
#     * Runtime Dependencies (rdc): Runtime environment requirements
#
# Initialization Flow:
#   1. Module System Initialization:
#      - Validates core dependencies
#      - Sets up required directories
#      - Loads and verifies essential modules (err, lo1, lo2, tme)
#
#   2. Runtime System Initialization:
#      - Processes runtime configurations
#      - Loads runtime dependencies
#      - Registers and validates system functions
#
# Error Handling:
#   - Comprehensive error logging via debug_log
#   - Fallback to minimal environment on failure
#   - Verification at each critical step
#
# Dependencies:
#   Required files in cfg/core/:
#   - ric (Runtime initialization constants)
#   - rdc (Runtime dependency constants)
#   - mdc (Module dependency constants)
#   Required modules in lib/core/:
#   - ver (Verification functions)
#
#######################################################################

# Set the base directory path
readonly DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
readonly BASE_DIR="$( cd "$DIR/.." &> /dev/null && pwd )"

# Debug verbosity level (0=minimal, 1=standard, 2=verbose)
DEBUG_VERBOSITY=${DEBUG_VERBOSITY:-1}

# Simple debug logging function to use before we load the full system
debug_log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local source="${2:-${FUNCNAME[1]:-main}}"
    local level="${3:-1}" # Default verbosity level
    local LOG_DEBUG_FILE="${BASE_DIR}/.log/debug.log"
    
    # Always log to file regardless of verbosity
    mkdir -p "$(dirname "$LOG_DEBUG_FILE")" 2>/dev/null
    echo "[DEBUG] $timestamp - [$source] $message" >> "$LOG_DEBUG_FILE"
    
    # Only output to stderr if verbosity level is sufficient
    if (( DEBUG_VERBOSITY >= level )); then
        # For level 0, only show startup, completion and error messages
        if (( DEBUG_VERBOSITY == 0 )); then
            if [[ "$message" == *ERROR* || "$message" == *CRITICAL* || "$message" == *WARNING* || 
                  "$message" == *"Starting main"* || "$message" == *"completed successfully"* ]]; then
                echo "[DEBUG] $timestamp - [$source] $message" >&2
            fi
        else
            echo "[DEBUG] $timestamp - [$source] $message" >&2
        fi
    fi
}

# Initialization System
# Dependencies: Relies on verification module (ver), runtime and module dependency constants (rdc, mdc)
# Purpose: Manages system initialization in two phases:
#   1. Module dependency initialization (working with mdc)
#   2. Runtime dependency initialization (working with rdc)

# Source runtime initialization constants
source "${BASE_DIR}/cfg/core/ric" || {
    echo "Failed to source runtime constants" >&2
    exit 1
}

# Source runtime dependency constants
source "${BASE_DIR}/cfg/core/rdc" || {
    echo "Failed to source dependency constants" >&2
    exit 1
}

# Source module dependency constants
source "${BASE_DIR}/cfg/core/mdc" || {
    echo "Failed to source dependency constants" >&2
    exit 1
}

# Source verification module
source "${BASE_DIR}/lib/core/ver" || {
    echo "Failed to source verification module" >&2
    exit 1
}

###############################################
# Core initialization orchestrator
# Dependencies:
#   - ver (lib/core/ver) for all verification functions
###############################################
main_ini() {
    debug_log "Starting main initialization"

    # Verify that verification module is loaded
    if ! type verify_module &>/dev/null || ! type verify_path &>/dev/null; then
        echo "ERROR: Verification module not properly loaded" >&2
        return 1
    fi

    # Part 1: Module dependency initialization
    if ! init_module_system; then
        debug_log "ERROR: Module system initialization failed"
        return 1
    fi

    # Source the component orchestrator
    # Ensure BASE_DIR is available to comp script if it needs it explicitly
    # (though sourcing should make variables available)
    local comp_orchestrator_path="${BASE_DIR}/bin/core/comp"
    if [[ ! -f "$comp_orchestrator_path" ]]; then
        debug_log "ERROR: Component orchestrator script not found at $comp_orchestrator_path"
        return 1
    fi
    # shellcheck source=bin/core/comp
    if ! source "$comp_orchestrator_path"; then
        debug_log "ERROR: Failed to source component orchestrator $comp_orchestrator_path"
        return 1
    fi
    debug_log "Component orchestrator sourced successfully"

    # Part 2: Runtime dependency initialization (core)
    if ! init_runtime_system; then
        debug_log "ERROR: Core runtime system initialization failed"
        return 1
    fi

    # Part 3: Setup additional components using the orchestrator
    debug_log "Setting RC_SOURCED=0 before calling setup_components"
    export RC_SOURCED=0
    
    # Define print_timing_report and print_error_report if they don't exist
    if ! type print_timing_report &>/dev/null; then
        debug_log "Defining fallback print_timing_report function"
        print_timing_report() { debug_log "Timing report requested but function unavailable"; }
        export -f print_timing_report
    fi
    
    if ! type print_error_report &>/dev/null; then
        debug_log "Defining fallback print_error_report function"
        print_error_report() { debug_log "Error report requested but function unavailable"; }
        export -f print_error_report
    fi
    
    if ! setup_components; then
        debug_log "ERROR: Component setup failed via orchestrator."
        return 1 # main_ini should still return failure
    fi

    debug_log "RC_SOURCED value after setup_components: ${RC_SOURCED}"
    
    # Modify this check to set RC_SOURCED=1 if setup_components succeeded
    if [[ -z "${RC_SOURCED:-}" ]] || [[ "${RC_SOURCED:-0}" -ne 1 ]]; then
        debug_log "Note: RC_SOURCED was not set to 1 by setup_components, setting it now"
        export RC_SOURCED=1
    fi

    debug_log "Main initialization completed successfully"
    return 0
}

###########################################
# PART 1: Module Dependency Management
# Uses verification functions:
#   - verify_module() from ver
#   - verify_path() from ver
#   - validate_module() from ver
###########################################

init_module_system() {
    debug_log "Starting module system initialization"

    # Essential verification check from ver module
    if ! essential_check; then
        debug_log "ERROR: Essential system check failed"
        return 1
    fi

    # Initialize module requirements - make it conditionally run based on existence
    if type init_module_requirements &>/dev/null && ! init_module_requirements; then
        debug_log "ERROR: Failed to initialize module requirements"
        return 1
    fi

    # Initialize directories using ver's verify_path
    if ! init_dirs; then
        debug_log "ERROR: Directory initialization failed"
        return 1
    fi

    # Load and verify modules using ver's validation functions
    if ! load_modules; then
        debug_log "ERROR: Module loading failed"
        return 1
    fi

    debug_log "Module system initialization completed"
    return 0
}

# Initialize directories using ver's verify_path
init_dirs() {
    debug_log "Starting directory initialization"

    # Updated directory paths to use BASE_DIR
    # Removed .log and .tmp as they are handled by essential_check
    local required_dirs=(
        "${BASE_DIR}/lib"
        "${BASE_DIR}/cfg"
    )

    # Using verify_path from ver module
    for dir in "${required_dirs[@]}"; do
        if ! verify_path "$dir" "dir" "true"; then
            debug_log "ERROR: Failed to verify/create directory: $dir"
            return 1
        fi
        chmod 700 "$dir" 2>/dev/null || debug_log "WARNING: Unable to set permissions for $dir"
    done

    return 0
}

# Load modules using ver's validation functions
load_modules() {
    debug_log "Starting module loading"

    local module_loaded=0
    local -a modules=(
        "${BASE_DIR}/lib/util/err" # <-- Changed from lib/core/err
        "${BASE_DIR}/lib/util/lo1"
        "${BASE_DIR}/lib/util/lo2"
        "${BASE_DIR}/lib/util/tme"
    )

    declare -A loaded_modules

    for module in "${modules[@]}"; do
        local module_name="$(basename "$module")"
        debug_log "Processing module: $module_name"

        # Using verify_module and validate_module from ver
        if ! verify_module "$module_name" || ! validate_module "$module"; then
            debug_log "ERROR: Module verification/validation failed for $module_name" "verify_module" 1
            continue
        fi

        if [[ -f "$module" ]] && [[ -r "$module" ]]; then
            if source "$module" 2>/dev/null; then
                debug_log "Successfully loaded module: $module_name"
                loaded_modules[$module_name]=1
                ((module_loaded++))
            else
                debug_log "ERROR: Failed to source module $module_name"
            fi
        fi
    done

    return $((module_loaded > 0 ? 0 : 1))
}

###########################################
# PART 2: Runtime Dependency Management
# Uses verification functions:
#   - verify_path() from ver
#   - verify_var() from ver
###########################################

init_runtime_system() {
    debug_log "Starting runtime system initialization"

    # Updated with BASE_DIR - using rdc file which exists
    local rde_path="${BASE_DIR}/cfg/core/rdc"
    
    # Verify runtime dependency file exists using ver's verify_path
    if ! verify_path "$rde_path" "file" "false"; then
        debug_log "ERROR: Runtime dependencies file not found"
        return 1
    fi

    # Load runtime dependencies
    if ! source "$rde_path" 2>/dev/null; then
        debug_log "ERROR: Failed to load runtime dependencies"
        return 1
    fi

    # Process runtime configurations
    if ! process_runtime_config; then
        debug_log "ERROR: Failed to process runtime configuration"
        return 1
    fi

    # Initialize registered functions
    if ! init_registered_functions; then
        debug_log "ERROR: Failed to initialize registered functions"
        return 1
    fi

    debug_log "Runtime system initialization completed"
    return 0
}

# Process runtime configurations with ver validation
process_runtime_config() {
    debug_log "Processing runtime configuration"
    
    # RC files have been consolidated into the init file, 
    # no need to verify or source separate RC files
    debug_log "Runtime configuration files consolidated into init file"
    
    # Still call source_rc for backward compatibility,
    # but it will handle the case where no RC files exist
    source_rc
    
    return 0
}

# Source RC files with validation
source_rc() {
    debug_log "Starting source_rc"
    
    # RC files have been consolidated into the init file
    debug_log "RC files have been consolidated into the init file, no separate RC files to source"
    
    # Return success directly
    return 0
}

# Initialize registered functions with verification
init_registered_functions() {
    debug_log "Initializing registered functions" "init_registered_functions" 1

    # Verify REGISTERED_FUNCTIONS exists using ver's verify_var
    if ! verify_var "REGISTERED_FUNCTIONS" 1; then
        debug_log "No registered functions found" "init_registered_functions" 1
        return 0
    fi

    local failed=0
    local success=0
    for func in "${REGISTERED_FUNCTIONS[@]}"; do
        debug_log "Checking function: $func" "init_registered_functions" 2
        if ! verify_function_dependencies "$func"; then
            debug_log "WARNING: Failed to verify dependencies for function: $func - continuing anyway" "init_registered_functions" 1
            continue
        fi

        if register_function "$func"; then
            debug_log "Successfully registered function: $func" "init_registered_functions" 1
            ((success++))
        else
            debug_log "WARNING: Failed to register function: $func - continuing anyway" "init_registered_functions" 1
        fi
    done

    # Even with failures, continue if at least one function registers successfully
    debug_log "Registered $success functions successfully" "init_registered_functions" 1
    return $((success > 0 ? 0 : 1))
}

# Register a function with its dependencies
register_function() {
    local func_name="$1"
    debug_log "Registering function: $func_name" "register_function" 1

    # Get the dependencies for this function
    local deps="${FUNCTION_DEPENDENCIES[$func_name]}"
    [[ -z "$deps" ]] && {
        debug_log "ERROR: No dependencies found for function: $func_name" "register_function" 1
        return 1
    }

    # Check if the function exists in any of its module files
    local success=0
    IFS=',' read -ra MODULE_ARRAY <<< "$deps"
    
    for module in "${MODULE_ARRAY[@]}"; do
        local module_path="${FUNCTION_MODULES["$func_name:$module"]:-${FUNCTION_MODULES[$func_name]}}"
        
        if [[ -n "$module_path" ]] && [[ -f "$module_path" ]]; then
            debug_log "Checking for function $func_name in module $module_path" "register_function" 2
            
            # Verify function exists in the module file
            if verify_function "$func_name" "$module_path" 2; then
                # Source the module file
                if source "$module_path" 2>/dev/null; then
                    debug_log "Successfully registered function: $func_name from $module_path" "register_function" 1
                    success=1
                    break
                fi
            fi
        else
            debug_log "WARNING: Module path not found for $func_name in module $module" "register_function" 1
        fi
    done

    return $((success == 1 ? 0 : 1))
}

# Setup minimal environment in case of failure
setup_minimal_environment() {
    local base_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$HOME/bin"
    export PATH="$PATH:$base_path"
    PS1="(minimal)[\u@\h \W]\$ "

    # Create essential directories
    local log_dir="${BASE_DIR}/.log"
    local tmp_dir="${BASE_DIR}/.tmp"
    for dir in "$log_dir" "$tmp_dir"; do
        mkdir -p "$dir" 2>/dev/null
    done
}

# Check if DEBUG_VERBOSITY is set as an environment variable when script is called
if [[ -z "${DEBUG_VERBOSITY}" ]]; then
    # Default is 1 (standard verbosity)
    DEBUG_VERBOSITY=1
fi

echo " ─── initializing (verbosity level: ${DEBUG_VERBOSITY})"
# Execute initialization
main_ini
RC_STATUS=$?

if [ $RC_STATUS -ne 0 ]; then
    echo "Initialization failed with status $RC_STATUS. Check logs for details" >&2
    setup_minimal_environment
    exit 1
fi

# Export only the main initialization function
export -f main_ini
