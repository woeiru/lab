#!/bin/bash

# Set the base directory path
readonly DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
readonly BASE_DIR="$( cd "$DIR/.." &> /dev/null && pwd )"

# Simple debug logging function to use before we load the full system
debug_log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$1"
    local source="${2:-${FUNCNAME[1]:-main}}"
    local LOG_DEBUG_FILE="${BASE_DIR}/.log/debug.log"
    
    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$LOG_DEBUG_FILE")" 2>/dev/null
    
    # Output to stderr for immediate feedback during debugging
    echo "[DEBUG] $timestamp - [$source] $message" >&2
    
    # Also log to file
    echo "[DEBUG] $timestamp - [$source] $message" >> "$LOG_DEBUG_FILE"
}

#######################################################################
# System Initialization Controller
#######################################################################
# Purpose:
#   Core system initialization script that manages the bootstrapping and 
#   configuration of the entire environment through a modular, dependency-
#   aware approach.
#
# Architecture:
#   - Core Components:
#     * Verification Module (ver): Validates system state and dependencies
#     * Runtime Constants (ric): System-wide configuration constants
#     * Module Dependencies (mdc): Module relationship definitions
#     * Runtime Dependencies (rdc): Runtime environment requirements
#
# Initialization Flow:
#   1. Module System Initialization:
#      - Validates core dependencies
#      - Sets up required directories
#      - Loads and verifies essential modules (err, lo1, lo2, tme)
#
#   2. Runtime System Initialization:
#      - Processes runtime configurations
#      - Loads runtime dependencies
#      - Registers and validates system functions
#
# Error Handling:
#   - Comprehensive error logging via debug_log
#   - Fallback to minimal environment on failure
#   - Verification at each critical step
#
# Dependencies:
#   Required files in cfg/core/:
#   - ric (Runtime initialization constants)
#   - rdc (Runtime dependency constants)
#   - mdc (Module dependency constants)
#   Required modules in lib/core/:
#   - ver (Verification functions)
#
#######################################################################

# Initialization System
# Dependencies: Relies on verification module (ver), runtime and module dependency constants (rdc, mdc)
# Purpose: Manages system initialization in two phases:
#   1. Module dependency initialization (working with mdc)
#   2. Runtime dependency initialization (working with rdc)

# Source runtime initialization constants
source "${BASE_DIR}/cfg/core/ric" || {
    echo "Failed to source runtime constants" >&2
    exit 1
}

# Source runtime dependency constants
source "${BASE_DIR}/cfg/core/rdc" || {
    echo "Failed to source dependency constants" >&2
    exit 1
}

# Source module dependency constants
source "${BASE_DIR}/cfg/core/mdc" || {
    echo "Failed to source dependency constants" >&2
    exit 1
}

# Source verification module
source "${BASE_DIR}/lib/core/ver" || {
    echo "Failed to source verification module" >&2
    exit 1
}

###############################################
# Core initialization orchestrator
# Dependencies:
#   - ver (lib/core/ver) for all verification functions
###############################################
main_ini() {
    debug_log "Starting main initialization"

    # Verify that verification module is loaded
    if ! type verify_module &>/dev/null || ! type verify_path &>/dev/null; then
        echo "ERROR: Verification module not properly loaded" >&2
        return 1
    fi

    # Part 1: Module dependency initialization
    if ! init_module_system; then
        debug_log "ERROR: Module system initialization failed"
        return 1
    fi

    # Part 2: Runtime dependency initialization
    if ! init_runtime_system; then
        debug_log "ERROR: Runtime system initialization failed"
        return 1
    fi

    debug_log "Main initialization completed successfully"
    return 0
}

###########################################
# PART 1: Module Dependency Management
# Uses verification functions:
#   - verify_module() from ver
#   - verify_path() from ver
#   - validate_module() from ver
###########################################

init_module_system() {
    debug_log "Starting module system initialization"

    # Essential verification check from ver module
    if ! essential_check; then
        debug_log "ERROR: Essential system check failed"
        return 1
    fi

    # Initialize module requirements - make it conditionally run based on existence
    if type init_module_requirements &>/dev/null && ! init_module_requirements; then
        debug_log "ERROR: Failed to initialize module requirements"
        return 1
    fi

    # Initialize directories using ver's verify_path
    if ! init_dirs; then
        debug_log "ERROR: Directory initialization failed"
        return 1
    fi

    # Load and verify modules using ver's validation functions
    if ! load_modules; then
        debug_log "ERROR: Module loading failed"
        return 1
    fi

    debug_log "Module system initialization completed"
    return 0
}

# Initialize directories using ver's verify_path
init_dirs() {
    debug_log "Starting directory initialization"

    # Updated directory paths to use BASE_DIR
    local required_dirs=(
        "${BASE_DIR}/.log"
        "${BASE_DIR}/.tmp"
        "${BASE_DIR}/lib"
        "${BASE_DIR}/cfg"
    )

    # Using verify_path from ver module
    for dir in "${required_dirs[@]}"; do
        if ! verify_path "$dir" "dir" "true"; then
            debug_log "ERROR: Failed to verify/create directory: $dir"
            return 1
        fi
        chmod 700 "$dir" 2>/dev/null || debug_log "WARNING: Unable to set permissions for $dir"
    done

    return 0
}

# Load modules using ver's validation functions
load_modules() {
    debug_log "Starting module loading"

    local module_loaded=0
    local -a modules=(
        "${BASE_DIR}/lib/core/err"
        "${BASE_DIR}/lib/util/lo1"
        "${BASE_DIR}/lib/util/lo2"
        "${BASE_DIR}/lib/util/tme"
    )

    declare -A loaded_modules

    for module in "${modules[@]}"; do
        local module_name="$(basename "$module")"
        debug_log "Processing module: $module_name"

        # Using verify_module and validate_module from ver
        if ! verify_module "$module_name" || ! validate_module "$module"; then
            debug_log "ERROR: Module verification/validation failed for $module_name"
            continue
        fi

        if [[ -f "$module" ]] && [[ -r "$module" ]]; then
            if source "$module" 2> >(debug_log "Source error: $(cat)"); then
                debug_log "Successfully loaded module: $module_name"
                loaded_modules[$module_name]=1
                ((module_loaded++))
            else
                debug_log "ERROR: Failed to source module $module_name"
            fi
        fi
    done

    return $((module_loaded > 0 ? 0 : 1))
}

###########################################
# PART 2: Runtime Dependency Management
# Uses verification functions:
#   - verify_path() from ver
#   - verify_var() from ver
###########################################

init_runtime_system() {
    debug_log "Starting runtime system initialization"

    # Updated with BASE_DIR - using rdc file which exists
    local rde_path="${BASE_DIR}/cfg/core/rdc"
    
    # Verify runtime dependency file exists using ver's verify_path
    if ! verify_path "$rde_path" "file" "false"; then
        debug_log "ERROR: Runtime dependencies file not found"
        return 1
    fi

    # Load runtime dependencies
    if ! source "$rde_path" 2>/dev/null; then
        debug_log "ERROR: Failed to load runtime dependencies"
        return 1
    fi

    # Process runtime configurations
    if ! process_runtime_config; then
        debug_log "ERROR: Failed to process runtime configuration"
        return 1
    fi

    # Initialize registered functions
    if ! init_registered_functions; then
        debug_log "ERROR: Failed to initialize registered functions"
        return 1
    fi

    debug_log "Runtime system initialization completed"
    return 0
}

# Process runtime configurations with ver validation
process_runtime_config() {
    debug_log "Processing runtime configuration"

    # Updated path for configuration directory
    local config_dir="${BASE_DIR}/cfg/core"
    
    # Verify RC files exist using rc array keys
    local rc_modules=()
    for rc in "${!rc[@]}"; do
        if ! verify_path "$config_dir/$rc" "file" "false"; then
            debug_log "WARNING: RC file $rc not found"
        fi
    done

    # Source RC files
    if ! source_rc; then
        debug_log "ERROR: Failed to source RC files"
        return 1
    fi

    return 0
}

# Source RC files with validation
source_rc() {
    debug_log "Starting source_rc"
    local rc_modules=()
    # Updated path for configuration directory
    local config_dir="${BASE_DIR}/cfg/core"
    
    # Iterate over the keys of the associative array 'rc'
    for rc in "${!rc[@]}"; do
        rc_modules+=("$rc")
    done
    local success_count=0
    local rc_files_exist=0

    for module in "${rc_modules[@]}"; do
        # First check if any RC files exist at all
        if [[ -r "$config_dir/$module" ]]; then
            rc_files_exist=1
            debug_log "Processing RC module: $module"
            # Validate RC file using ver's validate_module
            if validate_module "$config_dir/$module"; then
                if source "$config_dir/$module" 2> >(debug_log "Source error: $(cat)"); then
                    ((success_count++))
                fi
            fi
        fi
    done

    # If no RC files exist, don't consider it a failure
    if [[ $rc_files_exist -eq 0 ]]; then
        debug_log "No RC files found - continuing anyway"
        return 0
    fi

    return $((success_count > 0 ? 0 : 1))
}

# Initialize registered functions with verification
init_registered_functions() {
    debug_log "Initializing registered functions"

    # Verify REGISTERED_FUNCTIONS exists using ver's verify_var
    if ! verify_var "REGISTERED_FUNCTIONS"; then
        debug_log "No registered functions found"
        return 0
    fi

    local failed=0
    for func in "${REGISTERED_FUNCTIONS[@]}"; do
        if ! verify_function_dependencies "$func"; then
            debug_log "ERROR: Failed to verify dependencies for function: $func"
            ((failed++))
            continue
        fi

        if ! register_function "$func"; then
            debug_log "ERROR: Failed to register function: $func"
            ((failed++))
        fi
    done

    return $((failed > 0 ? 1 : 0))
}

# Register a function with its dependencies
register_function() {
    local func_name="$1"
    debug_log "Registering function: $func_name"

    # Get the dependencies for this function
    local deps="${FUNCTION_DEPENDENCIES[$func_name]}"
    [[ -z "$deps" ]] && {
        debug_log "ERROR: No dependencies found for function: $func_name"
        return 1
    }

    # Check if the function exists in any of its module files
    local success=0
    IFS=',' read -ra MODULE_ARRAY <<< "$deps"
    
    for module in "${MODULE_ARRAY[@]}"; do
        local module_path="${FUNCTION_MODULES["$func_name:$module"]:-${FUNCTION_MODULES[$func_name]}}"
        
        if [[ -n "$module_path" ]] && [[ -f "$module_path" ]]; then
            debug_log "Checking for function $func_name in module $module_path"
            
            # Verify function exists in the module file
            if verify_function "$func_name" "$module_path"; then
                # Source the module file
                if source "$module_path" 2> >(debug_log "Source error: $(cat)"); then
                    debug_log "Successfully registered function: $func_name from $module_path"
                    success=1
                    break
                fi
            fi
        else
            debug_log "WARNING: Module path not found for $func_name in module $module"
        fi
    done

    return $((success == 1 ? 0 : 1))
}

# Setup minimal environment in case of failure
setup_minimal_environment() {
    local base_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$HOME/bin"
    export PATH="$PATH:$base_path"
    PS1="(minimal)[\u@\h \W]\$ "

    # Create essential directories
    local log_dir="${BASE_DIR}/.log"
    local tmp_dir="${BASE_DIR}/.tmp"
    for dir in "$log_dir" "$tmp_dir"; do
        mkdir -p "$dir" 2>/dev/null
    done
}

echo " ─── initializing"
# Execute initialization
main_ini
RC_STATUS=$?

if [ $RC_STATUS -ne 0 ]; then
    echo "Initialization failed with status $RC_STATUS. Check logs for details" >&2
    setup_minimal_environment
    exit 1
fi

# Export only the main initialization function
export -f main_ini
