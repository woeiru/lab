#!/bin/bash
#######################################################################
# Component Orchestrator
#######################################################################
# Purpose:
#   Provides functions to manage and execute a sequence of shell
#   script components during system or application initialization.
#   It handles sourcing environment/function files, executing setup
#   routines, and managing individual components with dependency
#   awareness (required vs. optional) and status tracking.
#
# Helper Functions:
#   - source_helper: Safely sources individual files.
#   - source_directory: Sources all files in a given directory.
#   - execute_component: Executes a single named component with status tracking.
#
# Component Functions (perform specific initialization tasks):
#   - execution_rc: Executes RC-specific setup functions.
#   - source_env: Sources environment configuration files.
#   - source_fun: Sources function library files.
#
# Main Orchestration Function:
#   - setup_components: Orchestrates the execution of all defined
#     components in the proper order with error handling.
#
# Usage:
#   This script is typically sourced by a main initialization script
#   (e.g., /home/es/lab/bin/init), and then its `setup_components`
#   function is called to perform the orchestrated setup.
#   It relies on the `lo1` module for logging and expects certain
#   environment variables like `BASE_DIR` and `ERROR_LOG` to be set,
#   and functions like `start_timer`, `end_timer`, `error_handler`,
#   `print_timing_report`, `print_error_report` to be available.
#######################################################################

# Helper function to safely source files with improved error handling and logging
source_helper() {
    local file="$1"
    local description="${2:-$(basename "$file")}"
    local temp_dir="/tmp" # Consider making this configurable or using mktemp
    local temp_error="$temp_dir/source_error.$$"

    start_timer "source_$description"

    # Verify the file exists
    if [[ ! -f "$file" ]]; then
        log "lvl" " Warning: File $description ($file) not found." # Removed tee and stderr redirection, assume log handles it
        handle_error "File not found: $file" "source_helper" "${ERROR_CODES[FILE_NOT_FOUND]}" "WARNING"
        end_timer "source_$description"
        return 1
    fi

    # Verify the file is readable
    if [[ ! -r "$file" ]]; then
        log "lvl" " Warning: File $description ($file) is not readable." # Removed tee and stderr redirection
        handle_error "File not readable: $file" "source_helper" "${ERROR_CODES[PERMISSION_DENIED]}" "WARNING"
        end_timer "source_$description" # Added missing end_timer
        return 1
    fi

    # Verify temp directory exists and is writable
    if [[ ! -d "$temp_dir" ]] || [[ ! -w "$temp_dir" ]]; then
        log "lvl" " Error: Temporary directory $temp_dir is not available or writable" | tee -a "$ERROR_LOG" >&2
        error_handler "$LINENO" "${ERROR_CODES[PERMISSION_DENIED]}" "false"
        end_timer "source_$description"
        return 1
    fi

    # Source the file and capture any errors
    if source "$file" 2>"$temp_error"; then
        log "lvl" "Successfully sourced: $description" | tee -a "$ERROR_LOG"
        end_timer "source_$description" "success"
        rm -f "$temp_error"
        return 0
    else
        local error_output
        error_output=$(cat "$temp_error")
        log "lvl" " Error sourcing $description: $error_output" | tee -a "$ERROR_LOG" >&2
        rm -f "$temp_error"
        error_handler "$LINENO" "${ERROR_CODES[SOURCE_ERROR]}" "false"
        end_timer "source_$description" "error"
        return 1
    fi
}

# Function to source all files in a directory with consistent sorting and error handling
source_directory() {
    local dir="$1"
    local pattern="${2:-*}"
    local description="$3"
    local return_value=0

    start_timer "dir_$description"
    log "lvl" "Sourcing $description: $dir" | tee -a "$ERROR_LOG"

    if [[ ! -d "$dir" ]]; then
        log "lvl" " Warning: Directory $dir not found. Skipping." | tee -a "$ERROR_LOG" >&2
        end_timer "dir_$description"
        return 1
    fi

    # Get all matching files in the directory
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <(find "$dir" -maxdepth 1 -type f -name "$pattern" -print0 | sort -z)

    if [[ ${#files[@]} -eq 0 ]]; then
        log "lvl" " Warning: No matching files found in $dir for pattern '$pattern'" | tee -a "$ERROR_LOG" >&2
        end_timer "dir_$description"
        return 1 # Or 0 if not finding files is acceptable
    fi

    # Source each file
    local success_count=0
    for file in "${files[@]}"; do
        if source_helper "$file" "$(basename "$file")"; then
            ((success_count++))
        fi
    done

    if ((success_count == 0 && ${#files[@]} > 0)); then # Only warn if files were found but none sourced
        log "lvl" " Warning: No files were successfully sourced from $dir" | tee -a "$ERROR_LOG" >&2
        return_value=1
    else
        log "lvl" "Successfully sourced $success_count files from $dir" | tee -a "$ERROR_LOG"
        return_value=0
    fi

    end_timer "dir_$description"
    return $return_value
}

# Component execution with status tracking
execute_component() {
    local func="$1"
    local component="$2"
    local required="${3:-1}"  # Default to required
    local success_var="${component}_SUCCESS"
    local return_value=0

    start_timer "$component"
    log "lvl" " Executing component: $component ..." | tee -a "$ERROR_LOG"

    if ! type "$func" &>/dev/null; then
        log "lvl" " Error: Function $func not found for component $component" | tee -a "$ERROR_LOG" >&2
        error_handler "$LINENO" "${ERROR_CODES[FUNCTION_NOT_FOUND]}" "$([[ $required -eq 0 ]] && echo true || echo false)"
        return_value=1
    elif "$func"; then # Corrected: remove $ before func for execution
        export "$success_var=1"
        log "lvl" " Component $component completed successfully" | tee -a "$ERROR_LOG"
        return_value=0
    else
        unset "$success_var"
        local msg="Component $component failed"
        if ((required)); then
            log "lvl" " Error: $msg" | tee -a "$ERROR_LOG" >&2
            error_handler "$LINENO" "${ERROR_CODES[EXECUTION_FAILED]}" "false"
            return_value=1
        else
            log "lvl" " Warning: $msg (optional component)" | tee -a "$ERROR_LOG" >&2
            error_handler "$LINENO" "${ERROR_CODES[EXECUTION_FAILED]}" "true" # Assuming error_handler can take 'true' for optional
            return_value=0 # Optional component failure doesn't make execute_component fail
        fi
    fi

    end_timer "$component"
    return $return_value
}

# Source the environment files
source_env() {
    # Use ENV_CONFIG_DIR which is defined in ric
    source_directory "$ENV_CONFIG_DIR" "*" "environment configuration files"
    return $?
}

# Source the function files
source_fun() {
    # Use FUN_DIR which is defined in ric
    source_directory "$FUN_DIR" "*" "function files"
    return $?
}

# Execute RC-specific setup functions
execution_rc() {
    log "lvl" "Starting ${FUNCNAME[0]}" | tee -a "$ERROR_LOG"
    start_timer "execution_rc"

    # Ensure BASE_DIR is available; it should be if 'comp' is sourced by 'init'
    if [[ -z "$BASE_DIR" ]]; then
        log "lvl" "Critical: BASE_DIR not set in execution_rc. Cannot proceed." | tee -a "$ERROR_LOG" >&2
        end_timer "execution_rc" "error_base_dir_missing"
        return 1
    fi

    # The alias definition files (static, dynamic, wrap) should now be sourced
    # by the main init script's init_registered_functions mechanism,
    # which uses the definitions in cfg/core/rdc.
    # Therefore, direct sourcing here is removed.

    log "lvl" "Expecting alias functions (set_static, set_dynamic, set_aliaswrap) to be available via rdc." | tee -a "$ERROR_LOG"

    local setup_functions=("set_static" "set_dynamic" "set_aliaswrap")
    local success_count=0

    for func in "${setup_functions[@]}"; do
        start_nested_timing "setup_${func}"

        if ! type "$func" &>/dev/null; then
            log "lvl" "Warning: Function $func not found" | tee -a "$ERROR_LOG" >&2
            end_nested_timing "setup_${func}" "error_not_found"
            continue
        fi

        log "lvl" "Executing $func" | tee -a "$ERROR_LOG"
        if "$func"; then # Corrected: remove $ before func for execution
            ((success_count++))
            end_nested_timing "setup_${func}" "success"
        else
            log "lvl" "Warning: $func failed" | tee -a "$ERROR_LOG" >&2
            end_nested_timing "setup_${func}" "error_execution"
        fi
    done

    local status=$((success_count > 0 ? "success" : "error"))
    end_timer "execution_rc" "$status"

    return $((success_count > 0 ? 0 : 1))
}

setup_components() {
    log "lvl" "Validating and executing component configuration..." | tee -a "$ERROR_LOG"
    log "lvl" "Initial RC_SOURCED value: ${RC_SOURCED:-unset}" | tee -a "$ERROR_LOG"
    
    # Check if required functions exist
    type print_timing_report &>/dev/null || log "lvl" "WARNING: print_timing_report function not found" | tee -a "$ERROR_LOG" >&2
    type print_error_report &>/dev/null || log "lvl" "WARNING: print_error_report function not found" | tee -a "$ERROR_LOG" >&2

    local components=(
        "execution_rc:EXEC:1"        # Required: Executes set_static, set_dynamic, set_aliaswrap
        "source_env:ENV:0"           # Optional: Sources files from $LAB_DIR/env
        "source_fun:FUN:0"           # Optional: Sources files from $LAB_DIR/fun
    )

    log "lvl" "Executing component functions..." | tee -a "$ERROR_LOG"

    local failed_required=0
    for component_def in "${components[@]}"; do # Renamed variable to avoid conflict
        IFS=':' read -r func name required <<< "$component_def"
        if ! execute_component "$func" "$name" "$required"; then
            # execute_component already logs detailed error/warning
            if ((required)); then
                failed_required=1
                # Specific log for required component failure leading to break
                log "lvl" " Required component $name ($func) failed. Halting further component setup." | tee -a "$ERROR_LOG" >&2
                break
            fi
        fi
    done

    if ((failed_required)); then
        unset RC_SOURCED
        log "lvl" " RC initialization failed: required component(s) failed" | tee -a "$ERROR_LOG" >&2
        log "lvl" " RC_SOURCED is now: ${RC_SOURCED:-unset}" | tee -a "$ERROR_LOG" >&2
        # Only call these functions if they exist
        type print_error_report &>/dev/null && print_error_report
        return 1
    else
        export RC_SOURCED=1
        log "lvl" " RC initialization completed successfully" | tee -a "$ERROR_LOG"
        log "lvl" " RC_SOURCED is now: ${RC_SOURCED:-unset}" | tee -a "$ERROR_LOG"
        # Only call these functions if they exist
        type print_error_report &>/dev/null && print_error_report
        return 0
    fi
}

# Ensure this script can be sourced without executing setup_components automatically
# To use, source this file, then call setup_components if needed.
# Example:
# source /path/to/comp
# setup_components
