#!/bin/bash
set -o pipefail

# Set up important directory paths
DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" >/dev/null 2>&1 && pwd)"
PARENT_DIR="/root/lab"

if [[ -z "${BAS_DIR:-}" ]]; then
    readonly BAS_DIR="$PARENT_DIR/bas"
fi

# Helper function to safely source files with improved error handling and logging
# Parameters:
#   $1: Path to the file to be sourced
#   $2: Optional description for logging (defaults to filename)
source_helper() {
    local file="$1"
    local description="${2:-$(basename "$file")}"

    if [[ ! -f "$file" ]]; then
        echo "       ━ Warning: File $description ($file) not found." | tee -a "$ERROR_LOG" >&2
        return 1
    fi

    if [[ ! -r "$file" ]]; then
        echo "       ━ Warning: File $description ($file) is not readable." | tee -a "$ERROR_LOG" >&2
        return 1
    fi

    # Source the file and capture any errors
    if source "$file" 2>/tmp/source_error; then
        echo "       ━ Successfully sourced: $description"
        return 0
    else
        local error=$(cat /tmp/source_error)
        echo "       ━ Error sourcing $description: $error" | tee -a "$ERROR_LOG" >&2
        rm -f /tmp/source_error
        return 1
    fi
}

# Function to source all files in a directory with consistent sorting and error handling
# Parameters:
#   $1: Directory path
#   $2: File pattern (e.g., "*.bash" or "*")
#   $3: Description for logging
source_directory() {
    local dir="$1"
    local pattern="${2:-*}"
    local description="$3"
    local return_value=0

    echo "     ━ Sourcing $description: $dir"

    if [[ ! -d "$dir" ]]; then
        echo "     ━ Warning: Directory $dir not found. Skipping."
        return 1
    fi

    # Get all matching files in the directory
    local files=()
    while IFS= read -r -d '' file; do
        if [[ -f "$file" ]]; then
            files+=("$file")
        fi
    done < <(find "$dir" -maxdepth 1 -type f -name "$pattern" -print0)

    # Sort files for consistent loading order
    IFS=$'\n' files=($(sort <<<"${files[*]}"))
    unset IFS

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "     ━ Warning: No matching files found in $dir"
        return 1
    fi

    # Source each file
    local success_count=0
    for file in "${files[@]}"; do
        if source_helper "$file" "$(basename "$file")"; then
            ((success_count++))
        fi
    done

    if ((success_count == 0)); then
        echo "     ━ Warning: No files were successfully sourced from $dir"
        return_value=1
    else
        echo "     ━ Successfully sourced $success_count files from $dir"
        return_value=0
    fi

    return $return_value
}

# Source the base files
source_bas() {
    source_directory "$BAS_DIR" "*" "base folder"
    return $?
}

# Source the function files
source_fun() {
    source_directory "$PARENT_DIR/fun" "*.bash" "function files"
    return $?
}

# Source the environment files
source_env() {
    source_directory "$PARENT_DIR/env" "*.conf" "environment configuration files"
    return $?
}

# Source the RC modules
source_rc() {
    log "lvl-2" "Sourcing primary RC modules"
    local rc_modules=("rc1" "rc2" "rc3" "rc4")
    local success_count=0

    for module in "${rc_modules[@]}"; do
        if source_helper "$DIR/$module" "RC module $module"; then
            ((success_count++))
        fi
    done

    if ((success_count == 0)); then
        log "lvl-4" "Warning: No RC modules were successfully sourced"
        return 1
    fi

    return 0
}

# Execute RC-specific setup functions
execution_rc() {
    log "lvl-1" "Starting ${FUNCNAME[0]}"
    local setup_functions=("set_static" "set_dynamic" "set_aliaswrap")
    local success_count=0

    for func in "${setup_functions[@]}"; do
        if ! type "$func" &>/dev/null; then
            log "lvl-3" "Warning: Function $func not found" | tee -a "$ERROR_LOG" >&2
            continue
        fi

        log "lvl-3" "Executing $func"
        if $func; then
            ((success_count++))
        else
            log "lvl-3" "Warning: $func failed" | tee -a "$ERROR_LOG" >&2
        fi
    done

    return $((success_count > 0 ? 0 : 1))
}

# Component execution with status tracking
execute_component() {
    local func="$1"
    local component="$2"
    local required="${3:-1}"  # Default to required
    local success_var="${component}_SUCCESS"
    local return_value=0

    echo
    echo "   ━ Executing component: $component"

    if ! type "$func" &>/dev/null; then
        echo "   ━ Error: Function $func not found" | tee -a "$ERROR_LOG" >&2
        return_value=1
    elif $func; then
        export "$success_var=1"
        echo "   ━ Component $component completed successfully"
        return_value=0
    else
        unset "$success_var"
        local msg="Component $component failed"
        if ((required)); then
            echo "   ━ Error: $msg" | tee -a "$ERROR_LOG" >&2
            return_value=1
        else
            echo "   ━ Warning: $msg (optional component)" | tee -a "$ERROR_LOG" >&2
            return_value=0
        fi
    fi

    return $return_value
}

# Main execution function with component dependency management
main_rc() {
    local components=(
        "source_bas:BAS:1"           # Required
        "source_rc:RC:1"             # Required
        "source_env:ENV:0"           # Optional
        "source_fun:FUN:0"           # Optional
        "execution_rc:EXEC:1"        # Required
    )

    local failed_required=0

    echo
    echo " ━ RC initialization started"

    for component in "${components[@]}"; do
        IFS=':' read -r func name required <<< "$component"

        if ! execute_component "$func" "$name" "$required"; then
            if ((required)); then
                failed_required=1
                echo " ━ Required component $name failed"
                echo
                break
            fi
        fi
    done

    # Setup error handling
    setup_error_handling

    if ((failed_required)); then
        unset RC_SOURCED
        echo " ━ RC initialization failed: required component(s) failed" | tee -a "$ERROR_LOG" >&2
        echo
        return 1
    else
        export RC_SOURCED=1
        echo
        echo " ━ RC initialization completed successfully"
        echo
        return 0
    fi
}

# Execute the main function
main_rc
