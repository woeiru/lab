#!/bin/bash

# Enable error handling
set -e

# Check if SOURCE_RC_SUCCESS is set
if [[ -z "${SOURCE_RC_SUCCESS}" ]]; then
    # Minimal log function as fallback
    log() {
        local level="$1"
        local message="$2"
        echo "[${level}] ${message}"
    }

    log_error() {
        log "ERROR" "$1" >&2
    }

    log_info() {
        log "INFO" "$1"
    }

    # Attempt to source rc2 for full logging capabilities
    if [[ -f "/path/to/rc2" ]]; then
        source "/path/to/rc2"
        export SOURCE_RC_SUCCESS=1
        log "lvl-2" "rc2 sourced successfully"
    else
        echo "rc2 not found, using minimal logging"
    fi
else
    log "lvl-2" "rc already sourced, using existing log function"
fi

check_arguments() {
    local script_name="$1"
    local min_args="$2"
    local max_args="$3"
    shift 3
    local args=("$@")

    if [ "${#args[@]}" -lt "$min_args" ] || [ "${#args[@]}" -gt "$max_args" ]; then
        log "lvl-4" "Incorrect number of arguments."
        print_usage
        clean_exit 0
    fi
}

print_usage() {
    log "lvl-4" "Usage: $0 MODE [ARGUMENT]"
    log "lvl-4" "MODE:"
    log "lvl-4" "  -i [DISPLAY_MODE]: Interactive mode. DISPLAY_MODE is optional (1-6)."
    log "lvl-4" "  -x SECTION: Executing mode. SECTION is required (function name or -all)."
}

setup_source() {
    local dir="$1"
    local file="$2"
    local base="$3"

    log "lvl-2" "Starting setup_source with dir=$dir, file=$file, base=$base"

    local lib_dir="${dir%/*}/lib"
    local var_dir="${dir%/*}/var"

    if [[ -z "$LABS_ENVIRONMENT_SOURCED" ]]; then
        log "lvl-3" "Sourcing environment files"

        # Source all .conf files in var directory
        for conf_file in "$var_dir"/*.conf; do
            if [[ -f "$conf_file" ]]; then
                log "lvl-4" "Sourcing $conf_file"
                source "$conf_file" || log_error "Failed to source $conf_file"
            fi
        done

        # Source all .bash files in lib directory
        for bash_file in "$lib_dir"/*.bash; do
            if [[ -f "$bash_file" ]]; then
                log "lvl-4" "Sourcing $bash_file"
                source "$bash_file" || log_error "Failed to source $bash_file"
            fi
        done

        export LABS_ENVIRONMENT_SOURCED=1
        log "lvl-3" "Environment sourcing completed"
    else
        log "lvl-3" "Environment already sourced, skipping..."
    fi
}

setup_main() {
    log "lvl-2" "Starting setup_main with arguments: $@"

    # Check arguments after logging has started
    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        log_error "Incorrect number of arguments."
        print_usage
        clean_exit 0
    fi

    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        log "lvl-3" "Incorrect number of arguments."
        print_usage
        return 1
    fi

    local mode="$1"
    local argument="$2"

    case "$mode" in
        -i)
            log "lvl-3" "Entering interactive mode"
            setup_interactive_mode "$argument"
            ;;
        -x)
            if [ -z "$argument" ]; then
                log_error "Section argument is required for executing mode."
                print_usage
                clean_exit 0
            fi
            log "lvl-3" "Entering executing mode"
            setup_executing_mode "$argument"
            ;;
        *)
            log_error "Invalid mode. Use -i for interactive or -x for executing."
            print_usage
            clean_exit 0
            ;;
    esac
}

setup_interactive_mode() {
    local display_choice="$1"
    log "lvl-3" "Setup interactive mode with display choice: $display_choice"

    local base_indent="          "  # Matches the indentation of lvl-4 log
    local BOLD='\033[1m'
    local RESET='\033[0m'

    printf "\n"
    printf "%s┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n" "$base_indent"
    printf "%s┃ ${BOLD}Choose a display option:${RESET}\n" "$base_indent"
    printf "%s┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n" "$base_indent"
    printf "%s┃ 1. Default display\n" "$base_indent"
    printf "%s┃ 2. Expand variables\n" "$base_indent"
    printf "%s┃ 3. Show function descriptions\n" "$base_indent"
    printf "%s┃ 4. Expand variables and show function descriptions\n" "$base_indent"
    printf "%s┃ 5. Show only function names and descriptions\n" "$base_indent"
    printf "%s┃ 6. Show only function descriptions\n" "$base_indent"
    printf "%s┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n" "$base_indent"
    printf "\n"

    if [ -z "$display_choice" ]; then
        read -p "${base_indent}Enter your choice (1-6): " display_choice
    fi

    # Validate user input
    if ! [[ "$display_choice" =~ ^[1-6]$ ]]; then
        log_error "Invalid choice. Using default display (1)."
        display_choice=1
    fi

    setup_display_menu "$DIR_SH" "$FILE_SH" "$display_choice" "-all"
    select_and_execute_sections
}


setup_executing_mode() {
    local section="$1"
    log "lvl-3" "Setup executing mode for section: $section"

    if [[ "$section" == "-all" ]]; then
        log "lvl-4" "Executing all sections"
        for func in "${!MENU_OPTIONS[@]}"; do
            log "lvl-5" "Executing section: $func"
            ${MENU_OPTIONS[$func]}
        done
    else
        if [[ -n "${MENU_OPTIONS[$section]}" ]]; then
            log "lvl-4" "Executing section: $section"
            ${MENU_OPTIONS[$section]}
        else
            log_error "Invalid section: $section"
            exit 1
        fi
    fi
}

select_and_execute_sections() {
    log "lvl-3" "Entering select_and_execute_sections"
    local base_indent="          "  # Matches the indentation of lvl-4 log
    local BOLD='\033[1m'
    local RESET='\033[0m'

    printf "\n"
    printf "%s┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n" "$base_indent"
    printf "%s┃ ${BOLD}Select sections to execute:${RESET}\n" "$base_indent"
    printf "%s┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n" "$base_indent"
    printf "%s┃ Available sections: ${BOLD}%s${RESET}\n" "$base_indent" "${!MENU_OPTIONS[*]}"
    printf "%s┃ Type 'all' to select all sections\n" "$base_indent"
    printf "%s┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n" "$base_indent"
    printf "\n"

    read -p "${base_indent}Enter section(s) separated by space, or 'all': " sections

    if [[ "$sections" == "all" ]]; then
        sections="${!MENU_OPTIONS[*]}"
        log "lvl-4" "User selected all sections"
    else
        log "lvl-4" "User selected sections: $sections"
    fi

    for section in $sections; do
        if [[ -n "${MENU_OPTIONS[$section]}" ]]; then
            log "lvl-4" "Executing section: $section"
            setup_executing_mode "$section"
        else
            log_error "Invalid section: $section. Skipping."
        fi
    done
}

# Function to expand variables
expand_variables() {
    local line="$1"
    local expanded_line="$line"

    local vars=$(echo "$line" | grep -o '\<[a-zA-Z_][a-zA-Z0-9_]*\>')

    for var in $vars; do
        if [[ -v $var ]]; then
            local value="${!var}"
            expanded_line="${expanded_line//$var/$var = $value}"
        fi
    done

    log "lvl-5" "Expanded line: $expanded_line"
    echo "$expanded_line"
}

# Function to get function description
get_function_description() {
    local func_name="$1"
    local lib_name="${func_name%%-*}"
    local lib_file="/root/lab/lib/${lib_name}.bash"

    log "lvl-4" "Getting description for function: $func_name from file: $lib_file"

    if [ ! -f "$lib_file" ]; then
        log "lvl-4" "Library file not found: $lib_file"
        return
    fi

    local description=$(awk -v fn="$func_name" '
        $0 ~ "^"fn"\\(\\)" {
            if (NR > 2) print lines[NR-3];
            exit;
        }
        {
            lines[NR] = $0;
        }
    ' "$lib_file" | sed 's/^# *//')

    if [ -n "$description" ]; then
        log "lvl-5" "Function description: $description"
        echo "--( $description )--"
    else
        log "lvl-5" "No description found for function: $func_name"
    fi
}

setup_display_menu() {
    local dir="$1"
    local file="$2"
    local display_choice="$3"
    local section="$4"
    local base_indent="          "  # Matches the indentation of lvl-4 log
    local content_indent="            "  # Matches the indentation of lvl-5 log

    # ANSI escape codes for bold text and reset
    local BOLD='\033[1m'
    local RESET='\033[0m'

    log "lvl-4" "Scanning file $file for *_xall functions"
    printf "\n"
    printf "%s┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n" "$base_indent"
    grep -E '^[a-zA-Z_]+_xall\(\)' "$dir/$file" | while IFS= read -r line; do
        func_name=$(echo "$line" | awk -F'(' '{print $1}')
        if [[ "$section" == "-all" || "${func_name%%_xall}" == "$section" ]]; then
            printf "%s┣━━━ ${BOLD}( %s )${RESET}\n" "$base_indent" "${func_name%%_xall}"
            in_function=false
            first_line=true
            while IFS= read -r inner_line; do
                if $first_line; then
                    first_line=false
                    in_function=true
                    continue
                fi
                if [[ "$inner_line" == "}" ]]; then
                    in_function=false
                    printf "%s┃\n" "$base_indent"
                elif $in_function; then
                    case "$display_choice" in
                        1)
                            printf "%s┃ %s\n" "$base_indent" "$inner_line"
                            ;;
                        2)
                            printf "%s┃ %s\n" "$base_indent" "$(expand_variables "$inner_line")"
                            ;;
                        3)
                            if [[ "$inner_line" =~ ^[[:space:]]*([a-zA-Z_-]+) ]]; then
                                local func="${BASH_REMATCH[1]}"
                                local desc="$(get_function_description "$func")"
                                printf "%s┃ %s %s\n" "$base_indent" "${inner_line#"${inner_line%%[![:space:]]*}"}" "$desc"
                            else
                                printf "%s┃ %s\n" "$base_indent" "${inner_line#"${inner_line%%[![:space:]]*}"}"
                            fi
                            ;;
                        4)
                            if [[ "$inner_line" =~ ^[[:space:]]*([a-zA-Z_-]+) ]]; then
                                local func="${BASH_REMATCH[1]}"
                                local desc="$(get_function_description "$func")"
                                printf "%s┃ %s %s\n" "$base_indent" "$(expand_variables "${inner_line#"${inner_line%%[![:space:]]*}"}")" "$desc"
                            else
                                printf "%s┃ %s\n" "$base_indent" "$(expand_variables "${inner_line#"${inner_line%%[![:space:]]*}"}")"
                            fi
                            ;;
                        5)
                            if [[ "$inner_line" =~ ^[[:space:]]*([a-zA-Z_-]+) ]]; then
                                local func="${BASH_REMATCH[1]}"
                                local desc="$(get_function_description "$func")"
                                if [ -n "$desc" ]; then
                                    printf "%s┃ %s: %s\n" "$base_indent" "$func" "$desc"
                                fi
                            fi
                            ;;
                        6)
                            if [[ "$inner_line" =~ ^[[:space:]]*([a-zA-Z_-]+) ]]; then
                                local func="${BASH_REMATCH[1]}"
                                local desc="$(get_function_description "$func")"
                                if [ -n "$desc" ]; then
                                    printf "%s┃ %s\n" "$base_indent" "$desc"
                                fi
                            fi
                            ;;
                    esac
                fi
            done < <(sed -n "/^${func_name}()/,/^}/p" "$dir/$file")
        fi
    done
    printf "%s┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n" "$base_indent"
    printf "\n"
}

# Main execution is not needed in .up file as it's sourced by gen.sh
